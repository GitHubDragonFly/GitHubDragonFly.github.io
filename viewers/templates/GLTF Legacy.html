<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="encoding" content="utf-8" charset="utf-8">
    <meta name="description" content="GLTF v1.0 Viewer">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <link rel="shortcut icon" href="../../images/favicon.ico" type="image/x-icon"/>

    <script src="../static/model-tag/dist/model-gltf.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.135.0/build/three.min.js" defer></script>
    <script src="../static/js/exporters/OBJExporter.js" defer></script>
    <script src="../static/js/exporters/GLTFExporter.js" defer></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js" defer></script>

    <style>
      body, html {
        position: relative;
        display: block;
        width: 100%;
        min-height: 100vh;
        border: none;
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: black;
      }

      button {
        border: 1px solid blue;
        -webkit-border-radius: 2px;
        border-radius: 2px;
        margin: 2px 2px 2px 0;
        min-width: 22px;
        height: 22px;
        padding: 1px;
        vertical-align: middle;
      }

      label {
        vertical-align: middle;
        height: 22px;
        margin: 2px;
      }

      input[type=file] {
        vertical-align: middle;
        margin: 2px 0 2px 0;
        max-width: 175px;
      }

      input[type=number] { vertical-align: middle; margin: 2px 2px 2px 0; }

      input[type=text] {
        vertical-align: middle;
        margin: 2px 2px 2px 0;
      }

      select {
        border: 1px solid blue;
        -webkit-border-radius: 2px;
        border-radius: 2px;
        margin: 3px;
        padding: 2px;
        vertical-align: middle;
        min-width: 70px;
        height: 22px;
        color: blue;
        background: none;
      }

      .error_msg {
        background-color: transparent;
        position: absolute;
        text-align: center;
        font-size: x-large;
        display: none;
        color: red;
        width: 240px;
        height: 240px;
        top: 50%;
        left: 50%;
        margin-left: -127px;
        padding: 10px;
        border: none;
        z-index: 99;
      }

      p.full_screen {
        text-align: center;
        content: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAf0lEQVRIie1VQQ6AMAjb/x9M4IRePICoK7GLB5eQbElpCTAY7j6YRiUPAvvxbNMkN76XIDhSRKCdjhmB494hzzwngcoBIa/eASgisMgTBo4ODqCTAiSFrW6Biv8LfL/I1DbtfDRV9VLgjVFhZp59A4g+7JaM6yULh7IyWUYX2AAPDxz26GjX+gAAAABJRU5ErkJggg==);
        margin: 1px 1px 1px 2px;
        padding: 0;
        width: 15px;
        height: 15px;
      }

      .fm { color: navy; width: 99.25%; border: 1px solid navy; -webkit-border-radius: 3px; border-radius: 3px; padding: 4px; margin: 1px; }

      .fixed-menu {
        background-color: whitesmoke;
        position: fixed;
        float: left;
        z-index: 99;
        padding: 1px;
        width: 100%;
        margin: 0;
      }
    </style>

    <!-- Using modified version of GLTF model-tag from: https://github.com/mrdoob/model-tag -->
    <!-- GLTF v1.0 example models available at: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/1.0 -->

    <title>GLTF v1.0 Viewer</title>
  </head>
  <body onload="reset();" onresize="resize();">
    <div id="fixed_menu" class="fixed-menu">
      <div class="fm">
        <label title="GLTF v1.0 only. GLB is not supported." style="color: #553801; margin-left: 2px; margin-right: 3px;">GLTF</label>
        <button id="btn_url" title="URL of the remote GLTF v1.0 model" onclick="show_url();" style="min-width: 34px;">URL</button>
        <input type="file" title="Browse Local Files" id="file_input" name="file_input" onchange="init();" accept=".gltf, .bin, .glsl, image/png, image/jpeg, image/bmp, image/gif, image/svg+xml, image/webp" multiple />
        <select id="export_names" name="export_names" title="Export" disabled>
          <option value="" selected disabled>Export</option>
          <option value="obj" onclick="export_obj();">OBJ</option>
          <option value="glb" onclick="export_glb();">GLB</option>
          <option value="gltf" onclick="export_gltf();">GLTF</option>
        </select>
        <button id="btn_full_screen" title="Full Screen" onclick="full_screen();" style="float: right; min-width: 24px;"><p class="full_screen"></p></button>
      </div>
      <div class="fm" id="url" style="display: none;">
        <input type="text" id="url_entry" name="url_entry" value="" style="width: 75%;" />
        <button onclick="load_url_file();" style="min-width: 38px;">Load</button>
        <button onclick="clear_url();" style="min-width: 38px;">Clear</button>
      </div>
      <div class="fm">
        <label for="camera_id" title="Camera ID" style="color: #553801;">CAM</label>
        <input type="number" title="Camera ID" id="camera_id" name="camera_id" onkeydown="return_false();" onchange="set_camera_id();" min="0" max="0" value="0" step="1" style="width: 38px;" disabled />
        <label title="Camera Position" style="color: #553801;">POS</label>
        <label for="camera_x" title="X-Axis">X</label>
        <input type="number" title="X-Axis" id="camera_x" name="camera_x" onkeydown="return_false();" onchange="set_camera_x();" min="-1000" max="1000" value="0" step="1" style="width: 48px;" disabled />
        <label for="camera_y" title="Y-Axis">Y</label>
        <input type="number" title="Y-Axis" id="camera_y" name="camera_y" onkeydown="return_false();" onchange="set_camera_y();" min="-1000" max="1000" value="0" step="1" style="width: 48px;" disabled />
        <label for="camera_z" title="Z-Axis">Z</label>
        <input type="number" title="Z-Axis" id="camera_z" name="camera_z" onkeydown="return_false();" onchange="set_camera_z();" min="-1000" max="1000" value="25" step="1" style="width: 48px;" disabled />
        <button id="btn_rotate" title="Rotate Scene" onclick="set_rotation();" style="margin-left: 2px;" disabled>R</button>
      </div>
      <div id="div_model_gltf" style="display: block; z-index: 1; text-align: center; width: 99.75%; height: 100vh; margin-top: 30px;">
        <model-gltf id="model_gltf" src="#" blobs="#" />
      </div>
    </div>

    <div id="div_error" class="error_msg"></div>

    <script>
      const model_extensions = [ '.GLTF' ];
      const file_extensions = [ '.BIN', '.GLSL', '.PNG', '.JPG', '.JPEG', '.JFIF', '.PJPEG', '.PJP', '.BMP', '.GIF', '.SVG', '.WEBP' ];

      function return_false() { return false; }

      function set_rotation() {
        let scene = document.getElementById('model_gltf').scene;

        if (scene.rotate === true) {
          scene.rotate = false;
          document.getElementById('btn_rotate').style.backgroundColor = 'transparent';
        } else {
          scene.rotate = true;
          document.getElementById('btn_rotate').style.backgroundColor = 'lightgreen';
        }
      }

      function set_camera_id() {
        let current_id = document.getElementById('camera_id').value;
        let model_gltf = document.getElementById('model_gltf');

        model_gltf.camera = model_gltf.cameras[ current_id ];
        document.getElementById('camera_x').value = model_gltf.cameras[ current_id ].position.x;
        document.getElementById('camera_y').value = model_gltf.cameras[ current_id ].position.y;
        document.getElementById('camera_z').value = model_gltf.cameras[ current_id ].position.z;
      }

      function set_camera_x() {
        let current_x = document.getElementById('camera_x').value;
        let camera = document.getElementById('model_gltf').camera;

        camera.position.x = current_x;
      }

      function set_camera_y() {
        let current_y = document.getElementById('camera_y').value;
        let camera = document.getElementById('model_gltf').camera;

        camera.position.y = current_y;
      }

      function set_camera_z() {
        let current_z = document.getElementById('camera_z').value;
        let camera = document.getElementById('model_gltf').camera;

        camera.position.z = current_z;
      }

      function show_url() {
        if (url_displayed === true) {
          document.getElementById('url').style.display = 'none';
          url_displayed = false;
        } else {
          document.getElementById('url').style.display = 'block';
          url_displayed = true;
        }
      }

      function load_url_file() {
        let url = document.getElementById('url_entry').value.trim();
        if (url !== '') {
          selected_url_file = url;
          url_loading = true;
          init();
        }
      }

      function clear_url() { document.getElementById('url_entry').value = ''; }

      function reset( values_only = false ) {
        document.getElementById('div_error').style.display = 'none';

        document.getElementById('camera_id').value = 0;
        document.getElementById('camera_id').max = 0;
        document.getElementById('camera_x').value = 0;
        document.getElementById('camera_y').value = 0;
        document.getElementById('camera_z').value = 25;
        document.getElementById('btn_rotate').style.backgroundColor = 'transparent';

        if (values_only === false) {
          document.getElementById('file_input').value = '';
          document.getElementById('url_entry').value = '';
        }

        enable_disable( true );
      }

      function enable_disable( disabled = false ) {
        document.getElementById('camera_id').disabled = disabled;
        document.getElementById('camera_x').disabled = disabled;
        document.getElementById('camera_y').disabled = disabled;
        document.getElementById('camera_z').disabled = disabled;
        document.getElementById('btn_rotate').disabled = disabled;
        document.getElementById('export_names').disabled = disabled;
      }

      function resize() {
        if (window.fullScreen || document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement) {
          document.getElementById('btn_full_screen').style.backgroundColor = '#FFFF00';
        } else {
          document.getElementById('btn_full_screen').style.backgroundColor = 'transparent';
        }
      }

      function full_screen() {
        if (document.fullscreenEnabled) {
          document.fullscreenElement ? document.exitFullscreen() : document.body.requestFullscreen();
        } else if (document.mozFullScreenEnabled) {
          document.mozFullScreenElement ? document.mozCancelFullScreen() : document.body.mozRequestFullScreen();
        } else if (document.msFullscreenEnabled) {
          document.msFullscreenElement ? document.msExitFullscreen() : document.body.msRequestFullscreen();
        } else if (document.webkitFullscreenEnabled) {
          document.webkitFullscreenElement ? document.webkitExitFullscreen() : document.body.webkitRequestFullscreen();
        } else if (window.fullScreen) {
          // Do nothing. This fullscreen mode was triggered with F11 key press and requires the same again.
        }
      }
    </script>

    <script>
      var manager, filename, local_blobs, url_displayed = false, url_loading = false;
      var selected_model_file, selected_url_model_file, selected_url_file = '';

      const link = document.createElement( 'a' );
      link.style.display = 'none';
      document.body.appendChild( link );

      function export_obj() {
        document.getElementById('export_names').selectedIndex = 0;

        let mesh = document.getElementById('model_gltf').scene.clone();

        mesh.traverse( ( child ) => {
          if (child.isMesh && child.geometry.isBufferGeometry) {
            child.geometry = new THREE.BufferGeometry().copy( child.geometry ); // instance of new BufferGeometry for export
            if ( child.geometry.userData === undefined ) child.geometry.userData = {};
            if ( child.geometry.morphTargetsRelative === undefined ) child.geometry.morphTargetsRelative = {};

            let ambient = child.material.uniforms.u_ambient ? child.material.uniforms.u_ambient.value : null;
            let diffuse = child.material.uniforms.u_diffuse ? child.material.uniforms.u_diffuse.value : null;
            let diffuse_color = (diffuse && diffuse.isVector4) ? new THREE.Color().setRGB( diffuse.x, diffuse.y, diffuse.z ) : null;
            let emissive = child.material.uniforms.u_emissive ? child.material.uniforms.u_emissive.value : null;
            let emissive_color = (emissive && emissive.isVector4) ? new THREE.Color().setRGB( emissive.x, emissive.y, emissive.z ) : null;
            let specular = child.material.uniforms.u_specular ? child.material.uniforms.u_specular.value : null;
            let specular_color = (specular && specular.isVector4) ? new THREE.Color().setRGB( specular.x, specular.y, specular.z ) : null;
            let shininess = child.material.uniforms.u_shininess ? child.material.uniforms.u_shininess.value : 0;

            child.material = new THREE.MeshPhongMaterial({
              side: THREE.DoubleSide,
              opacity: child.material.opacity || 1,
              shininess: child.material.shininess || shininess,
              vertexColors: child.material.vertexColors || false,
              color: child.material.color ? child.material.color : (diffuse_color ? diffuse_color : child.material.defaultAttributeValues.color),
              map: child.material.map ? child.material.map : (diffuse ? (diffuse.isVector4 ? null : diffuse) : null),
              envMap: child.material.envMap ? child.material.envMap : (ambient ? (ambient.isVector4 ? null : ambient) : null),
              emissive: child.material.emissive ? child.material.emissive : (emissive_color ? emissive_color : new THREE.Color( 0, 0, 0 )),
              emissiveMap: child.material.emissiveMap ? child.material.emissiveMap : (emissive ? (emissive.isVector4 ? null : emissive) : null),
              specular: child.material.specular ? child.material.specular : (specular_color ? specular_color : new THREE.Color( 0, 0, 0 )),
              specularMap: child.material.specularMap ? child.material.specularMap : (specular ? (specular.isVector4 ? null : specular) : null)
            });
          }
        });

        const obj_exporter = new THREE.OBJExporter( manager );

        if (selected_model_file) {
          filename = selected_model_file.name.substring( 0, selected_model_file.name.lastIndexOf('.') + 1 );
        } else if (selected_url_model_file) {
          filename = selected_url_model_file.substring( selected_url_model_file.lastIndexOf('/') + 1, selected_url_model_file.lastIndexOf('.') + 1 );
        }

        let exported = obj_exporter.parse( mesh, filename );
        let obj = exported[ 'obj' ].split( ',' );
        let blob = new Blob( [ obj ], { type: 'text/plain' } );
        link.href = URL.createObjectURL( blob );
        URL.revokeObjectURL( blob );
        link.download = filename + 'obj';
        link.click();

        if (exported[ 'mtl' ]) {
          let mtl = exported[ 'mtl' ].split( ',' );
          blob = new Blob( [ mtl ], { type: 'text/plain' } );
          link.href = URL.createObjectURL( blob );
          URL.revokeObjectURL( blob );
          link.download = filename + 'mtl';
          link.click();

          exported[ 'tex' ].forEach( tex => {
            blob = new Blob( [ tex.data ], { type: 'image/png' } );

            let img = new Image();

            img.onload = function() {
              let canvas = document.createElement('canvas');

              canvas.width = img.naturalWidth;
              canvas.height = img.naturalHeight;

              let ctx = canvas.getContext( '2d' );

              // Flip image vertically
              ctx.scale( 1, -1 );
              ctx.drawImage( img, 0, -canvas.height );

              link.href = canvas.toDataURL( 'image/png' );
              link.download = `${ tex.name }.${ tex.ext }`;
              link.click();
            }

            img.src = URL.createObjectURL( blob );
            URL.revokeObjectURL( blob );
          });
        }
      }

      function export_gltf() {
        document.getElementById('export_names').selectedIndex = 0;

        let mesh = document.getElementById('model_gltf').scene.clone();

        mesh.traverse( ( child ) => {
          if (child.isMesh && child.geometry.isBufferGeometry) {
            child.geometry = new THREE.BufferGeometry().copy( child.geometry ); // instance of new BufferGeometry for export
            if ( child.geometry.userData === undefined ) child.geometry.userData = {};
            if ( child.geometry.morphTargetsRelative === undefined ) child.geometry.morphTargetsRelative = {};

            let ambient = child.material.uniforms.u_ambient ? child.material.uniforms.u_ambient.value : null;
            let diffuse = child.material.uniforms.u_diffuse ? child.material.uniforms.u_diffuse.value : null;
            let diffuse_color = (diffuse && diffuse.isVector4) ? new THREE.Color().setRGB( diffuse.x, diffuse.y, diffuse.z ) : null;
            let emissive = child.material.uniforms.u_emissive ? child.material.uniforms.u_emissive.value : null;
            let emissive_color = (emissive && emissive.isVector4) ? new THREE.Color().setRGB( emissive.x, emissive.y, emissive.z ) : null;
            let specular = child.material.uniforms.u_specular ? child.material.uniforms.u_specular.value : null;
            let specular_color = (specular && specular.isVector4) ? new THREE.Color().setRGB( specular.x, specular.y, specular.z ) : null;
            let shininess = child.material.uniforms.u_shininess ? child.material.uniforms.u_shininess.value : 0;

            child.material = new THREE.MeshPhongMaterial({
              side: THREE.DoubleSide,
              opacity: child.material.opacity || 1,
              shininess: child.material.shininess || shininess,
              vertexColors: child.material.vertexColors || false,
              color: child.material.color ? child.material.color : (diffuse_color ? diffuse_color : child.material.defaultAttributeValues.color),
              map: child.material.map ? child.material.map : (diffuse ? (diffuse.isVector4 ? null : diffuse) : null),
              envMap: child.material.envMap ? child.material.envMap : (ambient ? (ambient.isVector4 ? null : ambient) : null),
              emissive: child.material.emissive ? child.material.emissive : (emissive_color ? emissive_color : new THREE.Color( 0, 0, 0 )),
              emissiveMap: child.material.emissiveMap ? child.material.emissiveMap : (emissive ? (emissive.isVector4 ? null : emissive) : null),
              specular: child.material.specular ? child.material.specular : (specular_color ? specular_color : new THREE.Color( 0, 0, 0 )),
              specularMap: child.material.specularMap ? child.material.specularMap : (specular ? (specular.isVector4 ? null : specular) : null)
            });
          }
        });

        let gltf_exporter = new THREE.GLTFExporter( manager );

        if (mesh) {
          if (selected_model_file) {
            filename = selected_model_file.name.substring( 0, selected_model_file.name.lastIndexOf('.') + 1 );
          } else if (selected_url_model_file) {
            filename = selected_url_model_file.substring( selected_url_model_file.lastIndexOf('/') + 1, selected_url_model_file.lastIndexOf('.') + 1 );
          }

          let options = {	binary: false, maxTextureSize: 4096 || Infinity };

          gltf_exporter.parse( mesh, ( json ) => {
            let string = JSON.stringify( json, null, 2 );
            let blob = new Blob( [ string ], { type: 'text/plain' } );
            link.href = URL.createObjectURL( blob );
            link.download = filename + 'gltf';
            link.click();
          }, function( error ) { console.log( error ); }, options );
        }
      }

      function export_glb() {
        document.getElementById('export_names').selectedIndex = 0;

        let mesh = document.getElementById('model_gltf').scene.clone();

        mesh.traverse( ( child ) => {
          if (child.isMesh && child.geometry.isBufferGeometry) {
            child.geometry = new THREE.BufferGeometry().copy( child.geometry ); // instance of new BufferGeometry for export
            if ( child.geometry.userData === undefined ) child.geometry.userData = {};
            if ( child.geometry.morphTargetsRelative === undefined ) child.geometry.morphTargetsRelative = {};

            let ambient = child.material.uniforms.u_ambient ? child.material.uniforms.u_ambient.value : null;
            let diffuse = child.material.uniforms.u_diffuse ? child.material.uniforms.u_diffuse.value : null;
            let diffuse_color = (diffuse && diffuse.isVector4) ? new THREE.Color().setRGB( diffuse.x, diffuse.y, diffuse.z ) : null;
            let emissive = child.material.uniforms.u_emissive ? child.material.uniforms.u_emissive.value : null;
            let emissive_color = (emissive && emissive.isVector4) ? new THREE.Color().setRGB( emissive.x, emissive.y, emissive.z ) : null;
            let specular = child.material.uniforms.u_specular ? child.material.uniforms.u_specular.value : null;
            let specular_color = (specular && specular.isVector4) ? new THREE.Color().setRGB( specular.x, specular.y, specular.z ) : null;
            let shininess = child.material.uniforms.u_shininess ? child.material.uniforms.u_shininess.value : 0;

            child.material = new THREE.MeshPhongMaterial({
              side: THREE.DoubleSide,
              opacity: child.material.opacity || 1,
              shininess: child.material.shininess || shininess,
              vertexColors: child.material.vertexColors || false,
              color: child.material.color ? child.material.color : (diffuse_color ? diffuse_color : child.material.defaultAttributeValues.color),
              map: child.material.map ? child.material.map : (diffuse ? (diffuse.isVector4 ? null : diffuse) : null),
              envMap: child.material.envMap ? child.material.envMap : (ambient ? (ambient.isVector4 ? null : ambient) : null),
              emissive: child.material.emissive ? child.material.emissive : (emissive_color ? emissive_color : new THREE.Color( 0, 0, 0 )),
              emissiveMap: child.material.emissiveMap ? child.material.emissiveMap : (emissive ? (emissive.isVector4 ? null : emissive) : null),
              specular: child.material.specular ? child.material.specular : (specular_color ? specular_color : new THREE.Color( 0, 0, 0 )),
              specularMap: child.material.specularMap ? child.material.specularMap : (specular ? (specular.isVector4 ? null : specular) : null)
            });
          }
        });

        let gltf_exporter = new THREE.GLTFExporter( manager );

        if (mesh) {
          if (selected_model_file) {
            filename = selected_model_file.name.substring( 0, selected_model_file.name.lastIndexOf('.') + 1 );
          } else if (selected_url_model_file) {
            filename = selected_url_model_file.substring( selected_url_model_file.lastIndexOf('/') + 1, selected_url_model_file.lastIndexOf('.') + 1 );
          }

          let options = {	binary: true, maxTextureSize: 4096 || Infinity };

          gltf_exporter.parse( mesh, ( json ) => {
            let blob = new Blob( [ json ], { type: 'application/octet-stream' } );
            link.href = URL.createObjectURL( blob );
            link.download = filename + 'glb';
            link.click();
          }, function( error ) { console.log( error ); }, options );
        }
      }

      function init() {
        if (manager === undefined) manager = new THREE.LoadingManager();

        reset( true );

        if (url_loading === false) {
          selected_model_file = null;
          selected_url_file = '';
          local_blobs = '';

          // Locally loaded files
          var fi = document.getElementById('file_input');

          for (let i = 0; i < fi.files.length; i++) {
            let ext = fi.files[ i ].name.toUpperCase().substring( fi.files[ i ].name.lastIndexOf( '.' ) );

            if (model_extensions.includes( ext )) {
              selected_model_file = fi.files[ i ];
            } else if (file_extensions.includes( ext )) {
              local_blobs += fi.files[ i ].name + ',' + URL.createObjectURL( fi.files[ i ] ) + ',';
              URL.revokeObjectURL( fi.files[ i ] );
            }
          };

          if (selected_model_file === null) {
            console.log( 'No valid model file selected!' );
            return;
          }

          if (local_blobs.length > 0) local_blobs = local_blobs.slice( 0, - 1 );
        } else {
          selected_url_model_file = null;
          selected_model_file = null;
          url_loading = false;

          // Reset the file input
          document.getElementById('file_input').value = '';
        }

        // Load the model
        selected_model_file !== null ? loadFile() : loadURLFile();
      }

      async function loadFile() {
        let mdl_gltf = document.getElementById('model_gltf');
        mdl_gltf.attributes.src = '#';

        await new Promise( resolve => setTimeout( resolve, 50 ) ); // adjust timing if necessary

        mdl_gltf.remove();

        let src_attr = document.createAttribute('src');
        src_attr.value = URL.createObjectURL( selected_model_file );
        URL.revokeObjectURL( selected_model_file );

        let model_gltf = document.createElement('model-gltf');
        model_gltf.id = 'model_gltf';

        if (local_blobs !== '') {
          let blobs_attr = document.createAttribute('blobs');
          blobs_attr.value = local_blobs;

          model_gltf.attributes.setNamedItem( blobs_attr );
        }

        document.getElementById('div_model_gltf').appendChild( model_gltf );

        model_gltf.onLoad = function( data ) {
          enable_disable( false );

          if (data.cameras && data.cameras.length > 1) {
            document.getElementById('camera_id').max = data.cameras.length - 1;
            document.getElementById('camera_x').value = data.cameras[ 0 ].position.x;
            document.getElementById('camera_y').value = data.cameras[ 0 ].position.y;
            document.getElementById('camera_z').value = data.cameras[ 0 ].position.z;
          } else {
            document.getElementById('camera_id').disabled = true;
          }
        }

        model_gltf.onError = function( error ) {
          document.getElementById('div_error').style.display = 'block';
          document.getElementById('div_error').innerText = error;
          return;
        }

        model_gltf.attributes.setNamedItem( src_attr );
      }

      async function loadURLFile() {
        if (selected_url_file !== '') {
          if (selected_url_file.indexOf( ',' ) > -1) {
            let urls = selected_url_file.split( ',' );

            for (let i = 0; i < urls.length; i++) {
              let url = urls[ i ].trim();
              let ext = url.toUpperCase().substring( url.lastIndexOf( '.' ) );

              if (model_extensions.includes( ext )) selected_url_model_file = url;
            }
          } else {
            let ext = selected_url_file.toUpperCase().substring( selected_url_file.lastIndexOf( '.' ) );
            if (model_extensions.includes( ext )) selected_url_model_file = selected_url_file;
          }

          if (selected_url_model_file !== null) {
            let mdl_gltf = document.getElementById('model_gltf');
            mdl_gltf.attributes.src = '#';

            await new Promise( resolve => setTimeout( resolve, 50 ) ); // adjust timing if necessary

            mdl_gltf.remove();

            let src_attr = document.createAttribute('src');
            src_attr.value = selected_url_model_file;

            let model_gltf = document.createElement('model-gltf');
            model_gltf.id = 'model_gltf';

            document.getElementById('div_model_gltf').appendChild( model_gltf );

            model_gltf.onLoad = function( data ) {
              enable_disable( false );

              if (data.cameras && data.cameras.length > 1) {
                document.getElementById('camera_id').max = data.cameras.length - 1;
                document.getElementById('camera_x').value = data.cameras[ 0 ].position.x;
                document.getElementById('camera_y').value = data.cameras[ 0 ].position.y;
                document.getElementById('camera_z').value = data.cameras[ 0 ].position.z;
              } else {
                document.getElementById('camera_id').disabled = true;
              }
            }

            model_gltf.onError = function( error ) {
              document.getElementById('div_error').style.display = 'block';
              document.getElementById('div_error').innerText = error;
              return;
            }

            model_gltf.attributes.setNamedItem( src_attr );
          } else {
            console.log( 'No valid URL model file selected!' );
            enable_disable( true );
          }
        }
      }
    </script>
  </body>
</html>
