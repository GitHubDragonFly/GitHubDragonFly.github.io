<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="encoding" content="utf-8" charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="PLY (Polygon) + STL (Stereolithography) Viewer">
    <link rel="stylesheet" href="../../static/css/mobile-viewers.css">
    <link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon"/>

    <script>
      // Resource Loading Failures (404 or similar)
      window.addEventListener( 'error', function ( event ) {
        // We check if the target has a 'src' or 'href' to identify it as a resource
        if (event.target.src || event.target.href) {
          console.error( 'RESOURCE ERROR: ', {
            element: event.target.tagName,
            url: event.target.src || event.target.href,
            html: event.target.outerHTML
          });

          // If the failed resource is jQuery, show the alert immediately
          if ((event.target.src || '').includes('jquery')) {
            alert('jQuery failed to load. Limited functionality. Check your internet connection!');
          }
        }
      }, true); // The 'true' here is vital; it enables the "capturing" phase

      // Standard JavaScript Runtime Errors
      window.onerror = function ( message, source, lineno, colno, error ) {
        console.log( 'RUNTIME ERROR CAUGHT' );

        console.log({
          message: message, // Error message
          file: source,     // The script file where it happened
          line: lineno,     // Line number
          column: colno,    // Column number
          errorObj: error   // The actual Error object (includes stack trace)
        });

        // Returning 'true' prevents the error from showing up in the browser console
        return false; 
      };

      // Unhandled Promise Rejections (Async Errors)
      window.addEventListener( 'unhandledrejection', function ( event ) {
        console.warn( 'UNHANDLED PROMISE: ', event.reason );

        // event.promise is the promise that failed
        // event.reason is usually the error object or message

        if (init_running === true) handle_error( 'UNHANDLED PROMISE' );
      });
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2.8.0/dist/es-module-shims.min.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.module.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/"
        }
      }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" defer></script>

    <script>
      var THREE, manager, ply_loader, stl_loader, renderer, scene, camera, render_requested;
      var controls, mouse_down, mouse_wheel, events_initialized, init_running = false;
      var mesh, bounding_box, flat_shading_enabled, object_is_points;
      var gui, gui_container, gui_set = false, params;
      var merge_vertices, wireframe_enabled, isMobile;
      var ww = window.innerWidth, wh = window.innerHeight;
      var min_allowed_point_size, max_allowed_point_size, count = 0;
      var url_displayed = false, url_loading = false, url_ply;
      var selected_ply_file, selected_stl_file, selected_url_file = '';
    </script>

    <script type="module">
      import * as three_js from "three";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { STLLoader } from "three/addons/loaders/STLLoader.min.js";
      import { PLYLoader } from "three/addons/loaders/PLYLoader.min.js";

      THREE = three_js;

      manager = new THREE.LoadingManager();
      manager.onLoad = function() { mouse_wheel = true; }

      ply_loader = new PLYLoader( manager );
      stl_loader = new STLLoader( manager );

      gui_container = document.getElementById('gui_position');

      // Override external CSS so we can have GUI in the top-right corner
      gui_container.style.left = 'auto';         // Reset any left-side positioning
      gui_container.style.right = '3px';         // Anchor to the right
      gui_container.style.top = '2px';           // Anchor to the top
      gui_container.style.marginLeft = '0px';    // Clear the 2px margin from your CSS

      gui = new GUI( { autoPlace: false, container: gui_container } );
      set_gui_position();
    </script>

    <!-- Original OBJ source code that inspired this: https://codepen.io/Mamboleoo/pen/PqjGdN -->
    <!-- Using three.js library: https://github.com/mrdoob/three.js -->

    <!-- mouse_wheel variable is used throughout as a trigger for rendering -->

    <title>PLY+STL Viewer (r183)</title>
  </head>
  <body onload="reset_all(); document_ready(); disabled_changed();" onresize="resize();">
    <div id="fixed_menu" class="fixed-menu">
      <div class="fm">
        <button id="btn_desktop" title="Open Desktop Version" onclick="switch_to_desktop();">D</button>
        <label for="btn_desktop" title="Open Desktop Version"></label>
        <button title="Get remote model via URL" id="btn_url" onclick="show_url()" style="min-width: 38px;">URL</button>
        <label for="btn_url" title="Get remote model via URL"></label>
        <button title="Browse Local Files" id="btn_file_input" style="min-width: 54px;" onclick="document.getElementById('file_input').click();">Browse</button>
        <label for="btn_file_input" title="Browse Local Files"></label>
        <input type="file" id="file_input" style="display: none;" onchange="init();" accept=".ply, .stl" />
        <label for="back_color" title="Background Color">B</label>
        <input type="color" title="Background Color" id="back_color" onchange="set_back_color();" disabled />
        <button title="Flat Shading" id="btn_flat" onclick="set_flat();" style="display: none;">F</button>
        <label for="btn_flat" title="Flat Shading"></label>
        <button title="Wireframe" id="btn_wireframe" onclick="show_wireframe();" style="display: none;">W</button>
        <label for="btn_wireframe" title="Wireframe"></label>
        <button title="Quick -90 degree X-Axis Rotation" id="btn_quick_x" onclick="quick_x_rotation();" style="min-width: 15px;" disabled>&#x2191</button>
        <label for="btn_quick_x" title="Quick -90 degree X-Axis Rotation"></label>
        <button title="Increase Points Size" id="btn_plus" onclick="increase_points_size();" style="display: none; color: red;">+</button>
        <label for="btn_plus" title="Increase Points Size"></label>
        <button title="Decrease Points Size" id="btn_minus" onclick="decrease_points_size();" style="display: none; color: red;">-</button>
        <label for="btn_minus" title="Decrease Points Size"></label>
        <div id="status_indicator" class="indicator"></div>
      </div>
      <div class="fm" id="url" style="display: none;">
        <label for="url_entry" title="Remote URL"></label>
        <input type="text" id="url_entry" value="" style="width: calc(75% - 12px);" />
        <button title="Load" id="btn_load" onclick="load_url_file();" style="min-width: 8.5%;">Load</button>
        <label for="btn_load" title="Load"></label>
        <button title="Clear" id="btn_clear" onclick="clear_url();" style="min-width: 8.5%;">Clear</button>
        <label for="btn_clear" title="Clear"></label>
      </div>
    </div>
    <div id="gui_position"></div>
    <div id="div_error" class="error_msg">E R R O R !</div>
    <div id="div_loading" class="loading_msg">PLY+STL Viewer</div>

    <script>
      function switch_to_desktop() {
        let link = document.createElement( 'a' );
        link.style.display = 'none';
        link.href = "../PLY Viewer.html";
        link.click();
      }

      function show_url() {
        if (url_displayed === true) {
          url_displayed = false;
          document.getElementById('url').style.display = 'none';
          document.getElementById('btn_url').style.backgroundColor = 'transparent';
        } else {
          document.getElementById('btn_url').style.backgroundColor = 'lightgreen';
          document.getElementById('url').style.display = 'block';
          url_displayed = true;
        }

        resize();
      }

      function load_url_file() {
        let url = document.getElementById('url_entry').value.trim();
        if (url !== '') { selected_url_file = url; url_loading = true; init(); }
      }

      function clear_url() { document.getElementById('url_entry').value = ''; }

      function initialize_event_listeners() {
        const arrow_keys = [ 'ArrowUp', 'ArrowDown', 'ArrowRight', 'ArrowLeft' ];
        const activeKeys = new Set();

        window.addEventListener( 'pointerdown', (event) => { mouse_down = true; }, false);
        window.addEventListener( 'pointerup', (event) => { mouse_down = false; }, false);
        window.addEventListener( 'pointercancel', ( event ) => { mouse_down = false; mouse_wheel = false; }, false);
        window.addEventListener( 'wheel', ( event ) => { mouse_wheel = true; }, false);
        window.addEventListener( 'keydown', ( event ) => {
          if (arrow_keys.some( k => k === event.key ) || event.ctrlKey || event.metaKey || event.shiftKey) {
            controls.listenToKeyEvents( window );
            activeKeys.add( event.key ); // Track this key
            mouse_wheel = true;
          }
        }, false);
        window.addEventListener( 'keyup', ( event ) => {
          activeKeys.delete( event.key ); // Remove this key

          if ( controls && activeKeys.size === 0 ) {
            controls.stopListenToKeyEvents();
            mouse_wheel = false;
          }
        }, false);
      }

      function gui_reset() {
        params.brightness = 2.0;
        params.roughness = 0.5;
        params.metalness = 0.0;

        gui.reset();

        gui_container.style.display = 'none';
      }

      function set_gui_position() {
        let fixed_menu_bottom = ( parseInt( $('#fixed_menu').outerHeight( true ) ) + 2 ).toString() + 'px';
        gui_container.style.marginTop = fixed_menu_bottom;
      }

      function resize() {
        if (scene !== undefined) {
          mouse_wheel = true;

          ww = window.innerWidth;
          wh = window.innerHeight;

          renderer.setSize( ww, wh );

          camera.aspect = ww / wh;
          camera.updateProjectionMatrix();

          if (gui) set_gui_position();

          mouse_wheel = true;
        }
      }
    </script>

    <script>
      function set_back_color() {
        scene.background = null;
        document.body.style.backgroundColor = document.getElementById('back_color').value;
        mouse_wheel = true;
      }

      function increase_points_size() {
        if (mesh && mesh.isPoints && mesh.material.uniforms) {
          let newSize = mesh.material.uniforms.uSize.value * 1.1;
          mesh.material.uniforms.uSize.value = Math.min( newSize, max_allowed_point_size );
          mouse_wheel = true;
        }
      }

      function decrease_points_size() {
        if (mesh && mesh.isPoints && mesh.material.uniforms) {
          let newSize = mesh.material.uniforms.uSize.value / 1.1;
          mesh.material.uniforms.uSize.value = Math.max( newSize, min_allowed_point_size );
          mouse_wheel = true;
        }
      }

      function frame_camera() {
        bounding_box.setFromObject( mesh );
        const center = bounding_box.getCenter( new THREE.Vector3() );
        const size = bounding_box.getSize( new THREE.Vector3() );

        camera.position.copy( center.clone().add( new THREE.Vector3( 0, 0, size.length())));
        camera.lookAt( center );

        // Center root
        mesh.position.sub( center );

        // Frame camera to root
        const maxDim = Math.max( size.x, size.y, size.z );
        const fov = THREE.MathUtils.degToRad( camera.fov );
        const dist = maxDim / ( 2 * Math.tan( fov / 2.0 ) );
        camera.position.set( 0, 0, dist * 1.5 );
        camera.lookAt( 0, 0, 0 );
        resize();
      }

      async function init() {
        if (url_loading === false && document.getElementById('file_input').files.length === 0) return;

        init_running = true;

        if (scene) {
          mouse_wheel = true;

          if (mesh) await scene_cleanup();

          await reset_all( true );
        }

        enable_disable( true );

        selected_ply_file = null;
        selected_stl_file = null;
        object_is_points = false;
        url_ply = false;
        mouse_down = false;
        mouse_wheel = true;
        wireframe_enabled = false;
        flat_shading_enabled = false;
        render_requested = false;
        bounding_box = new THREE.Box3();
        max_allowed_point_size = isMobile ? 0.75 : 1.5;
        min_allowed_point_size = isMobile ? 0.01 : 0.05;

        if (!params) params = { brightness: 2.0, roughness: 0.5, metalness: 0.0 };

        document.getElementById('btn_flat').disabled = false;
        document.getElementById('btn_wireframe').disabled = false;

        console.time( 'Loading Time' );
        document.getElementById('div_error').style.display = 'none';
        document.getElementById('div_loading').style.display = 'block';
        document.getElementById('div_loading').innerHTML = 'Load & Visualize';

        if (url_loading === false) {
          // Loaded file
          var fi = document.getElementById('file_input');

          for (let i = 0; i < fi.files.length; i++) {
            if (fi.files[ i ].name.toUpperCase().endsWith('.PLY')) { selected_ply_file = fi.files[ i ]; }
            else if (fi.files[ i ].name.toUpperCase().endsWith('.STL')) { selected_stl_file = fi.files[ i ]; }
          };

          if (selected_ply_file === null && selected_stl_file === null) {
            handle_error( 'No valid PLY or STL file selected!' );
            return;
          }

          selected_url_file = '';
        } else {
          // Reset the file input
          document.getElementById('file_input').value = '';
          url_loading = false;
        }

        if (renderer === undefined) {
          renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.toneMapping = THREE.NeutralToneMapping;
          renderer.toneMappingExposure = 0.5;
          renderer.setSize( ww, wh );
          renderer.info.autoReset = false;
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          renderer.setClearColor( 0xFFFFFF, 0 ); // Allow setting the background color
          renderer.autoClear = false;

          document.body.appendChild( renderer.domElement );
        }

        if (scene === undefined) scene = new THREE.Scene();

        if (!events_initialized) { initialize_event_listeners(); events_initialized = true; }

        if (camera === undefined) {
          camera = new THREE.PerspectiveCamera( 60, ww / wh, 0.1, 1e9 );
          camera.position.set( 0, 0, 250 );
          scene.add( camera );
        }

        if (controls === undefined) {
          const { OrbitControls } = await import( "three/addons/controls/OrbitControls.min.js" );

          controls = new OrbitControls( camera, renderer.domElement );
          controls.enableZoom = true;
          controls.zoomToCursor = true;
          controls.zoomSpeed = 0.5;
          controls.rotateSpeed = 0.5;
          controls.keyPanSpeed = 0.5; 
          controls.panSpeed = 0.5;
          controls.minDistance = 0;
          controls.maxDistance = Infinity;
          //controls.enableDamping = true;
          //controls.dampingFactor = 0.3;
          //controls.enableKeys = false;
          //controls.maxPolarAngle = 2.2;
          //controls.minPolarAngle = 1.1;
        }

        // Start flashing indicator
        document.getElementById('status_indicator').style.display = 'inline-block';

        // Load the model
        loadFile();
      }

      function allVertexColorsAreBlack( geometry ) {
        if (!geometry.hasAttribute( 'color' ) ) return false;

        const colors = geometry.getAttribute( 'color' );
        const col_count = colors.count;

        for ( let i = 0; i < col_count; i++ ) {
          if (
            colors.getX( i ) !== 0 ||
            colors.getY( i ) !== 0 ||
            colors.getZ( i ) !== 0
          ) {
            return false;  // found a non-black vertex
          }
        }

        return true; // all black
      }

      function add_face_normals( geometry ) {
        if (geometry.index) geometry = geometry.toNonIndexed();

        const pos = geometry.attributes.position;
        const pos_count = pos.count;
        const normals = [];

        for ( let i = 0; i < pos_count; i += 3 ) {
          const a = new THREE.Vector3().fromBufferAttribute( pos, i );
          const b = new THREE.Vector3().fromBufferAttribute( pos, i + 1 );
          const c = new THREE.Vector3().fromBufferAttribute( pos, i + 2 );

          // Compute face normal
          const cb = new THREE.Vector3().subVectors( c, b );
          const ab = new THREE.Vector3().subVectors( a, b );
          cb.cross( ab ).normalize();

          // Assign same normal to all 3 vertices of the face
          normals.push(cb.x, cb.y, cb.z);
          normals.push(cb.x, cb.y, cb.z);
          normals.push(cb.x, cb.y, cb.z);
        }

        geometry.setAttribute( 'faceNormal', new THREE.Float32BufferAttribute( normals , 3 ) );

        return geometry;
      }

      function normalsAreValid( geometry ) {
        if (!geometry.hasAttribute('normal')) return false;

        const normals = geometry.getAttribute('normal');
        let validCount = 0;
        const sampleSize = Math.min(normals.count, 1000); // Check a sample for speed

        for (let i = 0; i < sampleSize; i++) {
          // Check if the normal has any length at all
          if (Math.abs( normals.getX( i ) ) > 0.05 || 
            Math.abs( normals.getY( i ) ) > 0.05 || 
            Math.abs( normals.getZ( i ) ) > 0.05) {
            validCount++;
          }
        }

        // If less than 50% of sampled points have data, ignore normals
        return ( validCount / sampleSize ) > 0.5;
      }

      function createMeshShaderMaterial() {
        const material = new THREE.ShaderMaterial({
          uniforms: {
            uOpacity:        { value: 1.0 },
            uBrightness:     { value: 2.0 },
            uUseFlatShading: { value: 0.0 },
            uUseVertexColors:{ value: 1.0 },
            uBaseColor:      { value: new THREE.Color( 1, 1, 1 ) },
            uRoughness:      { value: 0.5 },
            uMetalness:      { value: 0.0 }
          },

          vertexShader: /* glsl */`
            varying vec3 vViewPos;
            varying vec3 vNormal;
            varying vec3 vColor;

            void main() {
              vColor = color;

              // view-space position
              vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
              vViewPos = viewPos.xyz;

              // view-space normal
              vNormal = normalize(normalMatrix * normal);

              gl_Position = projectionMatrix * viewPos;
            }
          `,

          fragmentShader: /* glsl */`
            uniform float uOpacity;
            uniform float uBrightness;
            uniform float uUseFlatShading;
            uniform float uUseVertexColors;
            uniform vec3  uBaseColor;
            uniform float uRoughness;
            uniform float uMetalness;

            varying vec3 vViewPos;
            varying vec3 vNormal;
            varying vec3 vColor;

            void main() {

              // -------- vertex colors vs base color --------
              float vcFactor = step(0.5, uUseVertexColors);
              float baseFactor = 1.0 - vcFactor;
              vec3 albedo = vColor * vcFactor + uBaseColor * baseFactor;

              // -------- flat vs smooth normal --------
              vec3 N_smooth = normalize(vNormal);

              // compute flat normal in view space
              vec3 dx = dFdx(vViewPos);
              vec3 dy = dFdy(vViewPos);
              vec3 N_flat = normalize(cross(dx, dy));

              vec3 N = normalize(mix(N_smooth, N_flat, uUseFlatShading));

              // -------- lighting vectors --------
              vec3 V = normalize(-vViewPos);     // view direction
              vec3 L = vec3(0.0, 0.0, 1.0);       // camera light
              vec3 H = normalize(V + L);

              float NdotV = max(dot(N, V), 0.0);
              float NdotL = max(N.z, 0.0);
              float NdotH = max(dot(N, H), 0.0);

              // -------- Fresnel (Schlick) --------
              vec3 F0 = mix(vec3(0.04), albedo, uMetalness);
              vec3 F = F0 + (1.0 - F0) * pow(1.0 - NdotV, 5.0);

              // -------- simple specular --------
              float shininess = 32.0 * (1.0 - uRoughness);
              float spec = pow(NdotH, shininess);
              vec3 specular = F * spec;

              // -------- diffuse --------
              vec3 kd = (1.0 - F) * (1.0 - uMetalness);
              vec3 diffuse = albedo * kd / 3.14159265;

              // -------- hybrid lighting --------
              vec3 Lo = (diffuse + specular) * NdotL;
              float simple = dot(N, V) * 0.5 + uRoughness;
              float hybrid = mix(simple, Lo.r, 0.9);

              vec3 shaded = albedo * hybrid * uBrightness;

              #include <colorspace_fragment>

              gl_FragColor = vec4(shaded, uOpacity);
              gl_FragColor = linearToOutputTexel(gl_FragColor);
            }
          `,

          transparent: true,
          depthWrite: true,
          depthTest: true,
          vertexColors: true,
          side: THREE.FrontSide
        });

        return material;
      }

      function createPointShaderMaterial( size ) {
        return new THREE.ShaderMaterial({
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexColors: true,

          uniforms: {
            uSize: { value: size },
            uOpacity: { value: 1.0 },
            uBrightness: { value: 2.0 },
            uUseVertexColors: { value: true },
            uUseRandomColors: { value: false },
            uBaseColor: { value: new THREE.Color( 1.0, 1.0, 1.0 ) }
          },

          vertexShader: `
            uniform float uSize;
            uniform vec3 uBaseColor;
            uniform bool uUseVertexColors;
            uniform bool uUseRandomColors;
            attribute float intensity;
            varying vec3 vColor;

            float hash(vec3 p) {
              return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
            }

            vec3 hueToRgb(float h) {
              return clamp(abs(mod(h * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
            }

            vec3 randomColor(vec3 p) {
              float h = hash(p);
              return hueToRgb(h);
            }

            void main() {
              vec3 base = uUseRandomColors ? randomColor(position) : (uUseVertexColors ? color : uBaseColor);
              vColor = base * pow(clamp(intensity, 0.001, 1.0), 0.45);

              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

              gl_PointSize = uSize * (300.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,

          fragmentShader: `
            uniform float uBrightness;
            uniform float uOpacity;
            varying vec3 vColor;

            void main() {
              float d = length(gl_PointCoord - vec2(0.5));
              if (d > 0.5) discard;   // circular points

              gl_FragColor = vec4(vColor * uBrightness, (1.0 - d) * uOpacity);
            }
          `
        });
      }

      function loadFile() {
        // Launch loading of the selected file, addFileInScene is the callback when it's ready
        if (selected_ply_file !== null) {
          ply_loader.load( URL.createObjectURL( selected_ply_file ), addFileInScene,
          function( xhr ) { }, // onProgress
          function ( error ) { handle_error( error ); }); // onError
        } else if (selected_stl_file !== null) {
          stl_loader.load( URL.createObjectURL( selected_stl_file ), addFileInScene,
          function( xhr ) { }, // onProgress
          function ( error ) { handle_error( error ); }); // onError
        } else {
          loadURLFile();
        }
      }

      async function addFileInScene( object ) {
        if (selected_ply_file) {
          URL.revokeObjectURL( selected_ply_file );
        } else if (selected_stl_file) {
          URL.revokeObjectURL( selected_stl_file );
        }

        // object is geometry

        let smooth = object;

        smooth.computeBoundingBox();
        smooth.computeBoundingSphere();

        if ( smooth.index !== null ) {
          // Compute smooth normals first (while we have the original vertex data)
          if (!smooth.hasAttribute( 'normal' )) smooth.computeVertexNormals();

          // Set attributes for flatShading and wireframe functionality

          smooth = add_face_normals( smooth );

          if (!smooth.hasAttribute( 'normal' )) smooth.computeVertexNormals();
          smooth.normalizeNormals();
          smooth.center();

          smooth.computeBoundingBox();
          smooth.computeBoundingSphere();

          if (smooth.hasAttribute( 'color' )) {
            if (allVertexColorsAreBlack( smooth )) {
              const col_count = smooth.getAttribute( 'color' ).count;
              const white = new Float32Array( col_count * 3 ).fill( 1.0 );
              smooth.setAttribute( 'color', new THREE.BufferAttribute( white, 3 ) );
            }
          }

          let mesh_material = createMeshShaderMaterial();

          mesh = new THREE.Mesh( smooth, mesh_material );
        } else {
          if (selected_ply_file || url_ply) {
            // PLY points model loaded

            let points_material = createPointShaderMaterial( isMobile ? 0.25 : 0.5 );

            // Shader material expects color attribute
            // Fill with white color if no color is present

            if (!smooth.hasAttribute( 'color' )) {
              const pos_count = smooth.attributes.position.count;
              const colors = new Float32Array( pos_count * 3 ).fill( 0.9 );
              smooth.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
            }

            // *** START - Add intensity to geometry ***

            // Some PLY point clouds might have intensity baked-in

            if (!smooth.hasAttribute( 'intensity' )) {
              const pos = smooth.getAttribute( 'position' );
              const points_count = pos.count;
              const intensity = new Float32Array( points_count );

              // Spherical falloff

              for (let i = 0; i < points_count; i++) {
                const x = pos.getX( i );
                const y = pos.getY( i );
                const z = pos.getZ( i );

                const d = Math.sqrt( x * x + y * y + z * z );

                intensity[ i ] = d;
              }

              // Normalize

              let min = Infinity;
              let max = -Infinity;

              for (let i = 0; i < intensity.length; i++) {
                const v = intensity[ i ];

                if (v < min) min = v;
                if (v > max) max = v;
              }

              const range = ( max - min );

              for (let i = 0; i < points_count; i++) {
                intensity[ i ] = ( intensity[ i ] - min ) / range;
              }

              smooth.setAttribute( 'intensity', new THREE.BufferAttribute( intensity, 1 ) );
            }

            // *** END - Add intensity to geometry ***

            mesh = new THREE.Points( smooth, points_material );
            mesh.sizeAttenuation = true;
            mesh.sortPoints = true;

            object_is_points = true;
          } else {
            // STL model loaded

            if (merge_vertices === undefined) {
              const { mergeVertices } = await import( 'three/addons/utils/BufferGeometryUtils.min.js' );
              merge_vertices = mergeVertices;
            }

            smooth.deleteAttribute('normal');
            smooth = merge_vertices( smooth, 1e-6 );
            smooth.computeVertexNormals();

            // Set attributes for flatShading and wireframe functionality

            smooth = add_face_normals( smooth );

            if (!smooth.hasAttribute( 'normal' )) smooth.computeVertexNormals();
            smooth.normalizeNormals();
            smooth.center();

            smooth.computeBoundingBox();
            smooth.computeBoundingSphere();

            if (smooth.hasAttribute( 'color' )) {
              if (allVertexColorsAreBlack( smooth )) {
                const col_count = smooth.getAttribute( 'color' ).count;
                const white = new Float32Array( col_count * 3 ).fill( 1.0 );
                smooth.setAttribute( 'color', new THREE.BufferAttribute( white, 3 ) );
              }
            }

            let mesh_material = createMeshShaderMaterial();

            mesh = new THREE.Mesh( smooth, mesh_material );
          }
        }

        // Add mesh to the scene
        scene.add( mesh );
        camera.lookAt( mesh.position );

        finish_loading();

        mouse_wheel = true;
      }

      function loadURLFile() {
        if (selected_url_file !== '') {
          if (selected_url_file.startsWith('https://www.dropbox.com') === true) {
            selected_url_file = selected_url_file.replace('www.dropbox.com', 'dl.dropbox.com');
          } else if (selected_url_file.startsWith('https://github.com') === true) {
            selected_url_file = ( selected_url_file.replace('github.com', 'raw.githubusercontent.com') ).replace('blob/', '');
          }

          // No extension checking for single URL so it has to point to PLY or STL file

          stl_loader.load( selected_url_file, addFileInScene,
          function( xhr ) { }, // onProgress
          function ( error1 ) { // onError
            url_ply = true;
            ply_loader.load( selected_url_file, addFileInScene,
            function( xhr ) { }, // onProgress
            function ( error2 ) { handle_error( error2 ); }); // onError
          });
        }
      }

      async function finish_loading() {
        frame_camera();

        console.timeEnd( 'Loading Time' );

        // Stop flashing indicator
        document.getElementById('status_indicator').style.display = 'none';

        document.getElementById('div_loading').style.display = 'none';

        if (gui_set === false) {
          // Add Brightness control
          gui.add( params, 'brightness', 0, 10, 0.1 ).name( 'Brightness' )
          .onChange( ( value ) => {
            if (mesh) {
              mesh.material.uniforms.uBrightness.value = parseFloat( value );
              mouse_wheel = true;
            }
          });

          // Add Roughness control
          gui.add( params, 'roughness', 0.0, 1.0, 0.025 ).name( 'Roughness' )
          .onChange( ( value ) => {
            if (mesh && !object_is_points) {
              mesh.material.uniforms.uRoughness.value = parseFloat( value );
              mouse_wheel = true;
            }
          });

          // Add Metalness control
          gui.add( params, 'metalness', 0.0, 1.0, 0.025 ).name( 'Metalness' )
          .onChange( ( value ) => {
            if (mesh && !object_is_points) {
              mesh.material.uniforms.uMetalness.value = parseFloat( value );
              mouse_wheel = true;
            }
          });

          set_gui_position();

          gui.open();
          gui_set = true;
        }

        const gui_roughness = gui.controllersRecursive().find( c => c.property === 'roughness' );
        const gui_metalness = gui.controllersRecursive().find( c => c.property === 'metalness' );

        if (object_is_points) {
          gui_roughness.show( false );
          gui_metalness.show( false );

          document.getElementById('btn_flat').style.display = 'none';
          document.getElementById('btn_wireframe').style.display = 'none';
          document.getElementById('btn_plus').style.display = 'inline-block';
          document.getElementById('btn_minus').style.display = 'inline-block';
        } else {
          gui_roughness.show( true );
          gui_metalness.show( true );

          document.getElementById('btn_flat').style.display = 'inline-block';
          document.getElementById('btn_wireframe').style.display = 'inline-block';
          document.getElementById('btn_plus').style.display = 'none';
          document.getElementById('btn_minus').style.display = 'none';
        }

        gui_container.style.display = 'block';
        set_gui_position();

        enable_disable( false );

        init_running = false;

        render_requested = true;
        mouse_wheel = true;
        render();

        if (isMobile === false) await new Promise( resolve => setTimeout( log_info(), 250 ) );
      }

      function log_info() {
        console.log( 'Memory: ', renderer.info.memory );
        console.log( 'Render: ', renderer.info.render );
      }

      function handle_error( error ) {
        console.timeEnd( 'Loading Time' );
        console.log( 'Error loading model!' );
        console.log( error );
        mouse_wheel = true;
        render_requested = false;
        enable_disable( true );

        gui_container.style.display = 'none';

        // Stop flashing indicator
        document.getElementById('status_indicator').style.display = 'none';

        init_running = false;

        document.getElementById('div_loading').style.display = 'none';
        document.getElementById('div_error').style.display = 'block';
      }

      function quick_x_rotation( angle ) {
        mesh.rotateX( - Math.PI / 2.0 );

        mouse_wheel = true;
      }

      function set_flat() {
        if (mesh) {
          if (flat_shading_enabled) {
            document.getElementById('btn_flat').style.backgroundColor = 'transparent';
            flat_shading_enabled = false;
          } else {
            document.getElementById('btn_flat').style.backgroundColor = 'lightgreen';
            flat_shading_enabled = true;
          }

          mesh.traverse( ( child ) => {
            if (child.isMesh) {
              child.material.uniforms.uUseFlatShading.value = flat_shading_enabled;
            }

            mouse_wheel = true;
          });
        }
      }

      function show_wireframe() {
        if (mesh) {
          if (wireframe_enabled) {
            wireframe_enabled = false;
            document.getElementById('btn_wireframe').style.backgroundColor = 'transparent';
          } else {
            wireframe_enabled = true;
            document.getElementById('btn_wireframe').style.backgroundColor = 'lightgreen';
          }

          mesh.traverse( ( child ) => {
            if (child.isMesh) {
              child.material.wireframe = wireframe_enabled;
            }

            mouse_wheel = true;
          });
        }
      }

      async function render() {
        if (mesh) {
          if (mouse_down === true || mouse_wheel === true) {
            controls.update();

            renderer.clear();
            renderer.render( scene, camera );

            if (mouse_wheel === true) {
              if (count > 5) {
                mouse_wheel = false;
                count = 0;
              } else {
                count ++;
              }
            }
          }
        }

        if (render_requested === true) requestAnimationFrame( render );
      }

      async function reset_all( reset = false ) {
        document.getElementById('back_color').value = '#000000';
        document.getElementById('btn_url').style.backgroundColor = 'transparent';
        document.getElementById('btn_flat').style.backgroundColor = 'transparent';
        document.getElementById('btn_wireframe').style.backgroundColor = 'transparent';
        document.getElementById('btn_wireframe').style.display = 'none';
        document.getElementById('btn_flat').style.display = 'none';
        document.getElementById('btn_plus').style.display = 'none';
        document.getElementById('btn_minus').style.display = 'none';

        init_running = false;

        if (gui_set) gui_reset();

        // Reset the view
        if (reset === true) {
          controls.reset();
          set_back_color();
        } else {
          // Page (re)loading
          if (scene) {
            if (gui) gui.dispose();

            if (mesh) await scene_cleanup();

            while (scene.children.length > 0) {
              scene.remove( scene.children[ 0 ] );
            }

            renderer.clear();
            renderer.dispose();
          }

          document.getElementById('file_input').value = '';
          document.getElementById('div_error').style.display = 'none';
          document.getElementById('url_entry').value = '';
          selected_url_file = '';
          enable_disable( true );
        }

        mouse_wheel = true;
      }

      async function scene_cleanup() {
        if (wireframe_enabled) await show_wireframe();

        scene.remove( mesh );
        renderer.clear();

        mesh.traverse( ( child ) => {
          if (child.isMesh || child.isPoints) {
            if (child.geometry) {
              child.geometry.dispose();
              child.geometry = null;
            }

            if (child.material) {
              if (child.material.uniforms) {
                Object.keys( child.material.uniforms ).forEach( key => {
                  const uniform = child.material.uniforms[ key ].value;
                  if (uniform && uniform.isTexture) uniform.dispose();
                });
              } else {
                if (child.material.map) child.material.map.dispose();
              }

              child.material.dispose();
              child.material = null;
            }
          }
        });

        mesh = undefined;

        if (isMobile === false) {
          renderer.info.reset();
          renderer.resetState();
        }
      }

      function enable_disable( disable = false ) {
        document.getElementById('back_color').disabled = disable;
        document.getElementById('btn_quick_x').disabled = disable;
        disabled_changed();

        mouse_wheel = true;
      }
    </script>

    <script>
      function document_ready() {
        isMobile = (/iPad|iPhone|iPod/.test( navigator.platform )) ||
          (/Android|webOS|iPhone|iPad|iPod|CriOS|BlackBerry|IEMobile|Opera Mini/i.test( navigator.userAgent )) ||
          (navigator.maxTouchPoints !== undefined && navigator.maxTouchPoints > 2 && /MacIntel/.test( navigator.platform ));

        $('#url_entry').keypress( function( event ) { if (event.key === 'Enter') $('#btn_load').click(); });
      }

      function disabled_changed() {
        $('button').each( function() {
          if (this.disabled === false ) {
            $(this).hover(
            function() { $(this)[ 0 ].style.border = 'solid 2px red'; },
            function() { $(this)[ 0 ].style.border = 'solid 1px blue'; });
          } else {
            $(this).unbind('mouseenter mouseleave');
          }

          mouse_wheel = true;
        });

        $('input[type=color]').each( function() {
          if (this.disabled === false ) {
            $(this).hover(
            function() { $(this)[ 0 ].style.border = 'solid 2px red'; },
            function() { $(this)[ 0 ].style.border = 'solid 1px whitesmoke'; });
          } else {
            $(this).unbind('mouseenter mouseleave');
          }

          mouse_wheel = true;
        });
      }
    </script>
  </body>
</html>
