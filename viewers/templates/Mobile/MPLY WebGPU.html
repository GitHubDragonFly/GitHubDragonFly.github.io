<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="encoding" content="utf-8" charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="PLY (Polygon) + STL (Stereolithography) Viewer with WebGPU">
    <link rel="stylesheet" href="../../static/css/mobile-viewers.css">
    <link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon"/>

    <script>
      // Resource Loading Failures (404 or similar)
      window.addEventListener( 'error', function ( event ) {
        // We check if the target has a 'src' or 'href' to identify it as a resource
        if (event.target.src || event.target.href) {
          console.error( 'RESOURCE ERROR:', {
            element: event.target.tagName,
            url: event.target.src || event.target.href,
            html: event.target.outerHTML
          });

          // If the failed resource is jQuery, show the alert immediately
          if ((event.target.src || '').includes('jquery')) {
            alert('jQuery failed to load. Limited functionality. Check your internet connection!');
          }
        }
      }, true); // The 'true' here is vital; it enables the "capturing" phase

      // Standard JavaScript Runtime Errors
      window.onerror = function ( message, source, lineno, colno, error ) {
        console.log( 'RUNTIME ERROR CAUGHT' );

        console.log({
          message: message, // Error message
          file: source,     // The script file where it happened
          line: lineno,     // Line number
          column: colno,    // Column number
          errorObj: error   // The actual Error object (includes stack trace)
        });

        // Returning 'true' prevents the error from showing up in the browser console
        return false; 
      };

      // Unhandled Promise Rejections (Async Errors)
      window.addEventListener( 'unhandledrejection', function ( event ) {
        console.warn( 'UNHANDLED PROMISE: ', event.reason );

        // event.promise is the promise that failed
        // event.reason is usually the error object or message

        if (init_running === true) handle_error( 'UNHANDLED PROMISE: ' + event.reason );
      });
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2.8.0/dist/es-module-shims.min.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.min.js",
          "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.min.js",
          "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.tsl.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/",
          "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/"
        }
      }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" defer></script>

    <script>
      var THREE, manager, ply_loader, stl_loader, renderer, scene, camera, render_requested;
      var controls, mouse_down, mouse_wheel, events_initialized, init_running = false;
      var mesh, gpu, gl2, bounding_box, flat_shading_enabled, halt_on_error;
      var gui, gui_container, gui_set = false, object_is_points;
      var merge_vertices, wireframe_enabled, isMobile, params;
      var ww = window.innerWidth, wh = window.innerHeight;
      var url_displayed = false, url_loading = false, url_ply, count = 0;
      var selected_ply_file, selected_stl_file, selected_url_file = '';

      const pw = "<span style='color:red'>" + "Please Wait" + "</span>";
    </script>

    <script type="module">
      import * as threejs from "three";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { STLLoader } from "three/addons/loaders/STLLoader.min.js";
      import { PLYLoader } from "three/addons/loaders/PLYLoader.min.js";

      THREE = threejs;

      document.getElementById('div_message').innerText += ' (THREE loaded)';

      manager = new THREE.LoadingManager();
      manager.onLoad = function() { mouse_wheel = true; }

      ply_loader = new PLYLoader( manager );
      stl_loader = new STLLoader( manager );

      gui_container = document.getElementById('gui_position');

      // Override external CSS so we can have GUI in the top-right corner
      gui_container.style.left = 'auto';         // Reset any left-side positioning
      gui_container.style.right = '3px';         // Anchor to the right
      gui_container.style.top = '2px';           // Anchor to the top
      gui_container.style.marginLeft = '0px';    // Clear the 2px margin from your CSS

      gui = new GUI( { autoPlace: false, container: gui_container } );
      set_gui_position();
    </script>

    <!-- Original OBJ source code that inspired this: https://codepen.io/Mamboleoo/pen/PqjGdN -->
    <!-- Using three.js library: https://github.com/mrdoob/three.js -->

    <!-- mouse_wheel variable is used throughout as a trigger for rendering -->

    <title>PLY+STL WebGPU (r183)</title>
  </head>
  <body onload="reset_all(); document_ready(); disabled_changed();" onresize="resize();">
    <div id="fixed_menu" class="fixed-menu">
      <div class="fm">
        <button id="btn_desktop" title="Open Desktop Version" onclick="switch_to_desktop();">D</button>
        <label for="btn_desktop" title="Open Desktop Version"></label>
        <button title="Get remote model via URL" id="btn_url" onclick="show_url()" style="min-width: 38px;">URL</button>
        <label for="btn_url" title="Get remote model via URL"></label>
        <button title="Browse Local Files" id="btn_file_input" style="min-width: 54px;" onclick="document.getElementById('file_input').click();">Browse</button>
        <label for="btn_file_input" title="Browse Local Files"></label>
        <input type="file" id="file_input" style="display: none;" onchange="init();" accept=".ply, .stl" />
        <label for="back_color" title="Background Color">B</label>
        <input type="color" title="Background Color" id="back_color" onchange="set_back_color();" disabled />
        <button title="Flat Shading" id="btn_flat" onclick="set_flat();" style="display: none">F</button>
        <label for="btn_flat" title="Flat Shading"></label>
        <button title="Wireframe" id="btn_wireframe" onclick="show_wireframe();" style="display: none">W</button>
        <label for="btn_wireframe" title="Wireframe"></label>
        <button title="Quick -90 degree X-Axis Rotation" id="btn_quick_x" onclick="quick_x_rotation();" style="min-width: 15px;" disabled>&#x2191</button>
        <label for="btn_quick_x" title="Quick -90 degree X-Axis Rotation"></label>
        <div id="status_indicator" class="indicator"></div>
      </div>
      <div class="fm" id="url" style="display: none;">
        <label for="url_entry" title="Remote URL"></label>
        <input type="text" id="url_entry" value="" style="width: calc(75% - 12px);" />
        <button title="Load" id="btn_load" onclick="load_url_file();" style="min-width: 8.5%;">Load</button>
        <label for="btn_load" title="Load"></label>
        <button title="Clear" id="btn_clear" onclick="clear_url();" style="min-width: 8.5%;">Clear</button>
        <label for="btn_clear" title="Clear"></label>
      </div>
      <div class="fm" id="div_message" style="width: 99.1%; margin: 2px 0 2px 1px; color: maroon;">
        Use inputs above
      </div>
    </div>
    <div id="gui_position"></div>
    <div id="div_error" class="error_msg">E R R O R !</div>
    <div id="div_loading" class="loading_msg">PLY+STL WebGPU</div>

    <script>
      function switch_to_desktop() {
        let link = document.createElement( 'a' );
        link.style.display = 'none';
        link.href = "../PLY Viewer.html";
        link.click();
      }

      function show_url() {
        if (url_displayed === true) {
          url_displayed = false;
          document.getElementById('url').style.display = 'none';
          document.getElementById('btn_url').style.backgroundColor = 'transparent';
        } else {
          document.getElementById('btn_url').style.backgroundColor = 'lightgreen';
          document.getElementById('url').style.display = 'block';
          url_displayed = true;
        }

        resize();
      }

      function load_url_file() {
        let url = document.getElementById('url_entry').value.trim();
        if (url !== '') { selected_url_file = url; url_loading = true; init(); }
      }

      function clear_url() { document.getElementById('url_entry').value = ''; }

      function initialize_event_listeners() {
        const arrow_keys = [ 'ArrowUp', 'ArrowDown', 'ArrowRight', 'ArrowLeft' ];
        const activeKeys = new Set();

        window.addEventListener( 'pointerdown', (event) => { mouse_down = true; }, false);
        window.addEventListener( 'pointerup', (event) => { mouse_down = false; }, false);
        window.addEventListener( 'pointercancel', ( event ) => { mouse_down = false; mouse_wheel = false; }, false);
        window.addEventListener( 'wheel', ( event ) => { mouse_wheel = true; }, false);
        window.addEventListener( 'keydown', ( event ) => {
          if (arrow_keys.some( k => k === event.key ) || event.ctrlKey || event.metaKey || event.shiftKey) {
            controls.listenToKeyEvents( window );
            activeKeys.add( event.key ); // Track this key
            mouse_wheel = true;
          }
        }, false);
        window.addEventListener( 'keyup', ( event ) => {
          activeKeys.delete( event.key ); // Remove this key

          if ( controls && activeKeys.size === 0 ) {
            controls.stopListenToKeyEvents();
            mouse_wheel = false;
          }
        }, false);
      }

      function gui_reset() {
        params.brightness = 2.0;
        params.roughness = 0.5;
        params.metalness = 0.0;

        gui.reset();

        gui_container.style.display = 'none';
      }

      function set_gui_position() {
        let fixed_menu_bottom = ( parseInt( $('#fixed_menu').outerHeight( true ) ) + 2 ).toString() + 'px';
        gui_container.style.marginTop = fixed_menu_bottom;
      }

      function resize() {
        if (scene !== undefined) {
          mouse_wheel = true;

          ww = window.innerWidth;
          wh = window.innerHeight;

          renderer.setSize( ww, wh );

          camera.aspect = ww / wh;
          camera.updateProjectionMatrix();

          if (gui) set_gui_position();

          mouse_wheel = true;
        }
      }
    </script>

    <script>
      function set_back_color() {
        scene.background = null;
        document.body.style.backgroundColor = document.getElementById('back_color').value;
        mouse_wheel = true;
      }

      function frame_camera() {
        bounding_box.setFromObject( mesh );
        const center = bounding_box.getCenter( new THREE.Vector3() );
        const size = bounding_box.getSize( new THREE.Vector3() );

        camera.position.copy( center.clone().add( new THREE.Vector3( 0, 0, size.length())));
        camera.lookAt( center );

        // Center root
        mesh.position.sub( center );

        // Frame camera to root
        const maxDim = Math.max( size.x, size.y, size.z );
        const fov = THREE.MathUtils.degToRad( camera.fov );
        const dist = maxDim / ( 2 * Math.tan( fov / 2.0 ) );
        camera.position.set( 0, 0, dist * 1.5 );
        camera.lookAt( 0, 0, 0 );
        resize();
      }

      async function init() {
        if (url_loading === false && document.getElementById('file_input').files.length === 0) return;

        init_running = true;

        document.getElementById('div_message').innerHTML = 'Loading ... ' + pw;
        document.getElementById('div_message').style.display = '';

        if (scene) {
          mouse_wheel = true;

          if (mesh) await scene_cleanup();

          await reset_all( true );
        }

        enable_disable( true );

        selected_ply_file = null;
        selected_stl_file = null;
        object_is_points = false;
        url_ply = false;
        mouse_down = false;
        mouse_wheel = true;
        halt_on_error = false;
        wireframe_enabled = false;
        flat_shading_enabled = false;
        render_requested = false;
        bounding_box = new THREE.Box3();

        if (!params) params = { brightness: 2.0, roughness: 0.5, metalness: 0.0 };

        console.time( 'Loading Time' );
        document.getElementById('div_error').style.display = 'none';
        document.getElementById('div_loading').style.display = 'block';
        document.getElementById('div_loading').innerHTML = 'Load & Visualize';

        if (url_loading === false) {
          // Loaded file
          var fi = document.getElementById('file_input');

          for (let i = 0; i < fi.files.length; i++) {
            if (fi.files[ i ].name.toUpperCase().endsWith('.PLY')) { selected_ply_file = fi.files[ i ]; }
            else if (fi.files[ i ].name.toUpperCase().endsWith('.STL')) { selected_stl_file = fi.files[ i ]; }
          };

          if (selected_ply_file === null && selected_stl_file === null) {
            handle_error( 'No valid PLY or STL file selected!' );
            return;
          }

          selected_url_file = '';
        } else {
          // Reset the file input
          document.getElementById('file_input').value = '';
          url_loading = false;
        }

        if (renderer === undefined) {
          try {
            renderer = new THREE.WebGPURenderer( { antialias: true, alpha: true } );
            await renderer.init();
          } catch ( error ) {
            handle_error( error );
            return;
          }

          renderer.setPixelRatio( window.devicePixelRatio < 1.5 ? window.devicePixelRatio : 2.0 );
          renderer.outputColorSpace = THREE.SRGBColorSpace;
          renderer.toneMapping = THREE.NeutralToneMapping;
          renderer.toneMappingExposure = 1.0;
          renderer.setSize( ww, wh );
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          renderer.autoClear = false;

          // Consider removing this for a production build
          renderer.debug.onShaderError = ( gl, program, glVertexShader, glFragmentShader ) => {
            const errorLog = gl.getProgramInfoLog( program );
            const vertexSource = gl.getShaderSource( glVertexShader );
            const fragmentSource = gl.getShaderSource( glFragmentShader );

            halt_on_error = true;

            handle_error( 'CRITICAL SHADER ERROR: ' + errorLog );
          };

          document.body.appendChild( renderer.domElement );
        }

        if (scene === undefined) scene = new THREE.Scene();

        if (!events_initialized) { initialize_event_listeners(); events_initialized = true; }

        if (camera === undefined) {
          camera = new THREE.PerspectiveCamera( 45, ww / wh, 0.1, 1e9 );
          camera.position.set( 0, 0, 250 );
          scene.add( camera );
        }

        if (controls === undefined) {
          const { OrbitControls } = await import( "three/addons/controls/OrbitControls.min.js" );

          controls = new OrbitControls( camera, renderer.domElement );
          controls.zoomToCursor = true;
          controls.zoomSpeed = 0.5;
          controls.rotateSpeed = 0.5;
          controls.keyPanSpeed = 0.5; 
          controls.panSpeed = 0.5;
          //controls.enableDamping = true;
          //controls.dampingFactor = 0.3;
          //controls.enableKeys = false;
          //controls.enableZoom = true;
          //controls.maxPolarAngle = 2.2;
          //controls.minPolarAngle = 1.1;
          //controls.minDistance = 2;
          //controls.maxDistance = 500;
        }

        // Start flashing indicator
        document.getElementById('status_indicator').style.display = 'inline-block';

        // Load the model
        loadFile();
      }

      function allVertexColorsAreBlack( geometry ) {
        if (!geometry.hasAttribute( 'color' ) ) return false;

        const colors = geometry.getAttribute( 'color' );
        const col_count = colors.count;

        for ( let i = 0; i < col_count; i++ ) {
          if (
            colors.getX( i ) !== 0 ||
            colors.getY( i ) !== 0 ||
            colors.getZ( i ) !== 0
          ) {
            return false;  // found a non-black vertex
          }
        }

        return true; // all black
      }

      async function createMeshShaderMaterialTSL() {
        const {
          attribute, varying, uniform, vec3, vec4, float,
          modelViewProjection, modelViewMatrix, normalView,
          normalize, dot, max, mix, pow, step, dFdx, dFdy, cross
        } = await import( 'three/tsl' );

        // uniforms
        const uOpacity         = uniform( 1.0, 'float' );
        const uBrightness      = uniform( 2.0, 'float' );
        const uUseFlatShading  = uniform( 0.0, 'float' ); // 0 = smooth, 1 = flat
        const uUseVertexColors = uniform( 1.0, 'float' ); // 0 = off, 1 = on
        const uBaseColor       = uniform( new THREE.Color( 1, 1, 1 ), 'color' );
        const uRoughness       = uniform( 0.5, 'float' ); // 0.0 = mirror, 1.0 = matte
        const uMetalness       = uniform( 0.0, 'float' ); // 0.0 = plastic/dielectric, 1.0 = metal

        // attributes
        const position   = attribute( 'position', 'vec3' );
        const colorAttr  = attribute( 'color',    'vec3' );

        // varyings
        const vViewPos = varying( modelViewMatrix.mul( vec4( position, 1.0 ) ).xyz );
        const vViewNormal = varying( normalView );
        const vColor   = varying( colorAttr );

        // -------- vertex colors vs base color --------

        const vcFactor    = step( float( 0.5 ), uUseVertexColors );
        const baseFactor  = float( 1.0 ).sub( vcFactor );
        const albedoRGB = vColor.mul( vcFactor ).add( uBaseColor.rgb.mul( baseFactor ) );

        // -------- flat vs smooth normal view & light directions --------

        // Calculate the flat normal using the VIEW SPACE position
        // This ensures the flat faces are aligned with the camera

        const dViewPosdx     = dFdx( vViewPos );
        const dViewPosdy     = dFdy( vViewPos );
        const flatNormalView = normalize( cross( dViewPosdx, dViewPosdy ) );

        // Define N by mixing the smooth view normal and the flat view normal
        // We use uUseFlatShading to toggle between them

        const N = normalize( mix( vViewNormal, flatNormalView, uUseFlatShading ) );

        const V = vViewPos.negate().normalize();
        const L = vec3( 0, 0, 1 ); // Light comes from the screen/camera
        const H = normalize( V.add( L ) );

        // -------- simplified PBR --------

        const one = float( 1.0 );

        const NdotV = max( dot( N, V ), float( 0.0 ) );
        const NdotL = N.z.clamp(); // Optimized version of dot( N, vec3( 0, 0, 1 ) )
        const NdotH = max( dot( N, H ), float( 0.0 ) );

        // Fresnel (Schlick)

        const F0 = mix( vec3( 0.04 ), albedoRGB, uMetalness );
        const F  = F0.add( vec3( one.sub( F0 ) ).mul( pow( one.sub( NdotV ), float( 5.0 ) ) ) );

        // simple stable specular

        const shininess  = float( 32.0 ).mul( one.sub( uRoughness ) );
        const simpleSpec = pow( NdotH, shininess );
        const specular   = F.mul( simpleSpec );

        // diffuse (energy conserving)

        const kd      = one.sub( F ).mul( one.sub( uMetalness ) );
        const diffuse = albedoRGB.div( Math.PI ).mul( kd );

        // final hybrid lighting

        const Lo         = diffuse.add( specular ).mul( NdotL );
        const simple     = dot( N, V ).mul( 0.5 ).add( uRoughness );
        const hybrid     = mix( simple, Lo, 0.9 ); // 0.0 = simple, 1.0 = PBR
        const shadedRGB  = albedoRGB.mul( hybrid ).mul( uBrightness );

        const finalColor = vec4( shadedRGB, uOpacity ).context( { colorspace: true } );

        // -------- material setup --------

        const material = new THREE.NodeMaterial();
        material.positionNode = modelViewProjection.mul( vec4( position, 1.0 ) );
        material.colorNode = finalColor;

        material.transparent = true;
        material.depthWrite = true;
        material.depthTest = true;
        material.side = THREE.FrontSide; // IMPORTANT: keeps triangle count correct
        material.vertexColors = uUseVertexColors;
        material.wireframeLinewidth = 1.0; // IMPORTANT: avoids browser warnings

        // expose uniforms to tweak them externally

        material.uniforms = {
          uOpacity,
          uRoughness,
          uMetalness,
          uBrightness,
          uUseFlatShading,
          uUseVertexColors
        };

        return material;
      }

      async function createPointShaderMaterialTSL() {
        const {
          attribute, uniform, vec4, clamp, pow, positionView
        } = await import( 'three/tsl' );

        // uniforms
        const uOpacity = uniform( 1.0, 'float' );
        const uBrightness = uniform( 1.0, 'float' );

        // attributes
        const colorAttr = attribute( 'color', 'vec3' );
        const intensity = attribute( 'intensity', 'float' );

        // color shaping
        const shapedIntensity = pow( clamp( intensity, 0.001, 1.0 ), 0.1 );
        const rgb = colorAttr.mul( shapedIntensity ).mul( uBrightness );
        const finalColor = vec4( rgb, uOpacity );

        // material
        const material = new THREE.PointsNodeMaterial();
        material.colorNode = finalColor;

        material.transparent = true;
        material.depthWrite = false;
        material.blending = THREE.AdditiveBlending;

        // expose uniforms to tweak them externally

        material.uniforms = { uOpacity, uBrightness };

        return material;
      }

      function loadFile() {
        // Launch loading of the selected file, addFileInScene is the callback when it's ready
        if (selected_ply_file !== null) {
          ply_loader.load( URL.createObjectURL( selected_ply_file ), addFileInScene,
          function( xhr ) { }, // onProgress
          function ( error ) { handle_error( error ); }); // onError
        } else if (selected_stl_file !== null) {
          stl_loader.load( URL.createObjectURL( selected_stl_file ), addFileInScene,
          function( xhr ) { }, // onProgress
          function ( error ) { handle_error( error ); }); // onError
        } else {
          loadURLFile();
        }
      }

      async function addFileInScene( object ) {
        if (halt_on_error) return;

        if (selected_ply_file) {
          URL.revokeObjectURL( selected_ply_file );
        } else if (selected_stl_file) {
          URL.revokeObjectURL( selected_stl_file );
        }

        // object is geometry

        let smooth = object;

        smooth.computeBoundingBox();
        smooth.computeBoundingSphere();

        if ( smooth.index !== null ) {
          if (!smooth.hasAttribute( 'normal' )) smooth.computeVertexNormals();
          smooth.normalizeNormals();
          smooth.center();

          smooth.computeBoundingBox();
          smooth.computeBoundingSphere();

          if (( smooth.hasAttribute( 'color' ) && allVertexColorsAreBlack( smooth ) ) || !smooth.hasAttribute( 'color' )) {
            const pos_count = smooth.getAttribute( 'position' ).count;
            const white = new Float32Array( pos_count * 3 ).fill( 1.0 );
            smooth.setAttribute( 'color', new THREE.BufferAttribute( white, 3 ) );
          }

          let mesh_material = await createMeshShaderMaterialTSL();

          mesh = new THREE.Mesh( smooth, mesh_material );

          smooth.dispose();
          mesh_material.dispose();
        } else {
          if (selected_ply_file || url_ply) {
            // PLY points model loaded

            let points_material = await createPointShaderMaterialTSL();

            // Shader material expects color attribute
            // Fill with white color if no color is present

            if (!smooth.hasAttribute( 'color' )) {
              const pos_count = smooth.getAttribute( 'position' ).count;
              const colors = new Float32Array( pos_count * 3 ).fill( 0.9 );
              smooth.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
            }

            // *** START - Add intensity to geometry ***

            // Some PLY point clouds might have intensity baked-in

            if (!smooth.hasAttribute( 'intensity' )) {
              const pos = smooth.getAttribute( 'position' );
              const points_count = pos.count;
              const intensity = new Float32Array( points_count );

              // Spherical falloff

              for (let i = 0; i < points_count; i++) {
                const x = pos.getX( i );
                const y = pos.getY( i );
                const z = pos.getZ( i );

                const d = Math.sqrt( x * x + y * y + z * z );

                intensity[ i ] = d;
              }

              // Normalize

              let min = Infinity;
              let max = -Infinity;

              for (let i = 0; i < intensity.length; i++) {
                const v = intensity[ i ];

                if (v < min) min = v;
                if (v > max) max = v;
              }

              const range = ( max - min );

              for (let i = 0; i < points_count; i++) {
                intensity[ i ] = ( intensity[ i ] - min ) / range;
              }

              smooth.setAttribute( 'intensity', new THREE.BufferAttribute( intensity, 1 ) );
            }

            // *** END - Add intensity to geometry ***

            mesh = new THREE.Points( smooth, points_material );

            smooth.dispose();
            points_material.dispose();

            mesh.sizeAttenuation = true;
            mesh.sortPoints = true;
            object_is_points = true;
          } else {
            // STL model loaded

            if (merge_vertices === undefined) {
              const { mergeVertices } = await import( "three/addons/utils/BufferGeometryUtils.min.js" );
              merge_vertices = mergeVertices;
            }

            smooth.deleteAttribute('normal');
            smooth = merge_vertices( smooth, 1e-6 );
            smooth.computeVertexNormals();
            smooth.normalizeNormals();
            smooth.center();

            smooth.computeBoundingBox();
            smooth.computeBoundingSphere();

            if (( smooth.hasAttribute( 'color' ) && allVertexColorsAreBlack( smooth ) ) || !smooth.hasAttribute( 'color' )) {
              const pos_count = smooth.getAttribute( 'position' ).count;
              const white = new Float32Array( pos_count * 3 ).fill( 1.0 );
              smooth.setAttribute( 'color', new THREE.BufferAttribute( white, 3 ) );
            }

            let mesh_material = await createMeshShaderMaterialTSL();

            mesh = new THREE.Mesh( smooth, mesh_material );

            smooth.dispose();
            mesh_material.dispose();
          }
        }

        // Add mesh to the scene
        scene.add( mesh );
        camera.lookAt( mesh.position );

        finish_loading();

        mouse_wheel = true;
      }

      function loadURLFile() {
        if (selected_url_file !== '') {
          if (selected_url_file.startsWith('https://www.dropbox.com') === true) {
            selected_url_file = selected_url_file.replace('www.dropbox.com', 'dl.dropbox.com');
          } else if (selected_url_file.startsWith('https://github.com') === true) {
            selected_url_file = ( selected_url_file.replace('github.com', 'raw.githubusercontent.com') ).replace('blob/', '');
          }

          // No extension checking for single URL so it has to point to PLY or STL file

          stl_loader.load( selected_url_file, addFileInScene,
          function( xhr ) { }, // onProgress
          function ( error1 ) { // onError
            url_ply = true;
            ply_loader.load( selected_url_file, addFileInScene,
            function( xhr ) { }, // onProgress
            function ( error2 ) { handle_error( error2 ); }); // onError
          });
        }
      }

      async function finish_loading() {
        if (halt_on_error) return;

        frame_camera();

        console.timeEnd( 'Loading Time' );

        // Stop flashing indicator
        document.getElementById('status_indicator').style.display = 'none';

        document.getElementById('div_loading').style.display = 'none';
        document.getElementById('div_message').style.display = 'none';

        if (gui_set === false) {
          // Add Brightness control
          gui.add( params, 'brightness', 0, 10, 0.1 ).name( 'Brightness' )
          .onChange( ( value ) => {
            if (mesh) {
              mesh.material.uniforms.uBrightness.value = parseFloat( value );
              mouse_wheel = true;
            }
          });

          // Add Roughness control
          gui.add( params, 'roughness', 0.0, 1.0, 0.025 ).name( 'Roughness' )
          .onChange( ( value ) => {
            if (mesh && !object_is_points) {
              mesh.material.uniforms.uRoughness.value = parseFloat( value );
              mouse_wheel = true;
            }
          });

          // Add Metalness control
          gui.add( params, 'metalness', 0.0, 1.0, 0.025 ).name( 'Metalness' )
          .onChange( ( value ) => {
            if (mesh && !object_is_points) {
              mesh.material.uniforms.uMetalness.value = parseFloat( value );
              mouse_wheel = true;
            }
          });

          set_gui_position();

          gui.open();
          gui_set = true;
        }

        const gui_roughness = gui.controllersRecursive().find( c => c.property === 'roughness' );
        const gui_metalness = gui.controllersRecursive().find( c => c.property === 'metalness' );

        if (object_is_points) {
          gui_roughness.show( false );
          gui_metalness.show( false );

          document.getElementById('btn_flat').style.display = 'none';
          document.getElementById('btn_wireframe').style.display = 'none';
        } else {
          gui_roughness.show( true );
          gui_metalness.show( true );

          document.getElementById('btn_flat').style.display = 'inline-block';
          document.getElementById('btn_wireframe').style.display = 'inline-block';
          document.getElementById('btn_flat').style.backgroundColor = 'transparent';
          document.getElementById('btn_wireframe').style.backgroundColor = 'transparent';
        }

        gui_container.style.display = 'block';
        set_gui_position();

        enable_disable( false );

        init_running = false;

        render_requested = true;
        mouse_wheel = true;
        render();

        if (isMobile === false) await new Promise( resolve => setTimeout( log_info(), 250 ) );
      }

      function log_info() {
        console.log( 'Memory: ', renderer.info.memory );
        console.log( 'Render: ', renderer.info.render );
      }

      function handle_error( error ) {
        if (isMobile === false) {
          document.getElementById('div_message').innerText = 'Check the console for any error messages';
        } else {
          document.getElementById('div_message').innerText = error.message || error;
        }

        document.getElementById('div_message').style.display = '';
        gui_container.style.display = 'none';

        console.timeEnd( 'Loading Time' );
        console.log( 'Error loading model!' );
        console.log( error );
        mouse_wheel = true;
        render_requested = false;
        enable_disable( true );

        // Stop flashing indicator
        document.getElementById('status_indicator').style.display = 'none';

        init_running = false;

        document.getElementById('div_loading').style.display = 'none';
        document.getElementById('div_error').style.display = 'block';
      }

      function quick_x_rotation( angle ) {
        mesh.rotateX( - Math.PI / 2.0 );

        mouse_wheel = true;
      }

      function set_flat() {
        if (mesh) {
          if (flat_shading_enabled) {
            document.getElementById('btn_flat').style.backgroundColor = 'transparent';
            flat_shading_enabled = false;
          } else {
            document.getElementById('btn_flat').style.backgroundColor = 'lightgreen';
            flat_shading_enabled = true;
          }

          mesh.traverse( ( child ) => {
            if (child.isMesh && child.material.uniforms) {
              child.material.uniforms.uUseFlatShading.value = flat_shading_enabled ? 1.0 : 0.0;
            }

            mouse_wheel = true;
          });
        }
      }

      function show_wireframe() {
        if (mesh) {
          if (wireframe_enabled) {
            wireframe_enabled = false;
            document.getElementById('btn_wireframe').style.backgroundColor = 'transparent';
          } else {
            wireframe_enabled = true;
            document.getElementById('btn_wireframe').style.backgroundColor = 'lightgreen';
          }

          mesh.traverse( ( child ) => {
            if (child.isMesh) child.material.wireframe = wireframe_enabled;
            mouse_wheel = true;
          });
        }
      }

      async function render() {
        if (mesh) {
          if (mouse_down || mouse_wheel) {
            controls.update();

            renderer.clear();
            renderer.render( scene, camera );

            if (mouse_wheel) {
              if (count > 5) {
                mouse_wheel = false;
                count = 0;
              } else {
                count ++;
              }
            }
          }
        }

        if (render_requested === true) requestAnimationFrame( render );
      }

      async function reset_all( reset = false ) {
        document.getElementById('back_color').value = '#000000';
        document.getElementById('btn_url').style.backgroundColor = 'transparent';
        document.getElementById('btn_flat').style.backgroundColor = 'transparent';
        document.getElementById('btn_wireframe').style.backgroundColor = 'transparent';
        document.getElementById('btn_wireframe').style.display = 'none';
        document.getElementById('btn_flat').style.display = 'none';

        init_running = false;

        if (gui_set) gui_reset();

        // Reset the view
        if (reset === true) {
          controls.reset();
          set_back_color();
        } else {
          // Page (re)loading
          if (scene) {
            if (gui) gui.dispose();

            if (mesh) await scene_cleanup();

            while (scene.children.length > 0) {
              scene.remove( scene.children[ 0 ] );
            }

            renderer.clear();
            renderer.dispose();
          }

          document.getElementById('file_input').value = '';
          document.getElementById('div_error').style.display = 'none';
          document.getElementById('url_entry').value = '';
          selected_url_file = '';
          enable_disable( true );
        }

        mouse_wheel = true;
      }

      async function scene_cleanup() {
        if (wireframe_enabled === true) await show_wireframe();

        scene.remove( mesh );

        renderer.clear();

        mesh.traverse( ( child ) => {
          if (child.isMesh || child.isPoints) {
            if (child.geometry) {
              child.geometry.dispose();
              child.geometry = null;
            }

            if (child.material) {
              if (child.material.uniforms) {
                Object.keys( child.material.uniforms ).forEach( key => {
                  const uniform = child.material.uniforms[ key ].value;
                  if (uniform && uniform.isTexture) uniform.dispose();
                });
              } else {
                if (child.material.map) child.material.map.dispose();
              }

              child.material.dispose();
              child.material = null;
            }
          }
        });

        mesh = undefined;

        if (!isMobile) renderer.info.reset();
      }

      function enable_disable( disable = false ) {
        document.getElementById('back_color').disabled = disable;
        document.getElementById('btn_quick_x').disabled = disable;
        disabled_changed();

        mouse_wheel = true;
      }
    </script>

    <script>
      async function document_ready() {
        const WebGPU = await import( "three/addons/capabilities/WebGPU.min.js" );
        const WebGL = await import( "three/addons/capabilities/WebGL.min.js" );

        gpu = WebGPU[ 'default' ].isAvailable();
        gl2 = WebGL[ 'default' ].isWebGL2Available();

        if ( gpu === true ) {
          console.log( 'WebGPU support detected' );
          document.getElementById('div_message').innerText += ' - WebGPU';
        } else if ( gl2 === true ) {
          console.log( 'WebGL2 support detected' );
          document.getElementById('div_message').innerText += ' - WebGL2';
        } else {
          document.body.appendChild( WebGPU[ 'default' ].getErrorMessage() );
          document.getElementById('fixed_menu').style.display = 'none';
          throw new Error( 'No WebGPU or WebGL2 support detected' );
        }

        isMobile = (/iPad|iPhone|iPod/.test( navigator.platform )) ||
          (/Android|webOS|iPhone|iPad|iPod|CriOS|BlackBerry|IEMobile|Opera Mini/i.test( navigator.userAgent )) ||
          (navigator.maxTouchPoints !== undefined && navigator.maxTouchPoints > 2 && /MacIntel/.test( navigator.platform ));

        $('#url_entry').keypress( function( event ) { if (event.key === 'Enter') $('#btn_load').click(); });
      }

      function disabled_changed() {
        $('button').each( function() {
          if (this.disabled === false ) {
            $(this).hover(
            function() { $(this)[ 0 ].style.border = 'solid 2px red'; },
            function() { $(this)[ 0 ].style.border = 'solid 1px blue'; });
          } else {
            $(this).unbind('mouseenter mouseleave');
          }

          mouse_wheel = true;
        });

        $('input[type=color]').each( function() {
          if (this.disabled === false ) {
            $(this).hover(
            function() { $(this)[ 0 ].style.border = 'solid 2px red'; },
            function() { $(this)[ 0 ].style.border = 'solid 1px whitesmoke'; });
          } else {
            $(this).unbind('mouseenter mouseleave');
          }

          mouse_wheel = true;
        });
      }
    </script>
  </body>
</html>
