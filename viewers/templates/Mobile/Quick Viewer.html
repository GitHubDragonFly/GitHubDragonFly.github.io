<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="encoding" content="utf-8" charset="utf-8">
    <meta name="description" content="Quick O3DV based viewer">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon"/>

    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" defer></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/occt-import-js@0.0.21/dist/occt-import-js.js" defer></script>

    <script src="https://cdn.jsdelivr.net/npm/online-3d-viewer@0.11.0/build/engine/o3dv.min.js"></script>
    <script>
      // Set the external libraries location
      OV.SetExternalLibLocation( 'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.11.0/libs' );

      // Init all the 3d viewer elements.
      OV.Init3DViewerElements();
    </script>

    <style>
      body, html {
        position: relative;
        display: block;
        width: 100%;
        min-height: 100vh;
        border: none;
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: black;
      }

      button {
        border: 1px solid blue;
        -webkit-border-radius: 2px;
        border-radius: 2px;
        margin: 2px 2px 2px 0;
        min-width: 22px;
        height: 22px;
        padding: 1px;
        vertical-align: middle;
      }

      label {
        vertical-align: middle;
        height: 22px;
        margin: 2px 0 2px 0;
      }

      input[type=color] {
        border: 1px solid whitesmoke;
        vertical-align: middle;
        margin: 2px 3px 2px -1px;
        background: none;
        height: 20px;
        width: 16px;
        padding: 0;
      }

      input[type=file] {
        vertical-align: middle;
        margin: 2px 0 2px 0;
        max-width: 160px;
      }

      input[type=range] {
        vertical-align: middle;
        margin: 2px 0 2px 0;
        min-width: 30px;
      }

      input[type=text] {
        vertical-align: middle;
        margin: 2px 2px 2px 0;
      }

      .dropdown {
        background-color: transparent;
        vertical-align: middle;
        display: inline-block;
        position: relative;
        min-width: 40px;
        font-size: 85%;
        color: blue;
        border: none;
        padding: 1px;
      }

      .dropdown-content {
        background-color: #FFFAD5;
        border: 1px solid #DEAF64;
        -webkit-border-radius: 2px;
        border-radius: 2px;
        position: absolute;
        margin-top: 2px;
        z-index: 10;
      }

      select {
        vertical-align: middle;
        border: 1px solid blue;
        -webkit-border-radius: 2px;
        border-radius: 2px;
        background: none;
        min-width: 70px;
        height: 22px;
        padding: 2px;
        margin: 2px;
        color: blue;
      }

      .spinner {
        position: absolute;
        display: none;
        z-index: 99;
        background-color: transparent;
        width: 60px;
        height: 60px;
        top: calc(50% - 32px);
        left: calc(50% - 32px);
        padding: 4px;
        border: 1px solid #4040FF;
        -webkit-border-radius: 50%;
        border-radius: 50%;
        border-top-color: transparent;
        border-bottom-color: transparent;
        -webkit-animation: spin 2s ease-in-out infinite;
        animation: spin 2s ease-in-out infinite;
      }

      @-webkit-keyframes spin { to { -webkit-transform: rotate( 360deg ); } }
      @keyframes spin { to { transform: rotate( 360deg ); } }

      .loading_msg {
        display: none;
        color: #B43232;
        text-align: center;
        background-color: transparent;
      }

      .fm { color: navy; width: 99.25%; border: 1px solid navy; -webkit-border-radius: 3px; border-radius: 3px; padding: 4px; margin: 1px; }

      .fixed-menu {
        background-color: whitesmoke;
        position: fixed;
        float: left;
        z-index: 99;
        padding: 1px;
        width: 100%;
        margin: 0;
      }

      div.online_3d_viewer {
        border: 1px solid blue;
        -webkit-border-radius: 2px;
        border-radius: 2px;
        width: 100%;
        z-index: 1;
      }
    </style>

    <!-- Using Online 3D Viewer as a base: https://github.com/kovacsv/Online3DViewer -->
    <!-- Using occt-import-js library: https://github.com/kovacsv/occt-import-js -->
    <!-- Environment maps work of Emil Persson, aka Humus: https://www.humus.name/ -->

    <title>Quick Viewer (O3DV)</title>
  </head>
  <body onload="reset(); first_run();" onresize="resize();">
    <div id="fixed_menu" class="fixed-menu">
      <div class="fm">
        <label for="file_input" title="3D Model Formats: 3DM, 3DS, 3MF, AMF, BIM, BREP, BRP, DAE, FBX, GLB, GLTF, IFC, IGES, IGS, OBJ + MTL, OFF, PLY, STL, STEP, STP, WRL" style="color: #553801; margin-left: 2px; margin-right: 3px;">3D</label>
        <button title="URL of the remote 3D model" id="btn_url" onclick="show_url();" style="min-width: 34px;">URL</button>
        <input type="file" title="Browse local files" id="file_input" onchange="init();" accept=".3dm, .3ds, .3mf, .amf, .bim, .bin, .brep, .brp, .dae, .fbx, .glb, .gltf, .ifc, .iges, .igs, .mtl, .obj, .off, .ply, .stl, .step, .stp, .wrl, .tga, .dds, image/png, image/jpeg, image/bmp, image/gif" multiple />
        <select title="Export" id="export_names" disabled>
          <option value="" selected disabled>Export</option>
          <option value="obj" onclick="export_obj();">OBJ</option>
          <option value="glb" onclick="export_glb();">GLB</option>
          <option value="gltf" onclick="export_gltf();">GLTF</option>
        </select>
      </div>
      <div class="fm" id="url" style="display: none;">
        <input type="text" id="url_entry" value="" style="width: 75%;" />
        <button onclick="load_url_file();" style="min-width: 36px;">Load</button>
        <button onclick="clear_url();" style="min-width: 36px;">Clear</button>
      </div>
      <div class="fm">
        <label for="back_color" title="Background Color" style="margin-left: 2px;">BG</label>
        <input type="color" title="Background Color" id="back_color" onchange="set_back_color();" disabled />
        <label for="directional_light_color" title="Directional Light Color">DL</label>
        <input type="color" title="Directional Light Color" id="directional_light_color" onchange="set_directional_light_color();" disabled />
        <button title="Directional Light Intensity" id="btn_dc1" class="dropdown" onclick="show_hide_dropdown1();" style="text-align: center; border: 1px solid blue; -webkit-border-radius: 2px; border-radius: 2px;">DLi
          <div id="dc1" class="dropdown-content" style="display: none;" onfocusout="hide_dropdown1();">
            <input type="range" orient="vertical" id="directional_light_intensity" min="0" max="10" step="0.25" value="2.5" onkeydown="return_false();" oninput="set_directional_light_intensity();" disabled />
            <span id="dli_val">2.5</span>
          </div>
        </button>
        <label for="ambient_light_color" title="Ambient Light Color">AL</label>
        <input type="color" title="Ambient Light Color" id="ambient_light_color" onchange="set_ambient_light_color();" disabled />
        <button title="Ambient Light Intensity" id="btn_dc2" class="dropdown" onclick="show_hide_dropdown2();" style="text-align: center; border: 1px solid blue; -webkit-border-radius: 2px; border-radius: 2px;">ALi
          <div id="dc2" class="dropdown-content" style="display: none;" onfocusout="hide_dropdown2();">
            <input type="range" orient="vertical" id="ambient_light_intensity" min="0" max="3" step="0.05" value="0.75" onkeydown="return_false();" oninput="set_ambient_light_intensity();" disabled />
            <span id="ali_val">0.75</span>
          </div>
        </button>
        <label for="edge_color" title="Edge Color">EC</label>
        <input type="color" title="Edge Color" id="edge_color" onchange="set_edge_color();" disabled />
        <button title="Edges" id="btn_edges" onclick="show_edges();" disabled>E</button>
      </div>
      <div class="fm" title="Export Download Link" id="div_download" style="display: none; text-align: center;">
        <a id="link" href="#" target="_blank" onclick="document.getElementById('div_download').style.display = 'none';">Download</a>
      </div>
      <div id="div_loading" class="loading_msg"></div>
      <div id="div_spinner" class="spinner"></div>
      <div class="online_3d_viewer" id="o3dv_element" style="width: 99.75%; height: 95vh;" defaultColor="new OV.RGBColor( 192, 192, 192 )">
      </div>
    </div>

    <script>
      const model_extensions = [ '.3DM', '.3DS', '.3MF', '.AMF', '.BIM', '.BIN', '.BREP', '.BRP', '.DAE', '.FBX', '.GLB', '.GLTF', '.IFC', '.IGES', '.IGS', '.MTL', '.OBJ', '.OFF', '.PLY', '.STL', '.STEP', '.STP', '.WRL' ];
      const occt_extensions = [ '.BREP', '.BRP', '.IGES', '.IGS', '.STEP', '.STP' ];
      const image_extensions = [ '.PNG', '.JPEG', '.JPG', '.JFIF', '.PJPEG', '.PJP', '.BMP', '.GIF', '.TGA', '.DDS' ];
      const textureNames = [
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posx.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negx.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posy.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negy.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posz.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negz.jpg'
      ];
      const backgroundIsEnvMap = false;

      function hide_dropdown1() { $('#dc1').fadeOut(); }
      function show_hide_dropdown1() { ($('#dc1')[ 0 ].style.display === 'none') ? ($('#dc1').fadeIn(), $('#directional_light_intensity').focus()) : $('#dc1').fadeOut(); }

      function hide_dropdown2() { $('#dc2').fadeOut(); }
      function show_hide_dropdown2() { ($('#dc2')[ 0 ].style.display === 'none') ? ($('#dc2').fadeIn(), $('#ambient_light_intensity').focus()) : $('#dc2').fadeOut(); }

      function return_false() { return false; }

      function show_url() {
        if (url_displayed === true) {
          document.getElementById('url').style.display = 'none';
          url_displayed = false;
        } else {
          document.getElementById('url').style.display = 'block';
          url_displayed = true;
        }
      }

      function load_url_file() {
        let url = document.getElementById('url_entry').value.trim();

        if (url !== '') {
          selected_url_file = url;
          url_loading = true;
          init();
        }
      }

      function clear_url() { document.getElementById('url_entry').value = ''; }

      function reset() {
        document.getElementById('file_input').value = '';
        document.getElementById('url_entry').value = '';
        enable_disable( true );
        set_lights();
      }

      function resize() { o3dv_embedded_viewer.viewer.Resize(); }

      function export_obj() {
        document.getElementById('export_names').selectedIndex = 0;

        Export( o3dv_embedded_viewer.model, OV.FileFormat.Text, 'obj', async ( exportedFiles ) => {
          for ( let i = 0; i < exportedFiles.length; i++ ) {
            zip.file( exportedFiles[ i ].name, exportedFiles[ i ].content );
          }

          await process_zip( 'OBJ' );
        });
      }

      function export_glb() {
        document.getElementById('export_names').selectedIndex = 0;

        Export( o3dv_embedded_viewer.model, OV.FileFormat.Binary, 'glb', async ( exportedFiles ) => {
          zip.file( exportedFiles[ 0 ].name, exportedFiles[ 0 ].content );

          await process_zip( 'GLB' );
        });
      }

      function export_gltf() {
        document.getElementById('export_names').selectedIndex = 0;

        Export( o3dv_embedded_viewer.model, OV.FileFormat.Text, 'gltf', async ( exportedFiles ) => {
          for ( let i = 0; i < exportedFiles.length; i++ ) {
            zip.file( exportedFiles[ i ].name, exportedFiles[ i ].content );
          }

          await process_zip( 'GLTF' );
        });
      }

      // Modified version of code from: https://github.com/kovacsv/Online3DViewer/blob/fefe79f09c4df6ef7a84af7e84e091183dc9f5ba/test/tests/exportimport_test.js
      const exporter = new OV.Exporter();
      const settings = new OV.ExporterSettings();

      function Export( model, format, extension, onReady ) {
        exporter.Export( model, settings, format, extension, {
          onSuccess : function( exportedFiles ) {
            onReady( exportedFiles );
          }
        });
      }

      async function process_zip( ext = '' ) {
        await zip.generateAsync( { type: 'blob', compression: "DEFLATE", compressionOptions: { level: 9 } } ).then( function( zipped_file ) {
          let link = document.getElementById('link');
          link.href = URL.createObjectURL( zipped_file );
          URL.revokeObjectURL( zipped_file );
          link.download = 'model_' + ext + '.zip';
          document.getElementById('div_download').style.display = 'block';

          zip = new JSZip();
        });
      }

      function enable_disable( disable = false ) {
        document.getElementById('div_loading').innerHTML = '';
        document.getElementById('div_loading').style.display = 'none';
        document.getElementById('div_spinner').style.display = 'none';

        document.getElementById('btn_dc1').disabled = disable;
        document.getElementById('btn_dc2').disabled = disable;
        document.getElementById('btn_edges').disabled = disable;
        document.getElementById('export_names').disabled = disable;
        document.getElementById('back_color').disabled = disable;
        document.getElementById('ambient_light_color').disabled = disable;
        document.getElementById('ambient_light_intensity').disabled = disable;
        document.getElementById('directional_light_color').disabled = disable;
        document.getElementById('directional_light_intensity').disabled = disable;

        disabled_changed();
      }

      function disabled_changed() {
        $('button').each( function() {
          if (this.disabled === false ) {
            $(this).hover(
            function() { $(this)[ 0 ].style.border = 'solid 2px blue'; },
            function() { $(this)[ 0 ].style.border = 'solid 1px blue'; });
          } else {
            $(this).unbind('mouseenter mouseleave');
          }
        });

        $('input[type=color]').each( function() {
          if (this.disabled === false ) {
            $(this).hover(
            function() { $(this)[ 0 ].style.border = 'solid 1px blue'; },
            function() { $(this)[ 0 ].style.border = 'solid 1px whitesmoke'; });
          } else {
            $(this).unbind('mouseenter mouseleave');
          }
        });
      }

      function first_run() {
        let element = document.getElementById('o3dv_element');
        o3dv_embedded_viewer = new OV.EmbeddedViewer( element, { defaultColor: new OV.RGBColor( 192, 192, 192 ), environmentSettings: new OV.EnvironmentSettings( textureNames, backgroundIsEnvMap ) } );
        set_lights();
      }

      function set_lights() {
        document.getElementById('back_color').value = '#FFFFFF';
        document.getElementById('edge_color').value = '#FF0000';
        document.getElementById('ambient_light_color').value = '#FFFFFF';
        document.getElementById('ambient_light_intensity').value = 0.75;
        document.getElementById('directional_light_color').value = '#FFFFFF';
        document.getElementById('directional_light_intensity').value = 2.5;

        if (o3dv_embedded_viewer) {
          set_ambient_light_intensity();
          set_directional_light_intensity();
          set_ambient_light_color();
          set_directional_light_color();
          if (edges_visible) show_edges();
        }
      }

      function set_back_color() {
        let bg_colors = document.getElementById('back_color').value; // hex format '#rrggbb'
        o3dv_embedded_viewer.viewer.SetBackgroundColor( new OV.RGBAColor( parseInt( bg_colors.substring( 1, 3 ), 16 ), parseInt( bg_colors.substring( 3, 5 ), 16 ), parseInt( bg_colors.substring( 5 ), 16 ), 255 ) );

        o3dv_embedded_viewer.viewer.Render();
      }

      function set_directional_light_color() {
        let dl_color = document.getElementById('directional_light_color').value; // hex format '#rrggbb'
        o3dv_embedded_viewer.viewer.scene.children[ 2 ].color.setRGB( parseInt( dl_color.substring( 1, 3 ), 16 ) / 255.0, parseInt( dl_color.substring( 3, 5 ), 16 ) / 255.0, parseInt( dl_color.substring( 5 ), 16 ) / 255.0 );

        o3dv_embedded_viewer.viewer.Render();
      }

      function set_directional_light_intensity() {
        let dli_value = document.getElementById('directional_light_intensity').value;
        document.getElementById('dli_val').innerText = dli_value;
        o3dv_embedded_viewer.viewer.scene.children[ 2 ].intensity = parseFloat( dli_value );

        o3dv_embedded_viewer.viewer.Render();
      }

      function set_ambient_light_color() {
        let al_color = document.getElementById('ambient_light_color').value; // hex format '#rrggbb'
        o3dv_embedded_viewer.viewer.scene.children[ 1 ].color.setRGB( parseInt( al_color.substring( 1, 3 ), 16 ) / 255.0, parseInt( al_color.substring( 3, 5 ), 16 ) / 255.0, parseInt( al_color.substring( 5 ), 16 ) / 255.0 );

        o3dv_embedded_viewer.viewer.Render();
      }

      function set_ambient_light_intensity() {
        let ali_value = document.getElementById('ambient_light_intensity').value;
        document.getElementById('ali_val').innerText = ali_value;
        o3dv_embedded_viewer.viewer.scene.children[ 1 ].intensity = parseFloat( ali_value );

        o3dv_embedded_viewer.viewer.Render();
      }

      function set_edge_color() {
        let e_color = document.getElementById('edge_color').value; // hex format '#rrggbb'

        let r = parseInt( e_color.substring( 1, 3 ), 16 ) / 255.0;
        let g = parseInt( e_color.substring( 3, 5 ), 16 ) / 255.0;
        let b = parseInt( e_color.substring( 5 ), 16 ) / 255.0;

        edges.traverse( child => {
          if (child.type === 'LineSegments') child.material.color.setRGB( r, g, b );
        });

        o3dv_embedded_viewer.viewer.Render();
      }

      function show_edges() {
        if (edges_visible === true) {
          edges_visible = false;

          mesh !== undefined ? mesh.remove( edges ) : o3dv_embedded_viewer.viewer.scene.remove( edges );

          document.getElementById('edge_color').disabled = true;
          document.getElementById('btn_edges').style.backgroundColor = '#d1cefc';
        } else {
          if (edges_added === false) {
            o3dv_embedded_viewer.viewer.scene.traverse( child => {
              if (child.isMesh) {
                let innerEdgesGeometry = new THREE.EdgesGeometry( child.geometry, 30 );
                let edge = new THREE.LineSegments( innerEdgesGeometry, outline_material );
                edge.applyMatrix4( child.matrixWorld );
                edges.add( edge );
                edges_added = true;
              }
            });
          }

          edges_visible = true;

          mesh !== undefined ? mesh.add( edges ) : o3dv_embedded_viewer.viewer.scene.add( edges );

          document.getElementById('edge_color').disabled = false;
          document.getElementById('btn_edges').style.backgroundColor = 'lightgreen';
        }

        o3dv_embedded_viewer.viewer.Render();

        disabled_changed();
      }
    </script>

    <script>
      var o3dv_embedded_viewer, mesh, bounding_box, ext;
      var local_files, url_files, selected_model_file;
      var selected_url_model_file, selected_url_file = '';
      var url_displayed = false, url_loading = false, zip;
      var edges, edges_added, edges_visible, outline_material;

      function init() {
        if (zip === undefined) zip = new JSZip();

        if (o3dv_embedded_viewer !== undefined) {
          o3dv_embedded_viewer.viewer.Clear();

          if (edges_added && edges.children.length > 0) {
            edges.traverse( child => {
              if (child.type === 'LineSegments') {
                if (child.material && child.material.map) child.material.map.dispose();
                if (child.material) child.material.dispose();
                if (child.geometry) child.geometry.dispose();
              }
            });
          }

          if (mesh !== undefined) {
            if (mesh.material && mesh.material.map) mesh.material.map.dispose();
            if (mesh.material) mesh.material.dispose();
            if (mesh.geometry) mesh.geometry.dispose();
            mesh = undefined;
          }
        }

        outline_material = new THREE.LineBasicMaterial( { color: 0xFF0000 } );
        edges = new THREE.Group();
        edges_added = false;
        edges_visible = false;

        if (url_loading === false) {
          selected_model_file = null;
          selected_url_file = '';
          local_files = [];

          // Loaded files
          var fi = document.getElementById('file_input');

          for (let i = 0; i < fi.files.length; i++) {
            if (fi.files[ i ].type !== '' && fi.files[ i ].type.startsWith('image/')) {
              local_files.push( fi.files[ i ] );
            } else if (fi.files[ i ].name.indexOf( '.' ) > -1 && model_extensions.includes( fi.files[ i ].name.toUpperCase().substring( fi.files[ i ].name.lastIndexOf( '.' ) ))) {
              selected_model_file = fi.files[ i ];
              local_files.push( fi.files[ i ] );
            }
          };

          if (selected_model_file === null) {
            enable_disable( true );
            document.getElementById('div_loading').innerHTML = 'No valid model file selected!';
            document.getElementById('div_loading').style.display = 'block';
            console.log( 'No valid model file selected!' );
            return;
          }
        } else {
          selected_url_model_file = null;
          selected_model_file = null;
          url_loading = false;
          url_files = [];

          // Reset the file input
          document.getElementById('file_input').value = '';
        }

        // Load the model
        selected_model_file !== null ? loadFile() : loadURLFile();
      }

      async function loadFile() {
        document.getElementById('div_loading').style.display = 'none';

        if (o3dv_embedded_viewer !== undefined) o3dv_embedded_viewer.viewer.Clear();

        let element = document.getElementById('o3dv_element');
        element.innerHTML = '';

        o3dv_embedded_viewer = new OV.EmbeddedViewer( element, { defaultColor: new OV.RGBColor( 192, 192, 192 ), environmentSettings: new OV.EnvironmentSettings( textureNames, backgroundIsEnvMap ) } );

        ext = selected_model_file.name.toUpperCase().substring( selected_model_file.name.lastIndexOf( '.' ) );

        if (occt_extensions.includes( ext ) === true) {
          document.getElementById('div_loading').innerHTML = 'Loading OCCT ... Please wait';
          document.getElementById('div_loading').style.display = 'block';
          document.getElementById('div_spinner').style.display = 'block';

          bounding_box = new THREE.Box3();
          mesh = new THREE.Object3D();

          occtimportjs().then ( async function( occt ) {
            response = await fetch( URL.createObjectURL( selected_model_file ) );
            URL.revokeObjectURL( selected_model_file );

            buffer = await response.arrayBuffer();
            fileBuffer = new Uint8Array( buffer );

            let result;

            ext.startsWith( '.I' ) === true ? result = await occt.ReadIgesFile( fileBuffer, null ) : ( ext.startsWith( '.B' ) === true ? result = await occt.ReadBrepFile( fileBuffer, null ) : result = await occt.ReadStepFile( fileBuffer, null ));

            if (result.success && result.meshes.length > 0) {
              o3dv_embedded_viewer.model = new OV.Model();

              let mesh_count = 0;

              // Modified version of the original example code at https://github.com/kovacsv/occt-import-js/blob/main/examples/three_viewer.html#L42-L89
              for (let resultMesh of result.meshes) {
                let geometry = new THREE.BufferGeometry();

                geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( resultMesh.attributes.position.array, 3 ) );

                if (resultMesh.attributes.normal) {
                  geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( resultMesh.attributes.normal.array, 3 ) );
                }

                let index = Uint32Array.from( resultMesh.index.array );
                geometry.setIndex( new THREE.BufferAttribute( index, 1 ) );
            
                let defaultMaterial;

                if (resultMesh.color) {
                  let color = new THREE.Color( resultMesh.color[ 0 ], resultMesh.color[ 1 ], resultMesh.color[ 2 ] );
                  defaultMaterial = new THREE.MeshPhongMaterial( { name: 'default_material_' + mesh_count, side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } );
                } else {
                  defaultMaterial = new THREE.MeshPhongMaterial( { name: 'default_material_' + mesh_count, side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: 0xFFFFFF } );
                }

                let materials = defaultMaterial;

                if (resultMesh.brep_faces && resultMesh.brep_faces.length > 0) {
                  materials = [ defaultMaterial ];

                  for (let faceColor of resultMesh.brep_faces) {
                    let color = faceColor.color ? new THREE.Color( faceColor.color[ 0 ], faceColor.color[ 1 ], faceColor.color[ 2 ] ) : defaultMaterial.color;
                    materials.push( new THREE.MeshPhongMaterial( { name: 'material_' + mesh_count, side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } ) );
                  }

                  let triangleCount = resultMesh.index.array.length / 3;
                  let triangleIndex = 0;
                  let faceColorGroupIndex = 0;

                  while (triangleIndex < triangleCount) {
                    let firstIndex = triangleIndex;
                    let lastIndex = null;
                    let materialIndex = null;

                    if (faceColorGroupIndex >= resultMesh.brep_faces.length) {
                      lastIndex = triangleCount;
                      materialIndex = 0;
                    } else if (triangleIndex < resultMesh.brep_faces[ faceColorGroupIndex ].first) {
                      lastIndex = resultMesh.brep_faces[ faceColorGroupIndex ].first;
                      materialIndex = 0;
                    } else {
                      lastIndex = resultMesh.brep_faces[ faceColorGroupIndex ].last + 1;
                      materialIndex = faceColorGroupIndex + 1;
                      faceColorGroupIndex++;
                    }

                    geometry.addGroup( firstIndex * 3, ( lastIndex - firstIndex ) * 3, materialIndex );
                    triangleIndex = lastIndex;

                    let innerGeometry = new THREE.BufferGeometry();
                    innerGeometry.setAttribute( 'position', geometry.attributes.position );
                    if (geometry.attributes.normal) innerGeometry.setAttribute( 'normal', geometry.attributes.normal );
                    innerGeometry.setIndex( new THREE.BufferAttribute( index.slice( firstIndex * 3, lastIndex * 3 ), 1 ) );
                    let innerEdgesGeometry = new THREE.EdgesGeometry( innerGeometry, 30 );
                    let edge = new THREE.LineSegments( innerEdgesGeometry, outline_material );
                    edges.add( edge );
                    edges_added = true;
                  }
                }

                let new_mesh = new THREE.Mesh( geometry, materials );

                mesh.add( new_mesh );

                let ov_material = new OV.PhysicalMaterial();
                ov_material.name = materials[ 1 ].name;
                ov_material.color = new OV.RGBAColor( materials[ 1 ].color.r * 255.0, materials[ 1 ].color.g * 255.0, materials[ 1 ].color.b * 255.0, 255 );
                ov_material.roughness = 0.4;
                ov_material.metalness = 0.5;
                ov_material.reflectivity = 0.5;

                o3dv_embedded_viewer.model.AddMaterial( ov_material );

                let ov_mesh = OV.ConvertThreeGeometryToMesh( new_mesh.geometry, mesh_count, null );
                ov_mesh.SetName( 'mesh_' + mesh_count );
                o3dv_embedded_viewer.model.AddMeshToRootNode( ov_mesh );

                if (Array.isArray( materials )) {
                  materials.forEach( mtl => {
                    mtl.dispose();
                  });

                  new_mesh.material.forEach( mtrl => {
                    mtrl.dispose();
                  });
                } else {
                  materials.dispose();
                  new_mesh.material.dispose();
                }

                geometry.dispose();
                new_mesh.geometry.dispose();

                mesh_count += 1;
              }

              // Set the initial scale of the object so it comes to view
              bounding_box.setFromObject( mesh );
              let y;

              if (bounding_box.max.y < 0) {
                y = Math.abs( bounding_box.min.y ) - Math.abs( bounding_box.max.y );
              } else if (bounding_box.max.y >= 0 && bounding_box.min.y <= 0) {
                y = Math.abs( bounding_box.max.y ) + Math.abs( bounding_box.min.y );
              } else {
                y = Math.abs( bounding_box.max.y ) - Math.abs( bounding_box.min.y );
              }

              mesh.position.set( 0, 0, 0 );
              mesh.scale.multiplyScalar( 0.75 / y );

              o3dv_embedded_viewer.viewer.SetMainObject( mesh );
              o3dv_embedded_viewer.viewer.mainModel.UpdateWorldMatrix();

              enable_disable();
              set_lights();

              o3dv_embedded_viewer.viewer.Render();
            } else {
              enable_disable( true );
              document.getElementById('div_loading').innerHTML = 'No mesh detected!';
              document.getElementById('div_loading').style.display = 'block';
              console.log( 'No mesh detected!' );
              return;
            }

            await new Promise( resolve => setTimeout( resolve, 1000 ) ); // adjust timing if necessary
          });
        } else {
          document.getElementById('div_spinner').style.display = 'block';

          o3dv_embedded_viewer.LoadModelFromFileList( local_files );

          let i = 0;

          // Wait up to 10 seconds for the model to load
          while ( o3dv_embedded_viewer.model === null && i < 100 ) {
            await new Promise( resolve => setTimeout( resolve, 100 ) );
            i ++;
          }

          if (o3dv_embedded_viewer.model !== null) {
            o3dv_embedded_viewer.viewer.mainModel.UpdateWorldMatrix();

            o3dv_embedded_viewer.viewer.scene.traverse( child => {
              if (child.isMesh) {
                let innerEdgesGeometry = new THREE.EdgesGeometry( child.geometry, 30 );
                let edge = new THREE.LineSegments( innerEdgesGeometry, outline_material );
                edge.applyMatrix4( child.matrixWorld );
                edges.add( edge );
                edges_added = true;
              }
            });
          }

          enable_disable();
          set_lights();

          o3dv_embedded_viewer.viewer.Render();
        }
      }

      async function loadURLFile() {
        if (selected_url_file !== '') {
          if (selected_url_file.indexOf( ',' ) > -1) {
            let urls = selected_url_file.split( ',' );

            for (let i = 0; i < urls.length; i++) {
              let url = urls[ i ].trim();
              let url_uc = url.toUpperCase();


              if (url_uc.indexOf( '.' ) > -1 && (image_extensions.includes( url_uc.substring( url_uc.lastIndexOf( '.' ) )) || url_uc.includes( 'DROPBOX' ) || url_uc.includes( 'GITHUB' ))) {
                url_files.push( url );
              } else if (url_uc.indexOf( '.' ) > -1 && model_extensions.includes( url_uc.substring( url_uc.lastIndexOf( '.' ) ))) {
                url_files.push( url );
                selected_url_model_file = url;
              }
            }

            if (selected_url_model_file === null) {
              enable_disable( true );
              document.getElementById('div_loading').innerHTML = 'No valid URL model file selected!';
              document.getElementById('div_loading').style.display = 'block';
              console.log( 'No valid URL model file selected!' );
              return;
            }
          } else {
            let url_uc = selected_url_file.toUpperCase();

            if (url_uc.indexOf( '.' ) > -1 && ( model_extensions.includes( url_uc.substring( url_uc.lastIndexOf( '.' ) )) || url_uc.includes( 'DROPBOX' ) || url_uc.includes( 'GITHUB' ))) {
              url_files.push( selected_url_file );
            } else {
              enable_disable( true );
              document.getElementById('div_loading').innerHTML = 'No valid URL model file selected!';
              document.getElementById('div_loading').style.display = 'block';
              console.log( 'No valid URL model file selected!' );
              return;
            }
          }

          if (url_files.length > 0) {
            document.getElementById('div_loading').style.display = 'none';

            if (o3dv_embedded_viewer !== undefined) o3dv_embedded_viewer.viewer.Clear();

            let element = document.getElementById('o3dv_element');
            element.innerHTML = '';

            o3dv_embedded_viewer = new OV.EmbeddedViewer( element, { defaultColor: new OV.RGBColor( 192, 192, 192 ), environmentSettings: new OV.EnvironmentSettings( textureNames, backgroundIsEnvMap ) } );

            if (selected_url_model_file === null) {
              ext = selected_url_file.toUpperCase().substring( selected_url_file.lastIndexOf( '.' ) );
            } else {
              ext = selected_url_model_file.toUpperCase().substring( selected_url_model_file.lastIndexOf( '.' ) );
            }

            if (occt_extensions.includes( ext ) === true) {
              document.getElementById('div_loading').innerHTML = 'Loading OCCT ... Please wait';
              document.getElementById('div_loading').style.display = 'block';
              document.getElementById('div_spinner').style.display = 'block';

              bounding_box = new THREE.Box3();
              mesh = new THREE.Object3D();

              occtimportjs().then ( async function( occt ) {
                response = (selected_url_model_file === null) ? await fetch( selected_url_file ) : await fetch( selected_url_model_file );

                buffer = await response.arrayBuffer();
                fileBuffer = new Uint8Array( buffer );

                let result;

                ext.startsWith( '.I' ) === true ? result = await occt.ReadIgesFile( fileBuffer, null ) : ( ext.startsWith( '.B' ) === true ? result = await occt.ReadBrepFile( fileBuffer, null ) : result = await occt.ReadStepFile( fileBuffer, null ));

                if (result.success && result.meshes.length > 0) {
                  o3dv_embedded_viewer.model = new OV.Model();

                  let mesh_count = 0;

                  // Modified version of the original example code at https://github.com/kovacsv/occt-import-js/blob/main/examples/three_viewer.html#L42-L89
                  for (let resultMesh of result.meshes) {
                    let geometry = new THREE.BufferGeometry();

                    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( resultMesh.attributes.position.array, 3 ) );

                    if (resultMesh.attributes.normal) {
                      geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( resultMesh.attributes.normal.array, 3 ) );
                    }

                    let index = Uint32Array.from( resultMesh.index.array );
                    geometry.setIndex( new THREE.BufferAttribute( index, 1 ) );
    
                    let defaultMaterial;

                    if (resultMesh.color) {
                      let color = new THREE.Color( resultMesh.color[ 0 ], resultMesh.color[ 1 ], resultMesh.color[ 2 ] );
                      defaultMaterial = new THREE.MeshPhongMaterial( { name: 'default_material_' + mesh_count, side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } );
                    } else {
                      defaultMaterial = new THREE.MeshPhongMaterial( { name: 'default_material_' + mesh_count, side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: 0xFFFFFF } );
                    }

                    let materials = defaultMaterial;

                    if (resultMesh.brep_faces && resultMesh.brep_faces.length > 0) {
                      materials = [ defaultMaterial ];

                      for (let faceColor of resultMesh.brep_faces) {
                        let color = faceColor.color ? new THREE.Color( faceColor.color[ 0 ], faceColor.color[ 1 ], faceColor.color[ 2 ] ) : defaultMaterial.color;
                        materials.push( new THREE.MeshPhongMaterial( { name: 'material_' + mesh_count, side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } ) );
                      }

                      let triangleCount = resultMesh.index.array.length / 3;
                      let triangleIndex = 0;
                      let faceColorGroupIndex = 0;

                      while (triangleIndex < triangleCount) {
                        let firstIndex = triangleIndex;
                        let lastIndex = null;
                        let materialIndex = null;

                        if (faceColorGroupIndex >= resultMesh.brep_faces.length) {
                          lastIndex = triangleCount;
                          materialIndex = 0;
                        } else if (triangleIndex < resultMesh.brep_faces[ faceColorGroupIndex ].first) {
                          lastIndex = resultMesh.brep_faces[ faceColorGroupIndex ].first;
                          materialIndex = 0;
                        } else {
                          lastIndex = resultMesh.brep_faces[ faceColorGroupIndex ].last + 1;
                          materialIndex = faceColorGroupIndex + 1;
                          faceColorGroupIndex++;
                        }

                        geometry.addGroup( firstIndex * 3, ( lastIndex - firstIndex ) * 3, materialIndex );
                        triangleIndex = lastIndex;

                        let innerGeometry = new THREE.BufferGeometry();
                        innerGeometry.setAttribute( 'position', geometry.attributes.position );
                        if (geometry.attributes.normal) innerGeometry.setAttribute( 'normal', geometry.attributes.normal );
                        innerGeometry.setIndex( new THREE.BufferAttribute( index.slice( firstIndex * 3, lastIndex * 3 ), 1 ) );
                        let innerEdgesGeometry = new THREE.EdgesGeometry( innerGeometry, 30 );
                        let edge = new THREE.LineSegments( innerEdgesGeometry, outline_material );
                        edges.add( edge );
                        edges_added = true;
                      }
                    }

                    let new_mesh = new THREE.Mesh( geometry, materials );

                    mesh.add( new_mesh );

                    let ov_material = new OV.PhysicalMaterial();
                    ov_material.name = materials[ 1 ].name;
                    ov_material.color = new OV.RGBAColor( materials[ 1 ].color.r * 255.0, materials[ 1 ].color.g * 255.0, materials[ 1 ].color.b * 255.0, 255 );
                    ov_material.roughness = 0.4;
                    ov_material.metalness = 0.5;
                    ov_material.reflectivity = 0.5;

                    o3dv_embedded_viewer.model.AddMaterial( ov_material );

                    let ov_mesh = OV.ConvertThreeGeometryToMesh( new_mesh.geometry, mesh_count, null );
                    ov_mesh.SetName( 'mesh_' + mesh_count );
                    o3dv_embedded_viewer.model.AddMeshToRootNode( ov_mesh );

                    if (Array.isArray( materials )) {
                      materials.forEach( mtl => {
                        mtl.dispose();
                      });

                      new_mesh.material.forEach( mtrl => {
                        mtrl.dispose();
                      });
                    } else {
                      materials.dispose();
                      new_mesh.material.dispose();
                    }

                    geometry.dispose();
                    new_mesh.geometry.dispose();

                    mesh_count += 1;
                  }

                  // Set the initial scale of the object so it comes to view
                  bounding_box.setFromObject( mesh );
                  let y;

                  if (bounding_box.max.y < 0) {
                    y = Math.abs( bounding_box.min.y ) - Math.abs( bounding_box.max.y );
                  } else if (bounding_box.max.y >= 0 && bounding_box.min.y <= 0) {
                    y = Math.abs( bounding_box.max.y ) + Math.abs( bounding_box.min.y );
                  } else {
                    y = Math.abs( bounding_box.max.y ) - Math.abs( bounding_box.min.y );
                  }

                  mesh.position.set( 0, 0, 0 );
                  mesh.scale.multiplyScalar( 0.75 / y );

                  o3dv_embedded_viewer.viewer.SetMainObject( mesh );
                  o3dv_embedded_viewer.viewer.mainModel.UpdateWorldMatrix();

                  enable_disable();
                  set_lights();

                  o3dv_embedded_viewer.viewer.Render();
                } else {
                  enable_disable( true );
                  document.getElementById('div_loading').innerHTML = 'No mesh detected!';
                  document.getElementById('div_loading').style.display = 'block';
                  console.log( 'No mesh detected!' );
                  return;
                }

                await new Promise( resolve => setTimeout( resolve, 1000 ) ); // adjust timing if necessary
              });
            } else {
              document.getElementById('div_spinner').style.display = 'block';

              o3dv_embedded_viewer.LoadModelFromUrlList( url_files );

              let i = 0;

              // Wait up to 10 seconds for the model to load
              while ( o3dv_embedded_viewer.model === null && i < 100 ) {
                await new Promise( resolve => setTimeout( resolve, 100 ) );
                i ++;
              }

              if (o3dv_embedded_viewer.model !== null) {
                o3dv_embedded_viewer.viewer.mainModel.UpdateWorldMatrix();

                o3dv_embedded_viewer.viewer.scene.traverse( child => {
                  if (child.isMesh) {
                    let innerEdgesGeometry = new THREE.EdgesGeometry( child.geometry, 30 );
                    let edge = new THREE.LineSegments( innerEdgesGeometry, outline_material );
                    edge.applyMatrix4( child.matrixWorld );
                    edges.add( edge );
                    edges_added = true;
                  }
                });
              }

              enable_disable();
              set_lights();

              o3dv_embedded_viewer.viewer.Render();
            }
          }
        }
      }
    </script>
  </body>
</html>
