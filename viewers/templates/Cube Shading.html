<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="encoding" content="utf-8" charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Simple Cube Shading Example">
    <link rel="shortcut icon" href="../static/favicon.ico" type="image/x-icon"/>

    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.8.3/dist/es-module-shims.min.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/"
        }
      }
    </script>

    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>

    <!-- Use different functions to manipulate each of the RGBA components -->

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float u_time;

        void main() {
            gl_FragColor = vec4( atan(cos(u_time)), atan(sin(u_time)), cos(atan(u_time)), sin(u_time) );
        }
    </script>

    <style>
      body, html {
        position: relative;
        display: block;
        background-color: #000080;
        width: 100%;
        min-height: 100vh;
        border: none;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
    </style>

    <!-- Ref: https://thebookofshaders.com/04/ -->

    <title>Cube Shading</title>

  <body>
    <script type="module">
      import {
        BoxGeometry,
        Clock,
        DoubleSide,
        EdgesGeometry,
        LineBasicMaterial,
        LineSegments,
        Mesh,
        PerspectiveCamera,
        Scene,
        ShaderMaterial,
        WebGLRenderer
      } from "three";

      import {
        OrbitControls
      } from "three/addons/controls/OrbitControls.min.js";

      var mesh, camera, scene, controls, renderer, clock;
      var ww = window.innerWidth, wh = window.innerHeight;
      var uniforms;

      init();
      animate();

      function init() {
        renderer = new WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor( 0xFFFFFF, 0 );
        renderer.setSize( ww, wh );
        renderer.autoClear = false;

        document.body.appendChild( renderer.domElement );

        camera = new PerspectiveCamera( 45, ww / wh, 0.5, 5000 );
        camera.position.z = 2;

        scene = new Scene();
        clock = new Clock();

        uniforms = {
          u_time: { type: "f", value: 0.0 }
        };

        var material = new ShaderMaterial({
          uniforms: uniforms,
          vertexShader: document.getElementById( 'vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
          side: DoubleSide
        });

        let geometry = new BoxGeometry( 1.0, 1.0, 1.0 );

        let edges_material = new LineBasicMaterial( { color: 0x000040 } );
        let edges = new LineSegments( new EdgesGeometry( geometry, 30 ), edges_material );

        mesh = new Mesh( geometry, material );
        mesh.add( edges );

        scene.add( mesh );

        controls = new OrbitControls( camera, renderer.domElement );

        window.addEventListener( "resize", resize, false );
      }

      function resize( event ) {
        ww = window.innerWidth;
        wh = window.innerHeight;

        renderer.setSize( ww, wh );

        camera.aspect = ww / wh;
        camera.updateProjectionMatrix();
      }

      function animate() {
        requestAnimationFrame( animate );
        render();
      }

      function render() {
        uniforms.u_time.value += clock.getDelta();

        mesh.rotateY( 0.003 );

        controls.update();

        renderer.clear();
        renderer.render( scene, camera );

        scene.updateMatrixWorld();
        camera.updateMatrixWorld();
      }
    </script>
  </body>
</html>
