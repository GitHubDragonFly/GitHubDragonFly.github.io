<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="encoding" content="utf-8" charset="utf-8">
    <meta name="description" content="Quick O3DV based viewer">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <link rel="shortcut icon" href="../../images/favicon.ico" type="image/x-icon"/>

    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/libs/loaders/occt-import-js.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/build/o3dv.min.js"></script>
    <script>
      // Set the external libraries location
      OV.SetExternalLibLocation( 'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/libs' );

      // Init all the 3d viewer elements.
      OV.Init3DViewerElements();
    </script>

    <style>
      body, html {
        position: relative;
        display: block;
        width: 100%;
        min-height: 100vh;
        background-color: black;
        border: none;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }

      button {
        background-color: #d1cefc;
        border: 1px solid darkblue;
        -webkit-border-radius: 2px;
        border-radius: 2px;
        margin: 2px 2px 2px 0;
        min-width: 22px;
        height: 22px;
        padding: 1px;
        vertical-align: middle;
      }

      label { vertical-align: middle; height: 22px; margin: 2px 3px 2px 0; }

      input[type=file] {
        vertical-align: middle;
        margin: 2px 3px 2px 0;
        max-width: 175px;
      }

      input[type=text] { vertical-align: middle; margin: 2px 2px 2px 0; }

      .loading_msg {
        display: none;
        background-color: transparent;
        color: green;
        text-align: center;
      }

      p.full_screen {
        text-align: center;
        content: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAf0lEQVRIie1VQQ6AMAjb/x9M4IRePICoK7GLB5eQbElpCTAY7j6YRiUPAvvxbNMkN76XIDhSRKCdjhmB494hzzwngcoBIa/eASgisMgTBo4ODqCTAiSFrW6Biv8LfL/I1DbtfDRV9VLgjVFhZp59A4g+7JaM6yULh7IyWUYX2AAPDxz26GjX+gAAAABJRU5ErkJggg==);
        margin: 1px 1px 1px 2px;
        padding: 0;
        width: 15px;
        height: 15px;
      }

      .fm { color: navy; width: 99.25%; border: 1px solid navy; -webkit-border-radius: 2px; border-radius: 2px; padding: 4px; margin: 1px; }

      .fixed-menu {
        position: fixed;
        z-index: 99999;
        display: inline-block;
        background-color: whitesmoke;
        margin: 0px;
        padding: 1px;
        width: 100%;
      }

      div.online_3d_viewer {
        z-index: 1;
        width: 100%;
        border: 1px solid blue;
      }
    </style>

    <!-- Using Online 3D Viewer as a base: https://github.com/kovacsv/Online3DViewer -->
    <!-- Environment maps work of Emil Persson, aka Humus: https://www.humus.name/ -->

    <title>Quick Viewer (O3DV)</title>
  </head>
  <body onload="reset();" onresize="resize();">
    <div id="fixed_menu" class="fixed-menu">
      <div class="fm">
        <label for="file" title="3DM, 3DS, 3MF, BIM, BREP, BRP, DAE, FBX, FCSTD, GLB, GLTF, IFC, IGES, IGS, OBJ + MTL, OFF, PLY, STL, STEP, STP, WRL" style="color: #553801; margin-left: 3px;">Model</label>
        <button id="btn_url" onclick="show_url()" style="background-color: transparent; min-width: 34px;">URL</button>
        <label for="file_input" title="File Input"></label>
        <input type="file" id="file_input" name="file" onchange="init()" accept=".3dm, .3ds, .3mf, .bim, .brep, .brp, .dae, .fbx, .fcstd, .glb, .gltf, .ifc, .iges, .igs, .mtl, .obj, .off, .ply, .stl, .step, .stp, .wrl, image/png, image/jpeg, image/bmp, image/gif" multiple />
        <button id="btn_full_screen" title="Full Screen" onclick="full_screen()" style="float: right; background-color: transparent; min-width: 24px;"><p class="full_screen"></p></button>
      </div>
      <div class="fm" id="url" style="display: none;">
        <label for="url_entry">URL:</label>
        <input type="text" id="url_entry" name="url_entry" value="" style="width: 85%;" />
        <button onclick="load_url_file()" style="width: 50px;">Load</button>
        <button onclick="clear_url()" style="width: 50px;">Clear</button>
      </div>
      <div id="div_loading" class="loading_msg">Loading</div>
      <div class="online_3d_viewer" id="o3dv_element" style="width: 99.75%; height: 95vh;"
        defaultColor="new OV.RGBAColor( 174, 174, 190, 255 )"
        backgroundColor="new OV.RGBAColor( 5, 5, 25, 255 )"
        model="https://raw.githubusercontent.com/GitHubDragonFly/GitHubDragonFly.github.io/main/viewers/examples/legobrick.dae"
        environmentmap="
        https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posx.jpg,
        https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negx.jpg,
        https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posy.jpg,
        https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negy.jpg,
        https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posz.jpg,
        https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negz.jpg">
      </div>
    </div>

    <script>
      const model_extensions = [ '.3DM', '.3DS', '.3MF', '.BIM', '.BREP', '.BRP', '.DAE', '.FBX', '.FCSTD', '.GLB', '.GLTF', '.IFC', '.IGES', '.IGS', '.MTL', '.OBJ', '.OFF', '.PLY', '.STL', '.STEP', '.STP', '.WRL' ];
      const occt_extensions = [ '.BREP', '.BRP', '.IGES', '.IGS', '.STEP', '.STP' ];
      const image_extensions = [ '.PNG', '.JPEG', '.JPG', '.JFIF', '.PJPEG', '.PJP', '.BMP', '.GIF' ];
      const textureNames = [
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posx.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negx.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posy.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negy.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/posz.jpg',
        'https://cdn.jsdelivr.net/npm/online-3d-viewer@0.8.22/website/assets/envmaps/ice_river/negz.jpg'
      ];
      const backgroundIsEnvMap = false;

      function show_url() {
        if (url_displayed === true) {
          document.getElementById('url').style.display = 'none';
          url_displayed = false;
        } else {
          document.getElementById('url').style.display = 'block';
          url_displayed = true;
        }
      }

      function load_url_file() {
        let url = document.getElementById('url_entry').value.trim();
        if (url !== '') {
          selected_url_file = url;
          url_loading = true;
          init();
        }
      }

      function clear_url() { document.getElementById('url_entry').value = ''; }

      function reset() { document.getElementById('file_input').value = ''; document.getElementById('url_entry').value = ''; }

      function resize() {
        if (window.fullScreen || document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement) {
          document.getElementById('btn_full_screen').style.backgroundColor = '#FFFF00';
        } else {
          document.getElementById('btn_full_screen').style.backgroundColor = 'transparent';
        }
      }

      function full_screen() {
        if (document.fullscreenEnabled) {
          document.fullscreenElement ? document.exitFullscreen() : document.body.requestFullscreen();
        } else if (document.mozFullScreenEnabled) {
          document.mozFullScreenElement ? document.mozCancelFullScreen() : document.body.mozRequestFullScreen();
        } else if (document.msFullscreenEnabled) {
          document.msFullscreenElement ? document.msExitFullscreen() : document.body.msRequestFullscreen();
        } else if (document.webkitFullscreenEnabled) {
          document.webkitFullscreenElement ? document.webkitExitFullscreen() : document.body.webkitRequestFullscreen();
        } else if (window.fullScreen) {
          // Do nothing. This fullscreen mode was triggered with F11 key press and requires the same again.
        }
      }
    </script>

    <script>
      var o3dv_embedded_viewer, mesh, bounding_box, local_files, url_files, selected_model_file;
      var selected_url_model_file, selected_url_file = '', url_displayed = false, url_loading = false;

      function init() {
        if (url_loading === false) {
          selected_model_file = null;
          selected_url_file = '';
          local_files = [];

          // Loaded files
          var fi = document.getElementById('file_input');

          for (let i = 0; i < fi.files.length; i++) {
            if (fi.files[ i ].type !== '' && fi.files[ i ].type.startsWith('image/')) {
              local_files.push( fi.files[ i ] );
            } else if (fi.files[ i ].name.indexOf( '.' ) > -1 && model_extensions.includes( fi.files[ i ].name.toUpperCase().substring( fi.files[ i ].name.lastIndexOf( '.' ) ))) {
              selected_model_file = fi.files[ i ];
              local_files.push( fi.files[ i ] );
            }
          };

          if (selected_model_file === null) {
            console.log( 'No valid model file selected!' );
            return;
          }
        } else {
          selected_url_model_file = null;
          selected_model_file = null;
          url_loading = false;
          url_files = [];

          // Reset the file input
          document.getElementById('file_input').value = '';
        }

        // Load the model
        selected_model_file !== null ? loadFile() : loadURLFile();
      }

      function loadFile() {
        let element = document.getElementById('o3dv_element');
        if (o3dv_embedded_viewer !== undefined) o3dv_embedded_viewer.viewer.Clear();
        element.innerHTML = '';
        o3dv_embedded_viewer = new OV.EmbeddedViewer( element, { defaultColor: new OV.RGBAColor( 174, 174, 190, 255 ), backgroundColor: new OV.RGBAColor( 5, 5, 25, 255 ), environmentSettings: new OV.EnvironmentSettings( textureNames, backgroundIsEnvMap ) } );

        let ext = selected_model_file.name.toUpperCase().substring( selected_model_file.name.lastIndexOf( '.' ) );

        if (occt_extensions.includes( ext ) === true) {
          document.getElementById('div_loading').innerHTML = 'Loading OCCT ... Please wait';
          document.getElementById('div_loading').style.display = 'block';

          bounding_box = new THREE.Box3();
          mesh = new THREE.Object3D();

          occtimportjs().then ( async function( occt ) {
            response = await fetch( URL.createObjectURL( selected_model_file ) );
            URL.revokeObjectURL( selected_model_file );

            buffer = await response.arrayBuffer();
            fileBuffer = new Uint8Array( buffer );

            let result;

            ext.startsWith( '.I' ) === true ? result = await occt.ReadIgesFile( fileBuffer, null ) : ( ext.startsWith( '.B' ) === true ? result = await occt.ReadBrepFile( fileBuffer, null ) : result = await occt.ReadStepFile( fileBuffer, null ));

            if (result.success && result.meshes.length > 0) {
              let mesh_count = 1;

              // Modified version of the original example code at https://github.com/kovacsv/occt-import-js/blob/main/examples/three_viewer.html#L42-L89
              for (let resultMesh of result.meshes) {
                let geometry = new THREE.BufferGeometry();

                geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( resultMesh.attributes.position.array, 3 ) );

                if (resultMesh.attributes.normal) {
                  geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( resultMesh.attributes.normal.array, 3 ) );
                }

                let index = Uint32Array.from( resultMesh.index.array );
                geometry.setIndex( new THREE.BufferAttribute( index, 1 ) );
            
                let defaultMaterial;

                if (resultMesh.color) {
                  let color = new THREE.Color( resultMesh.color[ 0 ], resultMesh.color[ 1 ], resultMesh.color[ 2 ] );
                  defaultMaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } );
                } else {
                  defaultMaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: 0xFFFFFF } );
                }

                let materials = defaultMaterial;

                if (resultMesh.face_colors && resultMesh.face_colors.length > 0) {
                  materials = [ defaultMaterial ];

                  for (let faceColor of resultMesh.face_colors) {
                    let color = new THREE.Color( faceColor.color[ 0 ], faceColor.color[ 1 ], faceColor.color[ 2 ] );
                    materials.push( new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } ) );
                  }

                  let triangleCount = resultMesh.index.array.length / 3;
                  let triangleIndex = 0;
                  let faceColorGroupIndex = 0;

                  while (triangleIndex < triangleCount) {
                    let firstIndex = triangleIndex;
                    let lastIndex = null;
                    let materialIndex = null;

                    if (faceColorGroupIndex >= resultMesh.face_colors.length) {
                      lastIndex = triangleCount;
                      materialIndex = 0;
                    } else if (triangleIndex < resultMesh.face_colors[ faceColorGroupIndex ].first) {
                      lastIndex = resultMesh.face_colors[ faceColorGroupIndex ].first;
                      materialIndex = 0;
                    } else {
                      lastIndex = resultMesh.face_colors[ faceColorGroupIndex ].last + 1;
                      materialIndex = faceColorGroupIndex + 1;
                      faceColorGroupIndex++;
                    }

                    geometry.addGroup( firstIndex * 3, ( lastIndex - firstIndex ) * 3, materialIndex );
                    triangleIndex = lastIndex;
                  }
                }

                if (result.meshes.length === 1) geometry.center();

                let new_mesh = new THREE.Mesh( geometry, materials );

                mesh.add( new_mesh );

                if (Array.isArray( materials )) {
                  materials.forEach( mtl => {
                    mtl.dispose();
                  });

                  new_mesh.material.forEach( mtrl => {
                    mtrl.dispose();
                  });
                } else {
                  materials.dispose();
                  new_mesh.material.dispose();
                }

                geometry.dispose();
                new_mesh.geometry.dispose();
              }

              // Set the initial scale of the object so it comes to view
              bounding_box.setFromObject( mesh );
              let y;

              if (bounding_box.max.y < 0) {
                y = Math.abs( bounding_box.min.y ) - Math.abs( bounding_box.max.y );
              } else if (bounding_box.max.y >= 0 && bounding_box.min.y <= 0) {
                y = Math.abs( bounding_box.max.y ) + Math.abs( bounding_box.min.y );
              } else {
                y = Math.abs( bounding_box.max.y ) - Math.abs( bounding_box.min.y );
              }

              mesh.position.set( 0, 0, 0 );
              mesh.scale.multiplyScalar( 0.75 / y );

              o3dv_embedded_viewer.viewer.scene.add( mesh );
              o3dv_embedded_viewer.viewer.renderer.render( o3dv_embedded_viewer.viewer.scene, o3dv_embedded_viewer.viewer.camera );
            } else {
              console.log( 'No mesh detected!' );
              return;
            }

            document.getElementById('div_loading').innerHTML = '';
            document.getElementById('div_loading').style.display = 'none';
          });
        } else {
          o3dv_embedded_viewer.LoadModelFromFileList( local_files );
        }
      }

      function loadURLFile() {
        if (selected_url_file !== '') {
          if (selected_url_file.indexOf( ',' ) > -1) {
            let urls = selected_url_file.split( ',' );

            for (let i = 0; i < urls.length; i++) {
              let url = urls[ i ].trim();

              if (url.indexOf( '.' ) > -1 && image_extensions.includes( url.toUpperCase().substring( url.lastIndexOf( '.' ) ))) {
                url_files.push( url );
              } else if (url.indexOf( '.' ) > -1 && model_extensions.includes( url.toUpperCase().substring( url.lastIndexOf( '.' ) ))) {
                url_files.push( url );
                selected_url_model_file = url;
              }
            }

            if (selected_url_model_file === null) {
              console.log( 'No valid URL model file selected!' );
              return;
            }
          } else {
            if (selected_url_file.indexOf( '.' ) > -1 && model_extensions.includes( selected_url_file.toUpperCase().substring( selected_url_file.lastIndexOf( '.' ) ))) {
              url_files.push( selected_url_file );
            } else {
              console.log( 'No valid URL model file selected!' );
            }
          }

          if (url_files.length > 0) {
            let element = document.getElementById('o3dv_element');
            if (o3dv_embedded_viewer !== undefined) o3dv_embedded_viewer.viewer.Clear();
            element.innerHTML = '';
            o3dv_embedded_viewer = new OV.EmbeddedViewer( element, { defaultColor: new OV.RGBAColor( 174, 174, 190, 255 ), backgroundColor: new OV.RGBAColor( 5, 5, 25, 255 ), environmentSettings: new OV.EnvironmentSettings( textureNames, backgroundIsEnvMap ) } );

            let ext;

            if (selected_url_model_file === null) {
              ext = selected_url_file.toUpperCase().substring( selected_url_file.lastIndexOf( '.' ) );
            } else {
              ext = selected_url_model_file.toUpperCase().substring( selected_url_model_file.lastIndexOf( '.' ) );
            }

            if (occt_extensions.includes( ext ) === true) {
              document.getElementById('div_loading').innerHTML = 'Loading OCCT ... Please wait';
              document.getElementById('div_loading').style.display = 'block';

              bounding_box = new THREE.Box3();
              mesh = new THREE.Object3D();

              occtimportjs().then ( async function( occt ) {
                response = (selected_url_model_file === null) ? await fetch( selected_url_file ) : await fetch( selected_url_model_file );

                buffer = await response.arrayBuffer();
                fileBuffer = new Uint8Array( buffer );

                let result;

                ext.startsWith( '.I' ) === true ? result = await occt.ReadIgesFile( fileBuffer, null ) : ( ext.startsWith( '.B' ) === true ? result = await occt.ReadBrepFile( fileBuffer, null ) : result = await occt.ReadStepFile( fileBuffer, null ));

                if (result.success && result.meshes.length > 0) {
                  let mesh_count = 1;

                  // Modified version of the original example code at https://github.com/kovacsv/occt-import-js/blob/main/examples/three_viewer.html#L42-L89
                  for (let resultMesh of result.meshes) {
                    let geometry = new THREE.BufferGeometry();

                    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( resultMesh.attributes.position.array, 3 ) );

                    if (resultMesh.attributes.normal) {
                      geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( resultMesh.attributes.normal.array, 3 ) );
                    }

                    let index = Uint32Array.from( resultMesh.index.array );
                    geometry.setIndex( new THREE.BufferAttribute( index, 1 ) );
    
                    let defaultMaterial;

                    if (resultMesh.color) {
                      let color = new THREE.Color( resultMesh.color[ 0 ], resultMesh.color[ 1 ], resultMesh.color[ 2 ] );
                      defaultMaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } );
                    } else {
                      defaultMaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: 0xFFFFFF } );
                    }

                    let materials = defaultMaterial;

                    if (resultMesh.face_colors && resultMesh.face_colors.length > 0) {
                      materials = [ defaultMaterial ];

                      for (let faceColor of resultMesh.face_colors) {
                        let color = new THREE.Color( faceColor.color[ 0 ], faceColor.color[ 1 ], faceColor.color[ 2 ] );
                        materials.push( new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, shininess: 50, opacity: 1, flatShading: false, color: color } ) );
                      }

                      let triangleCount = resultMesh.index.array.length / 3;
                      let triangleIndex = 0;
                      let faceColorGroupIndex = 0;

                      while (triangleIndex < triangleCount) {
                        let firstIndex = triangleIndex;
                        let lastIndex = null;
                        let materialIndex = null;

                        if (faceColorGroupIndex >= resultMesh.face_colors.length) {
                          lastIndex = triangleCount;
                          materialIndex = 0;
                        } else if (triangleIndex < resultMesh.face_colors[ faceColorGroupIndex ].first) {
                          lastIndex = resultMesh.face_colors[ faceColorGroupIndex ].first;
                          materialIndex = 0;
                        } else {
                          lastIndex = resultMesh.face_colors[ faceColorGroupIndex ].last + 1;
                          materialIndex = faceColorGroupIndex + 1;
                          faceColorGroupIndex++;
                        }

                        geometry.addGroup( firstIndex * 3, ( lastIndex - firstIndex ) * 3, materialIndex );
                        triangleIndex = lastIndex;
                      }
                    }

                    if (result.meshes.length === 1) geometry.center();

                    let new_mesh = new THREE.Mesh( geometry, materials );

                    mesh.add( new_mesh );

                    if (Array.isArray( materials )) {
                      materials.forEach( mtl => {
                        mtl.dispose();
                      });

                      new_mesh.material.forEach( mtrl => {
                        mtrl.dispose();
                      });
                    } else {
                      materials.dispose();
                      new_mesh.material.dispose();
                    }

                    geometry.dispose();
                    new_mesh.geometry.dispose();
                  }

                  // Set the initial scale of the object so it comes to view
                  bounding_box.setFromObject( mesh );
                  let y;

                  if (bounding_box.max.y < 0) {
                    y = Math.abs( bounding_box.min.y ) - Math.abs( bounding_box.max.y );
                  } else if (bounding_box.max.y >= 0 && bounding_box.min.y <= 0) {
                    y = Math.abs( bounding_box.max.y ) + Math.abs( bounding_box.min.y );
                  } else {
                    y = Math.abs( bounding_box.max.y ) - Math.abs( bounding_box.min.y );
                  }

                  mesh.position.set( 0, 0, 0 );
                  mesh.scale.multiplyScalar( 0.75 / y );

                  o3dv_embedded_viewer.viewer.scene.add( mesh );
                  o3dv_embedded_viewer.viewer.renderer.render( o3dv_embedded_viewer.viewer.scene, o3dv_embedded_viewer.viewer.camera );
                } else {
                  console.log( 'No mesh detected!' );
                }

                document.getElementById('div_loading').innerHTML = '';
                document.getElementById('div_loading').style.display = 'none';
              });
            } else {
              o3dv_embedded_viewer.LoadModelFromUrlList( url_files );
            }
          }
        }
      }
    </script>
  </body>
</html>
