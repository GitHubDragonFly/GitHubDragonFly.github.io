const ensureUniqueNames=a=>{const t=[],e=new Set;for(const r of a){let a=r,i=0;for(;e.has(a);)a=r+"."+ ++i;e.add(a),t.push(a)}return t},mappingsArrayToTable=(a,t)=>{const e={};for(const r of a.mappings)for(const a of r.variants)e[t[a]]={material:null,gltfMaterialIndex:r.material};return e},compatibleObject=a=>void 0!==a.material&&a.userData&&a.userData.variantMaterials,traversePair=(a,t,e)=>{e(a,t);for(let r=0;r<a.children.length;r++)traversePair(a.children[r],t.children[r],e)},copyVariantMaterials=(a,t)=>{void 0!==t.userData.variantMaterials&&(a.userData.variantMaterials=Object.assign({},t.userData.variantMaterials)),void 0!==t.userData.originalMaterial&&(a.userData.originalMaterial=t.userData.originalMaterial)};export default class GLTFMaterialsVariantsExtension{constructor(a){this.parser=a,this.name="KHR_materials_variants"}afterRoot(a){const t=this.parser,e=t.json;if(!e.extensions||!e.extensions[this.name])return null;const r=e.extensions[this.name].variants||[],i=ensureUniqueNames(r.map((a=>a.name)));for(const r of a.scenes)r.traverse((a=>{const r=t.associations.get(a);if(!r||"nodes"!==r.type)return;const s=e.nodes[r.index].mesh;if(void 0===s)return;const n=e.meshes[s].primitives,l=a.isMesh?[a]:a.children;for(let a=0;a<n.length;a++){const t=n[a].extensions;t&&t[this.name]&&(l[a].userData.variantMaterials=mappingsArrayToTable(t[this.name],i))}}));a.userData.variants=i,a.functions=a.functions||{};const s=async(a,e,r)=>{a.userData.originalMaterial||(a.userData.originalMaterial=a.material);const i=a.material;let s=null;if(null!==e&&a.userData.variantMaterials[e]){const r=a.userData.variantMaterials[e];r.material?(a.material=r.material,void 0!==r.gltfMaterialIndex&&(s=r.gltfMaterialIndex)):(s=r.gltfMaterialIndex,a.material=await t.getDependency("material",s),t.assignFinalMaterial(a),r.material=a.material)}else a.material=a.userData.originalMaterial,t.associations.has(a.material)&&(s=t.associations.get(a.material).index);null!==r&&r(a,i,s)},n=a=>{const e=a.material,r=a.userData.variantMaterials,i=[];for(const e in r){const s=r[e];if(s.material)continue;const n=s.gltfMaterialIndex;i.push(t.getDependency("material",n).then((i=>{a.material=i,t.assignFinalMaterial(a),r[e].material=a.material})))}return Promise.all(i).then((()=>{a.material=e}))};a.functions.selectVariant=(a,t,e=!0,r=null)=>{const i=[];return e?a.traverse((a=>compatibleObject(a)&&i.push(s(a,t,r)))):compatibleObject(a)&&i.push(s(a,t,r)),Promise.all(i)},a.functions.ensureLoadVariants=(a,t=!0)=>{const e=[];return t?a.traverse((a=>compatibleObject(a)&&e.push(n(a)))):compatibleObject(a)&&e.push(n(a)),Promise.all(e)},a.functions.copyVariantMaterials=(a,t,e=!0)=>{e?traversePair(a,t,((a,t)=>copyVariantMaterials(a,t))):copyVariantMaterials(a,t)}}}