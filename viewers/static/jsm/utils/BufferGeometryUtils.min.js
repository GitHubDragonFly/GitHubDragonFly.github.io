import{BufferAttribute,BufferGeometry,Float32BufferAttribute,InstancedBufferAttribute,InterleavedBuffer,InterleavedBufferAttribute,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,Vector3}from"three";function computeMikkTSpaceTangents(t,e,r=!0){if(!e||!e.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function n(t){if(t.normalized||t.isInterleavedBufferAttribute){const e=new Float32Array(t.count*t.itemSize);for(let r=0,n=0;r<t.count;r++)e[n++]=t.getX(r),e[n++]=t.getY(r),t.itemSize>2&&(e[n++]=t.getZ(r));return e}return t.array instanceof Float32Array?t.array:new Float32Array(t.array)}const o=t.index?t.toNonIndexed():t,i=e.generateTangents(n(o.attributes.position),n(o.attributes.normal),n(o.attributes.uv));if(r)for(let t=3;t<i.length;t+=4)i[t]*=-1;return o.setAttribute("tangent",new BufferAttribute(i,4)),t!==o&&t.copy(o),t}function mergeGeometries(t,e=!1){const r=null!==t[0].index,n=new Set(Object.keys(t[0].attributes)),o=new Set(Object.keys(t[0].morphAttributes)),i={},u={},s=t[0].morphTargetsRelative,a=new BufferGeometry;let f=0;for(let l=0;l<t.length;++l){const c=t[l];let m=0;if(r!==(null!==c.index))return null;for(const t in c.attributes){if(!n.has(t))return null;void 0===i[t]&&(i[t]=[]),i[t].push(c.attributes[t]),m++}if(m!==n.size)return null;if(s!==c.morphTargetsRelative)return null;for(const t in c.morphAttributes){if(!o.has(t))return null;void 0===u[t]&&(u[t]=[]),u[t].push(c.morphAttributes[t])}if(e){let t;if(r)t=c.index.count;else{if(void 0===c.attributes.position)return null;t=c.attributes.position.count}a.addGroup(f,t,l),f+=t}}if(r){let e=0;const r=[];for(let n=0;n<t.length;++n){const o=t[n].index;for(let t=0;t<o.count;++t)r.push(o.getX(t)+e);e+=t[n].attributes.position.count}a.setIndex(r)}for(const t in i){const e=mergeAttributes(i[t]);if(!e)return null;a.setAttribute(t,e)}for(const t in u){const e=u[t][0].length;if(0===e)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let n=0;n<u[t].length;++n)e.push(u[t][n][r]);const n=mergeAttributes(e);if(!n)return null;a.morphAttributes[t].push(n)}}return a}function mergeAttributes(t){let e,r,n,o=-1,i=0;for(let u=0;u<t.length;++u){const s=t[u];if(s.isInterleavedBufferAttribute)return null;if(void 0===e&&(e=s.array.constructor),e!==s.array.constructor)return null;if(void 0===r&&(r=s.itemSize),r!==s.itemSize)return null;if(void 0===n&&(n=s.normalized),n!==s.normalized)return null;if(-1===o&&(o=s.gpuType),o!==s.gpuType)return null;i+=s.array.length}const u=new e(i);let s=0;for(let e=0;e<t.length;++e)u.set(t[e].array,s),s+=t[e].array.length;const a=new BufferAttribute(u,r,n);return void 0!==o&&(a.gpuType=o),a}export function deepCloneAttribute(t){return t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute?deinterleaveAttribute(t):t.isInstancedBufferAttribute?(new InstancedBufferAttribute).copy(t):(new BufferAttribute).copy(t)}function interleaveAttributes(t){let e,r=0,n=0;for(let o=0,i=t.length;o<i;++o){const i=t[o];if(void 0===e&&(e=i.array.constructor),e!==i.array.constructor)return null;r+=i.array.length,n+=i.itemSize}const o=new InterleavedBuffer(new e(r),n);let i=0;const u=[],s=["getX","getY","getZ","getW"],a=["setX","setY","setZ","setW"];for(let e=0,r=t.length;e<r;e++){const r=t[e],n=r.itemSize,f=r.count,l=new InterleavedBufferAttribute(o,n,i,r.normalized);u.push(l),i+=n;for(let t=0;t<f;t++)for(let e=0;e<n;e++)l[a[e]](t,r[s[e]](t))}return u}export function deinterleaveAttribute(t){const e=t.data.array.constructor,r=t.count,n=t.itemSize,o=t.normalized,i=new e(r*n);let u;u=t.isInstancedInterleavedBufferAttribute?new InstancedBufferAttribute(i,n,o,t.meshPerAttribute):new BufferAttribute(i,n,o);for(let e=0;e<r;e++)u.setX(e,t.getX(e)),n>=2&&u.setY(e,t.getY(e)),n>=3&&u.setZ(e,t.getZ(e)),n>=4&&u.setW(e,t.getW(e));return u}export function deinterleaveGeometry(t){const e=t.attributes,r=t.morphTargets,n=new Map;for(const t in e){const r=e[t];r.isInterleavedBufferAttribute&&(n.has(r)||n.set(r,deinterleaveAttribute(r)),e[t]=n.get(r))}for(const t in r){const e=r[t];e.isInterleavedBufferAttribute&&(n.has(e)||n.set(e,deinterleaveAttribute(e)),r[t]=n.get(e))}}function estimateBytesUsed(t){let e=0;for(const r in t.attributes){const n=t.getAttribute(r);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}const r=t.getIndex();return e+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,e}function mergeVertices(t,e=1e-4){e=Math.max(e,Number.EPSILON);const r={},n=t.getIndex(),o=t.getAttribute("position"),i=n?n.count:o.count;let u=0;const s=Object.keys(t.attributes),a={},f={},l=[],c=["getX","getY","getZ","getW"],m=["setX","setY","setZ","setW"];for(let e=0,r=s.length;e<r;e++){const r=s[e],n=t.attributes[r];a[r]=new BufferAttribute(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized);const o=t.morphAttributes[r];if(o)if(Array.isArray(o)){f[r]={};for(let t=0;t<o.length;t++)f[r][t]=o[t].clone()}else f[r]=new BufferAttribute(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized)}const d=.5*e,g=Math.log10(1/e),b=Math.pow(10,g),p=d*b;for(let e=0;e<i;e++){const o=n?n.getX(e):e;let i="";for(let e=0,r=s.length;e<r;e++){const r=s[e],n=t.getAttribute(r),u=n.itemSize;for(let t=0;t<u;t++)i+=~~(n[c[t]](o)*b+p)+","}if(i in r)l.push(r[i]);else{for(let e=0,r=s.length;e<r;e++){const r=s[e],n=t.getAttribute(r),i=t.morphAttributes[r],l=n.itemSize,d=a[r],g=f[r];for(let t=0;t<l;t++){const e=c[t],r=m[t];if(d[r](u,n[e](o)),i)for(let t=0,n=i.length;t<n;t++)g[t][r](u,i[t][e](o))}}r[i]=u,l.push(u),u++}}const A=t.clone();for(const e in t.attributes){const t=a[e];if(A.setAttribute(e,new BufferAttribute(t.array.slice(0,u*t.itemSize),t.itemSize,t.normalized)),e in f)for(let t=0;t<f[e].length;t++){const r=f[e][t];A.morphAttributes[e][t]=new BufferAttribute(r.array.slice(0,u*r.itemSize),r.itemSize,r.normalized)}}return A.setIndex(l),A}function toTrianglesDrawMode(t,e){if(e===TrianglesDrawMode)return t;if(e===TriangleFanDrawMode||e===TriangleStripDrawMode){let r=t.getIndex();if(null===r){const e=[],n=t.getAttribute("position");if(void 0===n)return t;for(let t=0;t<n.count;t++)e.push(t);t.setIndex(e),r=t.getIndex()}const n=r.count-2,o=[];if(e===TriangleFanDrawMode)for(let t=1;t<=n;t++)o.push(r.getX(0)),o.push(r.getX(t)),o.push(r.getX(t+1));else for(let t=0;t<n;t++)t%2==0?(o.push(r.getX(t)),o.push(r.getX(t+1)),o.push(r.getX(t+2))):(o.push(r.getX(t+2)),o.push(r.getX(t+1)),o.push(r.getX(t)));o.length;const i=t.clone();return i.setIndex(o),i.clearGroups(),i}return t}function computeMorphedAttributes(t){const e=new Vector3,r=new Vector3,n=new Vector3,o=new Vector3,i=new Vector3,u=new Vector3,s=new Vector3,a=new Vector3,f=new Vector3;function l(t,l,c,m,d,g,b,p){e.fromBufferAttribute(l,d),r.fromBufferAttribute(l,g),n.fromBufferAttribute(l,b);const A=t.morphTargetInfluences;if(c&&A){s.set(0,0,0),a.set(0,0,0),f.set(0,0,0);for(let t=0,l=c.length;t<l;t++){const l=A[t],p=c[t];0!==l&&(o.fromBufferAttribute(p,d),i.fromBufferAttribute(p,g),u.fromBufferAttribute(p,b),m?(s.addScaledVector(o,l),a.addScaledVector(i,l),f.addScaledVector(u,l)):(s.addScaledVector(o.sub(e),l),a.addScaledVector(i.sub(r),l),f.addScaledVector(u.sub(n),l)))}e.add(s),r.add(a),n.add(f)}t.isSkinnedMesh&&(t.applyBoneTransform(d,e),t.applyBoneTransform(g,r),t.applyBoneTransform(b,n)),p[3*d+0]=e.x,p[3*d+1]=e.y,p[3*d+2]=e.z,p[3*g+0]=r.x,p[3*g+1]=r.y,p[3*g+2]=r.z,p[3*b+0]=n.x,p[3*b+1]=n.y,p[3*b+2]=n.z}const c=t.geometry,m=t.material;let d,g,b;const p=c.index,A=c.attributes.position,h=c.morphAttributes.position,w=c.morphTargetsRelative,y=c.attributes.normal,B=c.morphAttributes.position,x=c.groups,I=c.drawRange;let z,S,v,V,M,T,X;const G=new Float32Array(A.count*A.itemSize),E=new Float32Array(y.count*y.itemSize);if(null!==p)if(Array.isArray(m))for(z=0,v=x.length;z<v;z++)for(M=x[z],T=Math.max(M.start,I.start),X=Math.min(M.start+M.count,I.start+I.count),S=T,V=X;S<V;S+=3)d=p.getX(S),g=p.getX(S+1),b=p.getX(S+2),l(t,A,h,w,d,g,b,G),l(t,y,B,w,d,g,b,E);else for(T=Math.max(0,I.start),X=Math.min(p.count,I.start+I.count),z=T,v=X;z<v;z+=3)d=p.getX(z),g=p.getX(z+1),b=p.getX(z+2),l(t,A,h,w,d,g,b,G),l(t,y,B,w,d,g,b,E);else if(Array.isArray(m))for(z=0,v=x.length;z<v;z++)for(M=x[z],T=Math.max(M.start,I.start),X=Math.min(M.start+M.count,I.start+I.count),S=T,V=X;S<V;S+=3)d=S,g=S+1,b=S+2,l(t,A,h,w,d,g,b,G),l(t,y,B,w,d,g,b,E);else for(T=Math.max(0,I.start),X=Math.min(A.count,I.start+I.count),z=T,v=X;z<v;z+=3)d=z,g=z+1,b=z+2,l(t,A,h,w,d,g,b,G),l(t,y,B,w,d,g,b,E);return{positionAttribute:A,normalAttribute:y,morphedPositionAttribute:new Float32BufferAttribute(G,3),morphedNormalAttribute:new Float32BufferAttribute(E,3)}}function mergeGroups(t){if(0===t.groups.length)return t;let e=t.groups;if(e=e.sort(((t,e)=>t.materialIndex!==e.materialIndex?t.materialIndex-e.materialIndex:t.start-e.start)),null===t.getIndex()){const e=t.getAttribute("position"),r=[];for(let t=0;t<e.count;t+=3)r.push(t,t+1,t+2);t.setIndex(r)}const r=t.getIndex(),n=[];for(let t=0;t<e.length;t++){const o=e[t],i=o.start,u=i+o.count;for(let t=i;t<u;t++)n.push(r.getX(t))}t.dispose(),t.setIndex(n);let o=0;for(let t=0;t<e.length;t++){const r=e[t];r.start=o,o+=r.count}let i=e[0];t.groups=[i];for(let r=1;r<e.length;r++){const n=e[r];i.materialIndex===n.materialIndex?i.count+=n.count:(i=n,t.groups.push(i))}return t}function toCreasedNormals(t,e=Math.PI/3){const r=Math.cos(e),n=100*(1+1e-10),o=[new Vector3,new Vector3,new Vector3],i=new Vector3,u=new Vector3,s=new Vector3,a=new Vector3;function f(t){return`${~~(t.x*n)},${~~(t.y*n)},${~~(t.z*n)}`}const l=t.index?t.toNonIndexed():t,c=l.attributes.position,m={};for(let t=0,e=c.count/3;t<e;t++){const e=3*t,r=o[0].fromBufferAttribute(c,e+0),n=o[1].fromBufferAttribute(c,e+1),s=o[2].fromBufferAttribute(c,e+2);i.subVectors(s,n),u.subVectors(r,n);const a=(new Vector3).crossVectors(i,u).normalize();for(let t=0;t<3;t++){const e=f(o[t]);e in m||(m[e]=[]),m[e].push(a)}}const d=new Float32Array(3*c.count),g=new BufferAttribute(d,3,!1);for(let t=0,e=c.count/3;t<e;t++){const e=3*t,n=o[0].fromBufferAttribute(c,e+0),l=o[1].fromBufferAttribute(c,e+1),d=o[2].fromBufferAttribute(c,e+2);i.subVectors(d,l),u.subVectors(n,l),s.crossVectors(i,u).normalize();for(let t=0;t<3;t++){const n=m[f(o[t])];a.set(0,0,0);for(let t=0,e=n.length;t<e;t++){const e=n[t];s.dot(e)>r&&a.add(e)}a.normalize(),g.setXYZ(e+t,a.x,a.y,a.z)}}return l.setAttribute("normal",g),l}function mergeBufferGeometries(t,e=!1){return mergeGeometries(t,e)}function mergeBufferAttributes(t){return mergeAttributes(t)}export{computeMikkTSpaceTangents,mergeGeometries,mergeBufferGeometries,mergeAttributes,mergeBufferAttributes,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups,toCreasedNormals};