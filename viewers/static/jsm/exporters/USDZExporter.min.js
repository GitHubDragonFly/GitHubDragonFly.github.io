import{DoubleSide,LinearSRGBColorSpace,MeshStandardMaterial,NoColorSpace}from"three";import{strToU8,zipSync}from"https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/libs/fflate.module.min.js";import{decompress}from"https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/utils/TextureUtils.min.js";class USDZExporter{parse(t,e,n,a){this.parseAsync(t,a).then(e).catch(n)}async parseAsync(t,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},quickLookCompatible:!1,map_flip_required:!1,maxTextureSize:1024},e);const n={};n["model.usda"]=null;let a=buildHeader();a+=buildSceneStart(e);const r={},o={};t.traverseVisible((t=>{if(t.isMesh){const e=t.geometry;let o=t.material;if(!0===Array.isArray(t.material)){if(t.material.length,o=t.material[0],1===o.color.r&&1===o.color.g&&1===o.color.b&&t.material.length>1)for(let e=1;e<t.material.length;e++)if(o.color.r!==t.material[e].color.r||o.color.g!==t.material[e].color.g||o.color.b!==t.material[e].color.b){o=t.material[e];break}if(!o.isMeshStandardMaterial){let e=o.map?o.map.clone():null,n=o.color;o=new MeshStandardMaterial({metalness:.05,roughness:.6,flatShading:!1,opacity:t.material.opacity||1,transparent:t.material.transparent||!1}),n&&o.color.setRGB(n.r,n.g,n.b,LinearSRGBColorSpace),e&&(o.map=e)}const i="geometries/Geometry_"+e.id+".usda";if(!(i in n)){const t=buildMeshObject(e);n[i]=buildUSDFileAsString(t)}o.uuid in r||(r[o.uuid]=o),a+="\t\t\t"+buildXform(t,e,o)}else{if(t.material.isMeshStandardMaterial)o=t.material;else{let e=t.material.map?t.material.map.clone():null;if(e?(e.isCompressedTexture&&(e=decompress(e)),o=new MeshStandardMaterial({map:e,metalness:.05,roughness:.6,flatShading:!1,opacity:t.material.opacity||1,transparent:t.material.transparent||!1})):o=new MeshStandardMaterial({metalness:.05,roughness:.6,flatShading:!1,opacity:t.material.opacity||1,transparent:t.material.transparent||!1}),t.material.color){const e=t.material.color;o.color.setRGB(e.r,e.g,e.b,LinearSRGBColorSpace)}}const i="geometries/Geometry_"+e.id+".usda";if(!(i in n)){const t=buildMeshObject(e);n[i]=buildUSDFileAsString(t)}o.uuid in r||(r[o.uuid]=o),a+="\t\t\t"+buildXform(t,e,o)}}else t.isCamera&&(a+=buildCamera(t))})),a+=buildSceneEnd(),a+=buildMaterials(r,o,e.quickLookCompatible),n["model.usda"]=strToU8(a),a=null;for(const t in o){let a=o[t];!0===a.isCompressedTexture&&(a=decompress(a));const r=imageToCanvas(a.image,e.map_flip_required,e.maxTextureSize),i=await new Promise((t=>r.toBlob(t,"image/png",1)));n[`textures/Texture_${t}.png`]=new Uint8Array(await i.arrayBuffer())}let i=0;for(const t in n){const e=n[t];i+=34+t.length;const a=63&i;if(4!==a){const r=new Uint8Array(64-a);n[t]=[e,{extra:{12345:r}}]}i=e.length}return zipSync(n,{level:0})}}function imageToCanvas(t,e,n){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const a=n/Math.max(t.width,t.height),r=document.createElement("canvas");r.width=t.width*Math.min(1,a),r.height=t.height*Math.min(1,a);const o=r.getContext("2d");return!0===e&&(o.translate(0,r.height),o.scale(1,-1)),o.drawImage(t,0,0,r.width,r.height),r}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const PRECISION=7;function buildHeader(){return'#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n'}function buildSceneStart(t){return`def Xform "Root"\n{\n\tdef Scope "Scenes" (\n\t\tkind = "sceneLibrary"\n\t)\n\t{\n\t\tdef Xform "Scene" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = "Scene"\n\t\t\t}\n\t\t\tsceneName = "Scene"\n\t\t)\n\t\t{\n\t\t\ttoken preliminary:anchoring:type = "${t.ar.anchoring.type}"\n\t\t\ttoken preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\n`}function buildSceneEnd(){return"\n\t\t}\n\t}\n}\n\n"}function buildUSDFileAsString(t){let e=buildHeader();return e+=t,strToU8(e)}function buildXform(t,e,n){const a="Object_"+t.id,r=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant(),`def Xform "${a}" (\n\t\t\t\tprepend references = @./geometries/Geometry_${e.id}.usda@</Geometry>\n\t\t\t\tprepend apiSchemas = ["MaterialBindingAPI"]\n\t\t\t)\n\t\t\t{\n\t\t\t\tmatrix4d xformOp:transform = ${r}\n\t\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\t\trel material:binding = </Materials/Material_${n.id}>\n\t\t\t}\n`}function buildMatrix(t){const e=t.elements;return`( ${buildMatrixRow(e,0)}, ${buildMatrixRow(e,4)}, ${buildMatrixRow(e,8)}, ${buildMatrixRow(e,12)} )`}function buildMatrixRow(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function buildMeshObject(t){return`\ndef "Geometry"\n{\n${buildMesh(t)}\n}\n`}function buildMesh(t){const e=t.attributes,n=e.position.count;return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${buildMeshVertexCount(t)}]\n\t\tint[] faceVertexIndices = [${buildMeshVertexIndices(t)}]\n\t\tnormal3f[] normals = [${buildVector3Array(e.normal,n)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${buildVector3Array(e.position,n)}]\n${buildPrimvars(e)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function buildMeshVertexCount(t){const e=null!==t.index?t.index.count:t.attributes.position.count;return Array(e/3).fill(3).join(", ")}function buildMeshVertexIndices(t){const e=t.index,n=[];if(null!==e)for(let t=0;t<e.count;t++)n.push(e.getX(t));else{const e=t.attributes.position.count;for(let t=0;t<e;t++)n.push(t)}return n.join(", ")}function buildVector3Array(t,e){if(void 0===t)return Array(e).fill("(0, 0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const a=t.getX(e),r=t.getY(e),o=t.getZ(e);n.push(`(${a.toPrecision(7)}, ${r.toPrecision(7)}, ${o.toPrecision(7)})`)}return n.join(", ")}function buildVector2Array(t){const e=[];for(let n=0;n<t.count;n++){const a=t.getX(n)||0,r=t.getY(n)||0;e.push(`(${a.toPrecision(7)}, ${1-r.toPrecision(7)})`)}return e.join(", ")}function buildPrimvars(t){let e="";for(let n=0;n<4;n++){const a=n>0?n:"",r=t["uv"+a];void 0!==r&&(e+=`\n\t\ttexCoord2f[] primvars:st${a} = [${buildVector2Array(r)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const n=t.color;if(void 0!==n){e+=`\n\t\tcolor3f[] primvars:displayColor = [${buildVector3Array(n,n.count)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`}return e}function buildMaterials(t,e,n=!1){const a=[];for(const r in t){const o=t[r];a.push(buildMaterial(o,e,n))}return`def "Materials"\n{\n${a.join("")}\n}\n\n`}function buildMaterial(t,e,n=!1){const a=[],r=[];function o(a,r,o){const i=a.source.id+"_"+a.flipY;e[i]=a;const s=a.channel>0?"st"+a.channel:"st",l={1e3:"repeat",1001:"clamp",1002:"mirror"},u=a.repeat.clone(),c=a.offset.clone(),p=a.rotation,d=Math.sin(p),f=Math.cos(p);return c.y=1-c.y-u.y,n?(c.x=c.x/u.x,c.y=c.y/u.y,c.x+=d/u.x,c.y+=f-1):(c.x+=d*u.x,c.y+=(1-f)*u.y),`\n\t\tdef Shader "PrimvarReader_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdPrimvarReader_float2"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = "${s}"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Transform2d_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdTransform2d"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${r}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(p*(180/Math.PI)).toFixed(7)}\n\t\t\tfloat2 inputs:scale = ${buildVector2(u)}\n\t\t\tfloat2 inputs:translation = ${buildVector2(c)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Texture_${a.id}_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdUVTexture"\n\t\t\tasset inputs:file = @textures/Texture_${i}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${r}.outputs:result>\n\t\t\t${void 0!==o?"float4 inputs:scale = "+buildColor4(o):""}\n\t\t\ttoken inputs:sourceColorSpace = "${a.colorSpace===NoColorSpace?"raw":"sRGB"}"\n\t\t\ttoken inputs:wrapS = "${l[a.wrapS]}"\n\t\t\ttoken inputs:wrapT = "${l[a.wrapT]}"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${t.transparent||t.alphaTest>0?"float outputs:a":""}\n\t\t}`}return t.side,t.map?(a.push(`\t\t\tcolor3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),r.push(o(t.map,"diffuse",t.color))):a.push(`\t\t\tcolor3f inputs:diffuseColor = ${buildColor(t.color)}`),t.emissiveMap?(a.push(`\t\t\tcolor3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),r.push(o(t.emissiveMap,"emissive"))):t.emissive.getHex()>0&&a.push(`\t\t\tcolor3f inputs:emissiveColor = ${buildColor(t.emissive)}`),t.normalMap&&(a.push(`\t\t\tnormal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),r.push(o(t.normalMap,"normal"))),t.aoMap&&(a.push(`\t\t\tfloat inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),r.push(o(t.aoMap,"occlusion"))),t.roughnessMap&&1===t.roughness?(a.push(`\t\t\tfloat inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),r.push(o(t.roughnessMap,"roughness"))):a.push(`\t\t\tfloat inputs:roughness = ${t.roughness}`),t.metalnessMap&&1===t.metalness?(a.push(`\t\t\tfloat inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),r.push(o(t.metalnessMap,"metallic"))):a.push(`\t\t\tfloat inputs:metallic = ${t.metalness}`),t.alphaMap?(a.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),a.push("\t\t\tfloat inputs:opacityThreshold = 0.0056"),r.push(o(t.alphaMap,"opacity"))):void 0!==t.opacity&&(void 0!==t.transmission&&t.transmission>0?(void 0!==t.thickness&&t.thickness>0?(a.push("\t\t\tfloat inputs:opacity = 0.25"),a.push("\t\t\tfloat inputs:opacityThreshold = 0.0059")):(a.push("\t\t\tfloat inputs:opacity = 0.95"),a.push("\t\t\tfloat inputs:opacityThreshold = 0.0058")),t.transmissionMap&&(a.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.transmissionMap.id}_opacity.outputs:r>`),r.push(o(t.transmissionMap,"opacity")))):!0===t.transparent||t.opacity<1?(a.push(`\t\t\tfloat inputs:opacity = ${t.opacity}`),a.push("\t\t\tfloat inputs:opacityThreshold = 0.0057"),t.map&&(a.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),r.push(o(t.map,"opacity")))):t.alphaTest||t.alphaTest>0?(a.push(`\t\t\tfloat inputs:opacity = ${t.opacity}`),a.push(`\t\t\tfloat inputs:opacityThreshold = ${t.alphaTest}`),t.map&&(a.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),r.push(o(t.map,"opacity")))):a.push(`\t\t\tfloat inputs:opacity = ${t.opacity}`)),t.isMeshPhysicalMaterial&&(t.specularColor&&a.push(`\t\t\tcolor3f inputs:specularColor = ${buildColor(t.specularColor)}`),t.clearcoat&&a.push(`\t\t\tfloat inputs:clearcoat = ${t.clearcoat}`),t.clearcoatRoughness&&a.push(`\t\t\tfloat inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),t.ior&&a.push(`\t\t\tfloat inputs:ior = ${t.ior}`),t.specularColorMap&&(a.push(`\t\t\tcolor3f inputs:specularColor.connect = </Materials/Material_${t.id}/Texture_${t.specularColorMap.id}_specularColor.outputs:rgb>`),r.push(o(t.specularColorMap,"specularColor"))),t.clearcoatMap&&(a.push(`\t\t\tfloat inputs:clearcoat.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatMap.id}_clearcoat.outputs:r>`),r.push(o(t.clearcoatMap,"clearcoat"))),t.clearcoatRoughnessMap&&(a.push(`\t\t\tfloat inputs:clearcoatRoughness.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`),r.push(o(t.clearcoatRoughnessMap,"clearcoatRoughness")))),`\n\tdef Material "Material_${t.id}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${a.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n${r.join("\n")}\n\t}\n`}function buildColor(t){return`(${t.r}, ${t.g}, ${t.b})`}function buildColor4(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}function buildVector2(t){return`(${t.x}, ${t.y})`}function buildCamera(t){const e=t.name?t.name:"Camera_"+t.id,n=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant(),t.isOrthographicCamera?`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(7)}, ${t.far.toPrecision(7)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(7)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(7)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`:`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(7)}, ${t.far.toPrecision(7)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(7)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(7)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(7)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(7)}\n\t\t}\n\t\n\t`}export{USDZExporter};