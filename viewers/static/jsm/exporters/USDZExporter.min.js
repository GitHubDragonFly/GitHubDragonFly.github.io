import{DefaultLoadingManager,DoubleSide,LinearSRGBColorSpace,MeshStandardMaterial,NoColorSpace,REVISION}from"three";import{strToU8,zipSync}from"three/addons/libs/fflate.module.min.js";async function import_decompress(){try{const{WebGLRenderer:t}=await import("three"),{decompress:e}=await import(parseFloat(REVISION)>169?"three/addons/utils/WebGLTextureUtils.min.js":"three/addons/utils/TextureUtils.min.js");return{decompress:e,renderer:new t({antialias:!0})}}catch(t){}try{const{CanvasTexture:t,NodeMaterial:e,QuadMesh:n,WebGPURenderer:r}=await import("three"),{texture:a,uv:o}=await import("three/tsl"),i=new r({antialias:!0});await i.init();const s=new n;return{decompress:function(n,r=1/0,i=null){const l=n.clone();l.offset.set(0,0),l.repeat.set(1,1);const u=new e;u.fragmentNode=a(l,o().flipY());const c=Math.min(l.image.width,r),p=Math.min(l.image.height,r);i.setSize(c,p),i.outputColorSpace=l.colorSpace,s.material=u,s.render(i);const d=document.createElement("canvas"),m=d.getContext("2d");d.width=c,d.height=p,m.drawImage(i.domElement,0,0,c,p);const f=new t(d);return f.offset.set(n.offset.x,n.offset.y),f.repeat.set(n.repeat.x,n.repeat.y),f.colorSpace=n.colorSpace,f.minFilter=n.minFilter,f.magFilter=n.magFilter,f.wrapS=n.wrapS,f.wrapT=n.wrapT,f.name=n.name,l.dispose(),f},renderer:i}}catch(t){throw new Error("THREE.OBJExporter: Could not import decompress function!")}}class USDZExporter{constructor(t){this.manager=t||DefaultLoadingManager,this.decompress=null,this.renderer=null}parse(t,e,n,r){this.parseAsync(t,r).then(e).catch(n)}async parseAsync(t,e={}){const n=this,{decompress:r,renderer:a}=await import_decompress();n.decompress=r,n.renderer=a,e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},quickLookCompatible:!1,map_flip_required:!1,maxTextureSize:1024},e);const o={};o["model.usda"]=null;let i=buildHeader();i+=buildSceneStart(e);const s={},l={};t.traverseVisible((t=>{if(t.isMesh){const e=t.geometry;let r=t.material;if(!0===Array.isArray(t.material)){if(t.material.length,r=t.material[0],1===r.color.r&&1===r.color.g&&1===r.color.b&&t.material.length>1)for(let e=1;e<t.material.length;e++)if(r.color.r!==t.material[e].color.r||r.color.g!==t.material[e].color.g||r.color.b!==t.material[e].color.b){r=t.material[e];break}if(!r.isMeshStandardMaterial){let e=r.map?r.map.clone():null,n=r.color;r=new MeshStandardMaterial({metalness:.05,roughness:.6,flatShading:!1,opacity:t.material.opacity||1,transparent:t.material.transparent||!1}),n&&r.color.setRGB(n.r,n.g,n.b,LinearSRGBColorSpace),e&&(r.map=e)}const n="geometries/Geometry_"+e.id+".usda";if(!(n in o)){const t=buildMeshObject(e);o[n]=buildUSDFileAsString(t)}r.uuid in s||(s[r.uuid]=r),i+="\t\t\t"+buildXform(t,e,r)}else{if(t.material.isMeshStandardMaterial)r=t.material;else{let e=t.material.map?t.material.map.clone():null;if(e?(e.isCompressedTexture&&(e=n.decompress(e,1/0,n.renderer)),r=new MeshStandardMaterial({map:e,metalness:.5,roughness:.5,flatShading:!1,opacity:t.material.opacity||1,transparent:t.material.transparent||!1})):r=new MeshStandardMaterial({metalness:.5,roughness:.5,flatShading:!1,opacity:t.material.opacity||1,transparent:t.material.transparent||!1}),t.material.color){const e=t.material.color;r.color.setRGB(e.r,e.g,e.b,LinearSRGBColorSpace)}}const a="geometries/Geometry_"+e.id+".usda";if(!(a in o)){const t=buildMeshObject(e);o[a]=buildUSDFileAsString(t)}r.uuid in s||(s[r.uuid]=r),i+="\t\t\t"+buildXform(t,e,r)}}else t.isCamera&&(i+=buildCamera(t))})),i+=buildSceneEnd(),i+=buildMaterials(s,l,e.quickLookCompatible),o["model.usda"]=strToU8(i),i=null;for(const t in l){let r=l[t];!0===r.isCompressedTexture&&(r=n.decompress(r,1/0,n.renderer));const a=imageToCanvas(r.image,e.map_flip_required,e.maxTextureSize),i=await new Promise((t=>a.toBlob(t,"image/png",1)));o[`textures/Texture_${t}.png`]=new Uint8Array(await i.arrayBuffer())}let u=0;for(const t in o){const e=o[t];u+=34+t.length;const n=63&u;if(4!==n){const r=new Uint8Array(64-n);o[t]=[e,{extra:{12345:r}}]}u=e.length}return null!==n.renderer&&(n.renderer.dispose(),n.renderer=null),zipSync(o,{level:0})}}function imageToCanvas(t,e,n){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const r=n/Math.max(t.width,t.height),a=document.createElement("canvas");a.width=t.width*Math.min(1,r),a.height=t.height*Math.min(1,r);const o=a.getContext("2d");return!0===e&&(o.translate(0,a.height),o.scale(1,-1)),o.drawImage(t,0,0,a.width,a.height),a}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const PRECISION=7;function buildHeader(){return'#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n'}function buildSceneStart(t){return`def Xform "Root"\n{\n\tdef Scope "Scenes" (\n\t\tkind = "sceneLibrary"\n\t)\n\t{\n\t\tdef Xform "Scene" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = "Scene"\n\t\t\t}\n\t\t\tsceneName = "Scene"\n\t\t)\n\t\t{\n\t\t\ttoken preliminary:anchoring:type = "${t.ar.anchoring.type}"\n\t\t\ttoken preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\n`}function buildSceneEnd(){return"\n\t\t}\n\t}\n}\n\n"}function buildUSDFileAsString(t){let e=buildHeader();return e+=t,strToU8(e)}function buildXform(t,e,n){const r="Object_"+t.id,a=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant(),`def Xform "${r}" (\n\t\t\t\tprepend references = @./geometries/Geometry_${e.id}.usda@</Geometry>\n\t\t\t\tprepend apiSchemas = ["MaterialBindingAPI"]\n\t\t\t)\n\t\t\t{\n\t\t\t\tmatrix4d xformOp:transform = ${a}\n\t\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\t\trel material:binding = </Materials/Material_${n.id}>\n\t\t\t}\n`}function buildMatrix(t){const e=t.elements;return`( ${buildMatrixRow(e,0)}, ${buildMatrixRow(e,4)}, ${buildMatrixRow(e,8)}, ${buildMatrixRow(e,12)} )`}function buildMatrixRow(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function buildMeshObject(t){return`\ndef "Geometry"\n{\n${buildMesh(t)}\n}\n`}function buildMesh(t){const e=t.attributes,n=e.position.count;return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${buildMeshVertexCount(t)}]\n\t\tint[] faceVertexIndices = [${buildMeshVertexIndices(t)}]\n\t\tnormal3f[] normals = [${buildVector3Array(e.normal,n)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${buildVector3Array(e.position,n)}]\n${buildPrimvars(e)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function buildMeshVertexCount(t){const e=null!==t.index?t.index.count:t.attributes.position.count;return Array(e/3).fill(3).join(", ")}function buildMeshVertexIndices(t){const e=t.index,n=[];if(null!==e)for(let t=0;t<e.count;t++)n.push(e.getX(t));else{const e=t.attributes.position.count;for(let t=0;t<e;t++)n.push(t)}return n.join(", ")}function buildVector3Array(t,e){if(void 0===t)return Array(e).fill("(0, 0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const r=t.getX(e),a=t.getY(e),o=t.getZ(e);n.push(`(${r.toPrecision(7)}, ${a.toPrecision(7)}, ${o.toPrecision(7)})`)}return n.join(", ")}function buildVector2Array(t){const e=[];for(let n=0;n<t.count;n++){const r=t.getX(n)||0,a=t.getY(n)||0;e.push(`(${r.toPrecision(7)}, ${1-a.toPrecision(7)})`)}return e.join(", ")}function buildPrimvars(t){let e="";for(let n=0;n<4;n++){const r=n>0?n:"",a=t["uv"+r];void 0!==a&&(e+=`\n\t\ttexCoord2f[] primvars:st${r} = [${buildVector2Array(a)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const n=t.color;if(void 0!==n){e+=`\n\t\tcolor3f[] primvars:displayColor = [${buildVector3Array(n,n.count)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`}return e}function buildMaterials(t,e,n=!1){const r=[];for(const a in t){const o=t[a];r.push(buildMaterial(o,e,n))}return`def "Materials"\n{\n${r.join("")}\n}\n\n`}function buildMaterial(t,e,n=!1){const r=[],a=[];function o(r,a,o){const i=r.source.id+"_"+r.flipY;e[i]=r;const s=r.channel>0?"st"+r.channel:"st",l={1e3:"repeat",1001:"clamp",1002:"mirror"},u=r.repeat.clone(),c=r.offset.clone(),p=r.rotation,d=Math.sin(p),m=Math.cos(p);return c.y=1-c.y-u.y,n?(c.x=c.x/u.x,c.y=c.y/u.y,c.x+=d/u.x,c.y+=m-1):(c.x+=d*u.x,c.y+=(1-m)*u.y),`\n\t\tdef Shader "PrimvarReader_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdPrimvarReader_float2"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = "${s}"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Transform2d_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdTransform2d"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${a}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(p*(180/Math.PI)).toFixed(7)}\n\t\t\tfloat2 inputs:scale = ${buildVector2(u)}\n\t\t\tfloat2 inputs:translation = ${buildVector2(c)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Texture_${r.id}_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdUVTexture"\n\t\t\tasset inputs:file = @textures/Texture_${i}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${a}.outputs:result>\n\t\t\t${void 0!==o?"float4 inputs:scale = "+buildColor4(o):""}\n\t\t\ttoken inputs:sourceColorSpace = "${r.colorSpace===NoColorSpace?"raw":"sRGB"}"\n\t\t\ttoken inputs:wrapS = "${l[r.wrapS]}"\n\t\t\ttoken inputs:wrapT = "${l[r.wrapT]}"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${t.transparent||t.alphaTest>0?"float outputs:a":""}\n\t\t}`}return t.side,t.map?(r.push(`\t\t\tcolor3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),a.push(o(t.map,"diffuse",t.color))):r.push(`\t\t\tcolor3f inputs:diffuseColor = ${buildColor(t.color)}`),t.emissiveMap?(r.push(`\t\t\tcolor3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),a.push(o(t.emissiveMap,"emissive"))):t.emissive.getHex()>0&&r.push(`\t\t\tcolor3f inputs:emissiveColor = ${buildColor(t.emissive)}`),t.normalMap&&(r.push(`\t\t\tnormal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),a.push(o(t.normalMap,"normal"))),t.aoMap&&(r.push(`\t\t\tfloat inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),a.push(o(t.aoMap,"occlusion"))),t.roughnessMap&&1===t.roughness?(r.push(`\t\t\tfloat inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),a.push(o(t.roughnessMap,"roughness"))):r.push(`\t\t\tfloat inputs:roughness = ${t.roughness}`),t.metalnessMap&&1===t.metalness?(r.push(`\t\t\tfloat inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),a.push(o(t.metalnessMap,"metallic"))):r.push(`\t\t\tfloat inputs:metallic = ${t.metalness}`),t.alphaMap?(r.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),r.push("\t\t\tfloat inputs:opacityThreshold = 0.0056"),a.push(o(t.alphaMap,"opacity"))):void 0!==t.opacity&&(void 0!==t.transmission&&t.transmission>0?(void 0!==t.thickness&&t.thickness>0?(r.push("\t\t\tfloat inputs:opacity = 0.25"),r.push("\t\t\tfloat inputs:opacityThreshold = 0.0059")):(r.push("\t\t\tfloat inputs:opacity = 0.95"),r.push("\t\t\tfloat inputs:opacityThreshold = 0.0058")),t.transmissionMap&&(r.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.transmissionMap.id}_opacity.outputs:r>`),a.push(o(t.transmissionMap,"opacity")))):!0===t.transparent||t.opacity<1?(r.push(`\t\t\tfloat inputs:opacity = ${t.opacity}`),r.push("\t\t\tfloat inputs:opacityThreshold = 0.0057"),t.map&&(r.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),a.push(o(t.map,"opacity")))):t.alphaTest||t.alphaTest>0?(r.push(`\t\t\tfloat inputs:opacity = ${t.opacity}`),r.push(`\t\t\tfloat inputs:opacityThreshold = ${t.alphaTest}`),t.map&&(r.push(`\t\t\tfloat inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),a.push(o(t.map,"opacity")))):r.push(`\t\t\tfloat inputs:opacity = ${t.opacity}`)),t.isMeshPhysicalMaterial&&(t.specularColor&&r.push(`\t\t\tcolor3f inputs:specularColor = ${buildColor(t.specularColor)}`),t.clearcoat&&r.push(`\t\t\tfloat inputs:clearcoat = ${t.clearcoat}`),t.clearcoatRoughness&&r.push(`\t\t\tfloat inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),t.ior&&r.push(`\t\t\tfloat inputs:ior = ${t.ior}`),t.specularColorMap&&(r.push(`\t\t\tcolor3f inputs:specularColor.connect = </Materials/Material_${t.id}/Texture_${t.specularColorMap.id}_specularColor.outputs:rgb>`),a.push(o(t.specularColorMap,"specularColor"))),t.clearcoatMap&&(r.push(`\t\t\tfloat inputs:clearcoat.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatMap.id}_clearcoat.outputs:r>`),a.push(o(t.clearcoatMap,"clearcoat"))),t.clearcoatRoughnessMap&&(r.push(`\t\t\tfloat inputs:clearcoatRoughness.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`),a.push(o(t.clearcoatRoughnessMap,"clearcoatRoughness")))),`\n\tdef Material "Material_${t.id}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n${a.join("\n")}\n\t}\n`}function buildColor(t){return`(${t.r}, ${t.g}, ${t.b})`}function buildColor4(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}function buildVector2(t){return`(${t.x}, ${t.y})`}function buildCamera(t){const e=t.name?t.name:"Camera_"+t.id,n=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant(),t.isOrthographicCamera?`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(7)}, ${t.far.toPrecision(7)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(7)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(7)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`:`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(7)}, ${t.far.toPrecision(7)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(7)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(7)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(7)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(7)}\n\t\t}\n\t\n\t`}export{USDZExporter};