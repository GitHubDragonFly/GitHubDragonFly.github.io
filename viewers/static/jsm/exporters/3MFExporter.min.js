import{BufferAttribute,ClampToEdgeWrapping,Color,DefaultLoadingManager,InterleavedBufferAttribute,LinearFilter,Matrix4,MirroredRepeatWrapping,NearestFilter,Quaternion,Vector3}from"three";import{strToU8,zipSync}from"three/addons/libs/fflate.module.min.js";import{deinterleaveAttribute,mergeVertices}from"three/addons/utils/BufferGeometryUtils.min.js";async function import_decompress(){try{const{WebGLRenderer:e}=await import("three"),{decompress:t}=await import("https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/utils/TextureUtils.min.js");return{decompress:t,renderer:new e({antialias:!0})}}catch(e){}try{const{CanvasTexture:e,NodeMaterial:t,QuadMesh:a,WebGPURenderer:r}=await import("three"),{texture:n,uv:i}=await import("three/tsl"),s=new r({antialias:!0});await s.init();const l=new a;return{decompress:function(a,r=1/0,s=null){const o=a.clone();o.offset.set(0,0),o.repeat.set(1,1);const m=new t;m.fragmentNode=n(o,i().flipY());const p=Math.min(o.image.width,r),c=Math.min(o.image.height,r);s.setSize(p,c),s.outputColorSpace=o.colorSpace,l.material=m,l.render(s);const d=document.createElement("canvas"),u=d.getContext("2d");d.width=p,d.height=c,u.drawImage(s.domElement,0,0,p,c);const g=new e(d);return g.offset.set(a.offset.x,a.offset.y),g.repeat.set(a.repeat.x,a.repeat.y),g.colorSpace=a.colorSpace,g.minFilter=a.minFilter,g.magFilter=a.magFilter,g.wrapS=a.wrapS,g.wrapT=a.wrapT,g.name=a.name,o.dispose(),g},renderer:s}}catch(e){throw new Error("THREE.3MFExporter: Could not import decompress function!")}}class ThreeMFExporter{constructor(e){this.manager=e||DefaultLoadingManager,this.decompress=null,this.renderer=null}parse(e,t,a,r={}){this.parseAsync(e,r).then(t).catch(a)}async parseAsync(e,t={}){e.updateMatrixWorld(!0,!0);const{decompress:a,renderer:r}=await import_decompress();this.decompress=a,this.renderer=r,t=Object.assign({upAxis:"Y_UP",map_flip_required:!1,maxTextureSize:1/0,thumbnail:null},t);let n=new Date,i='<?xml version="1.0" encoding="UTF-8"?>\n';i+='<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02" xmlns:msft="http://www.microsoft.com/3dmanufacturing/microsoftextension/2017/01">\n',i+=' <metadata name="Description">Custom 3MF Exporter</metadata>\n',i+=' <metadata name="Designer">GitHubDragonFly</metadata>\n',i+=' <metadata name="CreationDate">'+(n.toString().split(" ")[0]+" "+n.toLocaleDateString())+"</metadata>\n",i+=await this.createResourcesSection(e),i+=await this.createBuildSection(e),i+="</model>\n";const s={},l=await this.createRelsFile(t),o=await this.createTexturesRelsFile(e);return s["[Content_Types].xml"]=await strToU8(this.createContentTypesFile(t,o)),t.thumbnail&&(s["Metadata/thumbnail.png"]=t.thumbnail),s["_rels/.rels"]=await strToU8(l),null!==o&&(s["3D/_rels/3dmodel.model.rels"]=await strToU8(o),await this.addTexturesToZip(e,s,t)),s["3D/3dmodel.model"]=await strToU8(i),zipSync(s,{level:8})}async createRelsFile(e){let t='<?xml version="1.0" encoding="UTF-8"?>\n';return t+='<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n',t+=' <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />\n',null!==e.thumbnail&&(t+=' <Relationship Target="/Metadata/thumbnail.png" Id="rel1" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail" />\n'),t+="</Relationships>\n",t}async createTexturesRelsFile(e){let t=!1,a='<?xml version="1.0" encoding="UTF-8"?>\n';a+='<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n';const r={};return e.traverse((e=>{if(!0===e.isMesh)if(Array.isArray(e.material))e.material.forEach((e=>{if(null!==e.map||null!==e.emissiveMap){const n=null!==e.map?e.map:e.emissiveMap;t=!0;let i=n.name?n.name:"texture_"+n.uuid;if(-1===i.indexOf(".")&&(i+=".png"),!r[i]){r[i]=i;let e="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dtexture";a+=' <Relationship Target="/3D/Textures/'+i+'" Id="rel'+n.id+'" Type="'+e+'" />\n'}}}));else if(null!==e.material.map||null!==e.material.emissiveMap){const n=null!==e.material.map?e.material.map:e.material.emissiveMap;t=!0;let i=n.name?n.name:"texture_"+n.uuid;if(-1===i.indexOf(".")&&(i+=".png"),!r[i]){r[i]=i;let e="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dtexture";a+=' <Relationship Target="/3D/Textures/'+i+'" Id="rel'+n.id+'" Type="'+e+'" />\n'}}})),a+="</Relationships>\n",!0===t?a:null}createContentTypesFile(e,t){let a='<?xml version="1.0" encoding="UTF-8"?>\n';return a+='<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">\n',a+=' <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />\n',a+=' <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />\n',null!==t&&(a+=' <Default Extension="png" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodeltexture" />\n'),null!==e.thumbnail&&(a+=' <Override PartName="/Metadata/thumbnail.png" ContentType="image/png" />\n'),a+="</Types>\n",a}async createResourcesSection(e){let t=" <resources>\n";return e.traverse((e=>{if(!0===e.isMesh){let a=this.interleaved_buffer_attribute_check(e.geometry.clone()),r=e.material;if(a.groups.length>0&&(a.groups=a.groups.sort(((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start))),a.index||(a=mergeVertices(a,1e-6)),a.attributes.normal||a.computeVertexNormals(),a.normalizeNormals(),a.attributes.color&&!r.map)t+='  <m:colorgroup id="'+a.id+'">\n',t+=this.generateColors(a),t+="  </m:colorgroup>\n",t+='  <object id="'+e.id+'" type="model">\n',t+="   <mesh>\n",t+=this.generateVertices(a),t+=this.generateTriangles(a,null,a.id),t+="   </mesh>\n",t+="  </object>\n";else if(Array.isArray(r)&&r.length>1&&a.groups.length===r.length){let n="";r.forEach(((r,i)=>{let s=e.id+1e9+r.id+i,l=r.color.getHexString().toUpperCase();"000000"===l&&(l=r.emissive.getHexString().toUpperCase());let o="#"+l;if(r.opacity<1||!0===r.transparent){o+=1===r.opacity?"FD":parseInt(255*r.opacity).toString(16).toUpperCase().padStart(2,"0")}if(void 0!==r.metalness){let e=1e9+r.id,a=r.metalness,n=r.roughness;t+='  <m:pbmetallicdisplayproperties id="'+e+'">\n',t+='   <m:pbmetallic name="Metallic" metallicness="'+a+'" roughness="'+n+'" />\n',t+="  </m:pbmetallicdisplayproperties>\n",t+='  <basematerials id="'+r.id+'">\n',t+='   <base name="Metallic" displaycolor="'+o+'" displaypropertiesid="'+e+'" index="'+i+'" />\n',t+="  </basematerials>\n"}else t+='  <basematerials id="'+r.id+'">\n',t+='   <base name="'+(r.name||r.type)+'" displaycolor="'+o+'" index="'+i+'" />\n',t+="  </basematerials>\n";if(null!==r.map||null!==r.emissiveMap){const e=null!==r.map?r.map:r.emissiveMap;t+=this.processMap(r,r.id,e),a.hasAttribute("uv")&&(t+=this.generateUVs(a,s,e.id,i)),t+='  <object id="'+s+'" type="model">\n',t+="   <mesh>\n",t+=this.generateVertices(a,i),t+=this.generateTriangles(a,s,null,i),t+="   </mesh>\n",t+="  </object>\n"}else t+='  <object id="'+s+'" pid="'+r.id+'" pindex="0" type="model">\n',t+="   <mesh>\n",t+=this.generateVertices(a,i),t+=this.generateTriangles(a,null,null,i),t+="   </mesh>\n",t+="  </object>\n";n+='    <component objectid="'+s+'" />\n'})),t+='  <object id="'+e.id+'" type="model">\n',t+="   <components>\n",t+=n,t+="   </components>\n",t+="  </object>\n"}else if(Array.isArray(r)&&1===r.length&&(r=r[0]),null!==r.map||null!==r.emissiveMap){let n=e.id+1e9+r.id;const i=null!==r.map?r.map:r.emissiveMap;t+=this.processMap(r,r.id,i,!0),a.hasAttribute("uv")&&(t+=this.generateUVs(a,n,i.id)),t+='  <object id="'+e.id+'" type="model">\n',t+="   <mesh>\n",t+=this.generateVertices(a),t+=this.generateTriangles(a,n),t+="   </mesh>\n",t+="  </object>\n"}else{let n=r.color.getHexString().toUpperCase();"000000"===n&&(n=r.emissive.getHexString().toUpperCase());let i="#"+n;if(r.opacity<1||!0===r.transparent){i+=1===r.opacity?"FD":parseInt(255*r.opacity).toString(16).toUpperCase().padStart(2,"0")}if(void 0!==r.metalness){let e=1e9+r.id,a=r.metalness,n=r.roughness;t+='  <m:pbmetallicdisplayproperties id="'+e+'">\n',t+='   <m:pbmetallic name="Metallic" metallicness="'+a+'" roughness="'+n+'" />\n',t+="  </m:pbmetallicdisplayproperties>\n",t+='  <basematerials id="'+r.id+'">\n',t+='   <base name="Metallic" displaycolor="'+i+'" displaypropertiesid="'+e+'" />\n',t+="  </basematerials>\n"}else t+='  <basematerials id="'+r.id+'">\n',t+='   <base name="'+(r.name||r.type)+'" displaycolor="'+i+'" />\n',t+="  </basematerials>\n";t+='  <object id="'+e.id+'" pid="'+r.id+'" pindex="0" name="'+e.name+'" type="model">\n',t+="   <mesh>\n",t+=this.generateVertices(a),t+=this.generateTriangles(a),t+="   </mesh>\n",t+="  </object>\n"}}})),t+=" </resources>\n",t}async createBuildSection(e){let t=" <build>\n";return e.traverse((e=>{if(!0===e.isMesh){const a=new Matrix4;a.copy(e.matrixWorld);const r=new Vector3,n=new Quaternion,i=new Vector3;a.decompose(r,n,i);const s=(new Matrix4).compose(r,n,i).elements;let l="";l+=s[0]+" "+s[1]+" "+s[2]+" "+s[4]+" ",l+=s[5]+" "+s[6]+" "+s[8]+" "+s[9]+" ",l+=s[10]+" "+s[12]+" "+s[13]+" "+s[14],t+='  <item objectid="'+e.id+'" transform="'+l+'" />\n'}})),t+=" </build>\n",t}processMap(e,t,a,r=!1){let n="";!0===r&&(n+='  <basematerials id="'+t+'">\n',n+='   <base name="'+(e.name||e.type)+'" displaycolor="FFFFFF" />\n',n+="  </basematerials>\n");let i=a.name?a.name:"texture_"+a.uuid;-1===i.indexOf(".")&&(i+=".png");let s=a.wrapS===MirroredRepeatWrapping?"mirror":a.wrapS===ClampToEdgeWrapping?"clamp":"wrap",l=a.wrapT===MirroredRepeatWrapping?"mirror":a.wrapT===ClampToEdgeWrapping?"clamp":"wrap",o=a.magFilter===NearestFilter&&a.minFilter===NearestFilter?"nearest":a.magFilter===LinearFilter&&a.minFilter===LinearFilter?"linear":"auto";return n+='  <m:texture2d id="'+a.id+'" path="/3D/Textures/'+i+'" contenttype="image/png" tilestyleu="'+s+'" tilestylev="'+l+'" filter="'+o+'" />\n',n}generateColors(e){const t=e.getAttribute("color");let a="";for(let e=0;e<t.count;e++){a+='   <m:color color="#'+((new Color).fromBufferAttribute(t,e).getHexString().toUpperCase()+"FF")+'" />\n'}return a}generateVertices(e,t=null){const a=e.index.array,r=e.attributes.position.array;let n="    <vertices>\n";const i=null!==t&&void 0!==e.groups[t];let s=!0===i?e.groups[t].start:0,l=!0===i?e.groups[t].start+e.groups[t].count:r.length;if(l===1/0&&(l=a.length),!0===i)for(let e=s;e<l;e++){n+='     <vertex x="'+r[3*a[e]]+'" y="'+r[3*a[e]+1]+'" z="'+r[3*a[e]+2]+'" />\n'}else for(let e=s;e<l;e+=3){n+='     <vertex x="'+r[e]+'" y="'+r[e+1]+'" z="'+r[e+2]+'" />\n'}return n+="    </vertices>\n",n}generateTriangles(e,t=null,a=null,r=null){const n=e.index.array;let i="    <triangles>\n";const s=null!==r&&void 0!==e.groups[r];let l=!0===s?e.groups[r].count:n.length;l===1/0&&(l=!0===s?n.length-e.groups[r].start:n.length);for(let e=0;e<l;e+=3){let r=!0===s?e:n[e],l=!0===s?e+1:n[e+1],o=!0===s?e+2:n[e+2];i+=null!==t?'     <triangle v1="'+r+'" v2="'+l+'" v3="'+o+'" pid="'+t+'" p1="'+r+'" p2="'+l+'" p3="'+o+'" />\n':null!==a?'     <triangle v1="'+r+'" v2="'+l+'" v3="'+o+'" pid="'+a+'" p1="'+r+'" />\n':'     <triangle v1="'+r+'" v2="'+l+'" v3="'+o+'" />\n'}return i+="    </triangles>\n",i}generateUVs(e,t,a,r=null){const n=e.index.array,i=e.attributes.uv.array;let s='  <m:texture2dgroup id="'+t+'" texid="'+a+'">\n';const l=null!==r&&void 0!==e.groups[r];let o=!0===l?e.groups[r].start:0,m=!0===l?e.groups[r].start+e.groups[r].count:i.length;if(!0===l)for(let e=o;e<m;e++){s+='   <m:tex2coord u="'+i[2*n[e]]+'" v="'+i[2*n[e]+1]+'" />\n'}else for(let e=o;e<m;e+=2){s+='   <m:tex2coord u="'+i[e]+'" v="'+i[e+1]+'" />\n'}return s+="  </m:texture2dgroup>\n",s}async addTexturesToZip(e,t,a){const r={},n=[];e.traverse((e=>{if(!0===e.isMesh){let i;if(Array.isArray(e.material)){for(const s of e.material)if(null!==s.map||null!==s.emissiveMap){const e=null!==s.map?s.map:s.emissiveMap,l=e.uuid;i=!0===e.isCompressedTexture?this.decompress(e.clone(),1/0,this.renderer):e.clone();let o=i.name?i.name:"texture_"+l;if(-1===o.indexOf(".")&&(o+=".png"),!r[o]){r[o]=o;const e=this.imageToCanvas(i.image,a.map_flip_required,a.maxTextureSize).toDataURL("image/png",1).split(",")[1],s=atob(e),l=s.length,m=new Uint8Array(l);for(let e=0;e<l;e++)m[e]=s.charCodeAt(e);const p=new Blob([m],{type:"image/png"});n.push(new Promise((async e=>{const a=await p.arrayBuffer(),r=new Uint8Array(a);e(t["3D/Textures/"+o]=r)})))}}}else if(null!==e.material.map||null!==e.material.emissiveMap){const s=null!==e.material.map?e.material.map:e.material.emissiveMap,l=s.uuid;i=!0===s.isCompressedTexture?this.decompress(s.clone(),1/0,this.renderer):s.clone();let o=i.name?i.name:"texture_"+l;if(-1===o.indexOf(".")&&(o+=".png"),!r[o]){r[o]=o;const e=this.imageToCanvas(i.image,a.map_flip_required,a.maxTextureSize).toDataURL("image/png",1).split(",")[1],s=atob(e),l=s.length,m=new Uint8Array(l);for(let e=0;e<l;e++)m[e]=s.charCodeAt(e);const p=new Blob([m],{type:"image/png"});n.push(new Promise((async e=>{const a=await p.arrayBuffer(),r=new Uint8Array(a);e(t["3D/Textures/"+o]=r)})))}}i&&i.dispose()}})),await Promise.all(n)}imageToCanvas(e,t,a){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){let r,n;if("canvas"==typeof e)r=e;else{r=document.createElement("canvas");let i=a/Math.max(e.width,e.height);if(r.width=e.width*Math.min(1,i),r.height=e.height*Math.min(1,i),n=r.getContext("2d",{willReadFrequently:!0}),!0===t&&(n.translate(0,r.height),n.scale(1,-1)),e instanceof ImageData)n.putImageData(e,0,0);else if(e.data&&e.data.constructor===Uint8Array){let t=new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);n.putImageData(t,0,0)}else n.drawImage(e,0,0,r.width,r.height)}return r}throw new Error("THREE.3MFExporter: No valid image data found. Unable to process texture.")}deinterleave(e,t="color"){const a=e.attributes[t],r=a.itemSize,n=a.offset,i=a.data;if(void 0===i)return[];let s=new InterleavedBufferAttribute(i,r,n),l=deinterleaveAttribute(s),o=Array(l.array.length);for(let e=0,t=l.array.length;e<t;e++)o[e]=isNaN(l.array[e])?0:l.array[e];return new BufferAttribute(new Float32Array(o),r)}interleaved_buffer_attribute_check(e){const t=["position","normal","color","tangent","uv","uv1","uv2","uv3"];for(const a of t)if(e.attributes[a]&&e.attributes[a].isInterleavedBufferAttribute){if(e.attributes[a].data&&e.attributes[a].data.array){let t=this.deinterleave(e,a);e.deleteAttribute(a),e.setAttribute(a,t)}}else if(e.attributes[a]&&e.attributes[a].array){const t=e.attributes[a].itemSize,r=e.attributes[a].array,n=Array(r.length);for(let e=0,t=r.length;e<t;e++)n[e]=isNaN(r[e])?0:r[e];e.deleteAttribute(a),e.setAttribute(a,new BufferAttribute(new Float32Array(n),t))}return e}}export{ThreeMFExporter};