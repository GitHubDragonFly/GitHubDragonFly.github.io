import{DefaultLoadingManager,Matrix3,Vector3}from"three";import*as compressor from"https://esm.sh/lzfjs@1.0.1";const _tempVec=new Vector3;class PCDExporter{constructor(t){this.manager=t||DefaultLoadingManager}parse(t,e,n,r={}){this.parseAsync(t,e,n,r)}async parseAsync(t,e,n,r={}){const o=this;r=Object.assign({binary:!1,binaryCompressed:!1,includeNormals:!1,includeIntensity:!0,includeAlpha:!1,includeColors:!0,colorUnsigned:!1},r),t.updateMatrixWorld(!0,!0);const i=[];let s=0;const a=[];let l;function c(t,e,n){const r=(255&t)<<16|(255&e)<<8|(255&n)<<0,o=new Float32Array(1);return new Uint32Array(o.buffer)[0]=r,o[0]}function p(t,e,n){return(255&t)<<16|(255&e)<<8|(255&n)<<0}function u(t,e,n,r){const o=(255&r)<<24|(255&t)<<16|(255&e)<<8|(255&n)<<0,i=new Float32Array(1);return new Uint32Array(i.buffer)[0]=o,i[0]}function y(t,e,n,r){return(255&r)<<24|(255&t)<<16|(255&e)<<8|(255&n)<<0}if(function(){t.traverse((function(t){t.isPoints&&t.geometry&&(i.push(t),s+=t.geometry.attributes.position.count)}));const e=r.includeColors&&i.some((t=>t.geometry.attributes.color)),n=r.includeNormals&&i.some((t=>t.geometry.attributes.normal)),m=r.includeIntensity&&i.some((t=>t.geometry.attributes.intensity)),f=["x","y","z"],g=[4,4,4],h=["F","F","F"],b=[1,1,1];a.push({name:"x",type:"float32"}),a.push({name:"y",type:"float32"}),a.push({name:"z",type:"float32"}),n&&(a.push({name:"normal_x",type:"float32"}),a.push({name:"normal_y",type:"float32"}),a.push({name:"normal_z",type:"float32"}),f.push("normal_x","normal_y","normal_z"),g.push(4,4,4),h.push("F","F","F"),b.push(1,1,1)),m&&(a.push({name:"intensity",type:"float32"}),f.push("intensity"),g.push(4),h.push("F"),b.push(1)),e&&(a.push({name:r.includeAlpha?"rgba":"rgb",type:r.colorUnsigned?"uint32":"float32"}),f.push(r.includeAlpha?"rgba":"rgb"),g.push(4),h.push(r.colorUnsigned?"U":"F"),b.push(1));let d=`# Created by the custom PCD Exporter\n# .PCD v0.7 - Point Cloud Data file format\nVERSION 0.7\nFIELDS ${f.join(" ")}\nSIZE ${g.join(" ")}\nTYPE ${h.join(" ")}\nCOUNT ${b.join(" ")}\nWIDTH ${s}\nHEIGHT 1\nVIEWPOINT 0 0 0 0.7071068 -0.7071068 0 0\nPOINTS ${s}\nDATA ${r.binaryCompressed?"binary_compressed":r.binary?"binary":"ascii"}\n`;const A=[];let w,U,_,x,V="";(r.binary||r.binaryCompressed)&&(w=12+(n?12:0)+(m?4:0)+(e?4:0),U=new ArrayBuffer(w*s),_=new DataView(U),x=0);for(const t of i){const o=t.geometry.attributes.position,i=t.geometry.attributes.color,s=t.geometry.attributes.normal,a=t.matrixWorld,l=(new Matrix3).getNormalMatrix(a);for(let f=0;f<o.count;f++){_tempVec.fromBufferAttribute(o,f),_tempVec.applyMatrix4(a);const g=_tempVec.x,h=_tempVec.y,b=_tempVec.z;if(r.binary||r.binaryCompressed){if(_.setFloat32(x,g,!0),x+=4,_.setFloat32(x,h,!0),x+=4,_.setFloat32(x,b,!0),x+=4,n){_tempVec.fromBufferAttribute(s,f),_tempVec.applyMatrix3(l).normalize();const t=_tempVec.x,e=_tempVec.y,n=_tempVec.z;_.setFloat32(x,t,!0),x+=4,_.setFloat32(x,e,!0),x+=4,_.setFloat32(x,n,!0),x+=4}if(m){const e=t.geometry.getAttribute("intensity"),n=e?e.getX(f):1;_.setFloat32(x,n,!0),x+=4}if(e){const e=i?255*i.getX(f):255,n=i?255*i.getY(f):255,o=i?255*i.getZ(f):255;if(r.includeAlpha){const i=t.geometry.getAttribute("alpha"),s=Math.min(255,Math.max(0,i?255*i.getX(f):255*t.material.opacity)),a=r.colorUnsigned?y(e,n,o,s):u(e,n,o,s);r.colorUnsigned?_.setUint32(x,a,!0):_.setFloat32(x,a,!0)}else{const t=r.colorUnsigned?p(e,n,o):c(e,n,o);r.colorUnsigned?_.setUint32(x,t,!0):_.setFloat32(x,t,!0)}x+=4}}else{if(V+=`${g} ${h} ${b}`,n){_tempVec.fromBufferAttribute(s,f),_tempVec.applyMatrix3(l).normalize();V+=` ${_tempVec.x} ${_tempVec.y} ${_tempVec.z}`}if(m){const e=t.geometry.getAttribute("intensity");V+=` ${e?e.getX(f):1}`}if(e){const e=i?255*i.getX(f):255,n=i?255*i.getY(f):255,o=i?255*i.getZ(f):255;if(r.includeAlpha){const i=t.geometry.getAttribute("alpha"),s=Math.min(255,Math.max(0,i?255*i.getX(f):255*t.material.opacity));V+=` ${r.colorUnsigned?y(e,n,o,s):u(e,n,o,s)}`}else{V+=` ${r.colorUnsigned?p(e,n,o):c(e,n,o)}`}}V+="\n",A.push(V),V=""}}}if(r.binary||r.binaryCompressed){d.endsWith("\n")||(d+="\n");const t=(new TextEncoder).encode(d);if(r.binaryCompressed){f.length;const e=o._buildSoA(new Float32Array(U),s,a),n=compressor.compress(new Uint8Array(e)),r=n.length,i=U.byteLength,c=new Uint8Array(8);new DataView(c.buffer).setUint32(0,r,!0),new DataView(c.buffer).setUint32(4,i,!0),l=new Uint8Array(t.length+c.length+r),l.set(t,0),l.set(c,t.length),l.set(n,t.length+c.length)}else l=new Uint8Array(t.length+U.byteLength),l.set(t,0),l.set(new Uint8Array(U),t.length)}else l=d+A.join("")}(),0===s){if("function"==typeof n)return n("THREE.PCDExporter: No qualifying objects found!"),null;throw new Error("THREE.PCDExporter: No qualifying objects found!")}if("function"!=typeof e)return l;e(l)}_buildSoA(t,e,n){const r=n.reduce(((t,e)=>t+(e.type,1)),0),o=n.filter((t=>"float32"===t.type)),i=n.filter((t=>"uint32"===t.type)),s=new Float32Array(e*o.length),a=new Uint32Array(e*i.length);let l=0,c=0;for(let o=0;o<n.length;o++){const i=n[o];if("float32"===i.type){const n=l*e;for(let i=0;i<e;i++)s[n+i]=t[i*r+o];l++}if("uint32"===i.type){const n=c*e;for(let i=0;i<e;i++)a[n+i]=t[i*r+o];c++}}const p=new Uint8Array(s.byteLength+a.byteLength);return p.set(new Uint8Array(s.buffer),0),p.set(new Uint8Array(a.buffer),s.byteLength),p}}export{PCDExporter};