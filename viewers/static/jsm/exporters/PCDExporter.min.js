import{BufferAttribute,BufferGeometry,DefaultLoadingManager,Matrix3,Points,Vector3}from"three";import*as compressor from"https://esm.sh/lzfjs@1.0.1";class PCDExporter{constructor(t){this.manager=t||DefaultLoadingManager,this._tempVec=new Vector3}parse(t,e,n,r={}){this.parseAsync(t,e,n,r)}async parseAsync(t,e,n,r={}){const o=this;new Set;if(r=Object.assign({binary:!1,binaryCompressed:!1,littleEndian:!0,includeAlpha:!1,includeColors:!0,colorUnsigned:!1,separateRGB:!1,includeNormals:!0,includeIntensity:!0,includeClassification:!0,intensityType:"U2",classificationType:"U1",customFields:[]},r),!["U1","U2","U4","F4"].includes(r.intensityType))throw new Error("Invalid intensityType - valid values: U1, U2, U4, F4");if(!["U1","U2","U4"].includes(r.classificationType))throw new Error("Invalid classificationType - valid values: U1, U2, U4");if(r.customFields.length>0)for(const t of r.customFields){if(!/^[A-Za-z_][A-Za-z0-9_]*$/.test(t.name))throw new Error(`Invalid custom field name: ${t.name}`);if(!["U","F"].includes(t.type))throw new Error("Invalid custom field type - valid values: U, F");if(![1,2,4,8].includes(t.size))throw new Error("Invalid custom field size - valid values: 1, 2, 4, 8");if(null!=t.count&&t.count<1)throw new Error("Invalid custom field count - valid values: >= 1");if("string"!=typeof t.source)throw new Error("Invalid custom field source - requires string value");if(null!=t.scale&&t.scale<=0)throw new Error("Invalid custom field scale - valid values: >= 0")}t.updateMatrixWorld(!0,!0);let i=[],s=0;const a=[];let l;function c(t){return t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055}const u=new Float32Array(1),f=new Uint32Array(u.buffer);function m(t,e,n,r,o,i,s,a){let l;return l=a?s?(255&n)<<0|(255&e)<<8|(255&t)<<16|(255&r)<<24:(255&n)<<0|(255&e)<<8|(255&t)<<16:s?(255&r)<<24|(255&t)<<16|(255&e)<<8|(255&n)<<0:(255&t)<<16|(255&e)<<8|(255&n)<<0,"U"===o?i?l>>>0:l:(f[0]=4278190079&l,u[0])}if(function(){if(t.traverse((function(t){t.isPoints&&t.geometry&&(i.push(t),s+=t.geometry.attributes.position.count)})),0===s)return;if(i.length>1){const t=i.map((t=>{const e=t.geometry.clone();return e.applyMatrix4(t.matrixWorld),e})),e=o._mergeGeometries(t),n=i[0].material.clone();i=[new Points(e,n)]}const e=r.includeColors&&i.some((t=>t.geometry.attributes.color)),n=r.includeNormals&&i.some((t=>t.geometry.attributes.normal)),u=r.includeIntensity&&i.some((t=>t.geometry.attributes.intensity)),f=r.includeClassification&&i.some((t=>t.geometry.attributes.classification)),y=[],p=[],d=[],g=[];function h(t,e,n,r=1,o,i,s=1,l=0){a.push({name:t,type:e,size:n,count:r,source:o,component:i,scale:s,offset:l}),y.push(t),d.push(e),p.push(n),g.push(r)}if(h("x","F",4,1,"position"),h("y","F",4,1,"position"),h("z","F",4,1,"position"),n&&(h("normal_x","F",4,1,"normal"),h("normal_y","F",4,1,"normal"),h("normal_z","F",4,1,"normal")),u){h("intensity",r.intensityType[0],parseInt(r.intensityType.slice(1)),1,"intensity")}if(f){h("classification","U",parseInt(r.classificationType.slice(1)),1,"classification")}if(e)if(r.separateRGB)h("r","U",1,1,"color",0),h("g","U",1,1,"color",1),h("b","U",1,1,"color",2),r.includeAlpha&&h("a","U",1,1,"alpha",3);else{const t=r.colorUnsigned?"U":"F";h(r.includeAlpha?"rgba":"rgb",t,4,1,"color")}if(r.customFields.length>0){const t=i[0];for(const e of r.customFields){const n=t.geometry.getAttribute(e.source);let r=e.count;null===r?r=n?n.itemSize:1:n&&n.itemSize!==e.count&&console.warn(`PCD Exporter: Custom field "${e.name}" expects count ${e.count}, but attribute "${e.source}" has itemSize ${n.itemSize}.`),h(e.name,e.type,e.size,r,e.source,null,e.scale??1,e.offset??0)}}const b=r.binaryCompressed?"binary_compressed":r.binary?"binary":"ascii";let w=`# Created by the custom PCD Exporter\n# COLOR_ENDIANNESS ${r.littleEndian?"BBGGRRAA (little-endian)":"AARRGGBB (big-endian)"}\n# .PCD v0.7 - Point Cloud Data file format\nVERSION 0.7\nFIELDS ${y.join(" ")}\nSIZE ${p.join(" ")}\nTYPE ${d.join(" ")}\nCOUNT ${g.join(" ")}\nWIDTH ${s}\nHEIGHT 1\nVIEWPOINT 0 0 0 ${.9999996192.toFixed(10)} ${.0008726646.toFixed(10)} 0 0\nPOINTS ${s}\nDATA ${b}\n`;const A=a.reduce(((t,e)=>t+e.size*e.count),0);let U=null,x=null,_=0;const z=[];if(r.binary||r.binaryCompressed){U=new ArrayBuffer(A*s),x=new DataView(U),_=0}for(const t of i){const e=t.geometry.attributes.position,n=t.geometry.getAttribute("alpha"),i=o._normalize(t.geometry.attributes.color),s=t.geometry.attributes.normal,l=t.geometry.attributes.intensity,u=t.geometry.attributes.classification,f=t.matrixWorld,y=(new Matrix3).getNormalMatrix(f),p={pos:e,normalAttr:s,intensityAttr:l,classificationAttr:u,colorAttr:i,alphaAttr:n,worldMatrix:f,normalMatrix:y,options:r,packColor:(e,o)=>{const s=i?255*c(i.getX(e)):255,a=i?255*c(i.getY(e)):255,l=i?255*c(i.getZ(e)):255;if(r.includeAlpha){return m(s,a,l,Math.min(255,Math.max(0,n?255*n.getX(e):255*t.material.opacity)),o,r.colorUnsigned,!0,r.littleEndian)}return m(s,a,l,255,o,r.colorUnsigned,!1,r.littleEndian)}};for(let n=0;n<e.count;n++)if(r.binary||r.binaryCompressed)for(const e of a){const i=o._readFieldValue(e,n,t,p);_=o._writeFieldBinary(e,i,x,_,r.littleEndian)}else{let e="";for(const r of a){const i=o._readFieldValue(r,n,t,p);if(Array.isArray(i))for(const t of i)e+=t+" ";else e+=i+" "}z.push(e.trim()+"\n")}}if(r.binary||r.binaryCompressed){w.endsWith("\n")||(w+="\n");const t=(new TextEncoder).encode(w);if(r.binaryCompressed){y.length;let e=o._buildSoA(U,s,a);const n=compressor.compress(e),r=n.length,i=e.byteLength,c=new Uint8Array(8);new DataView(c.buffer).setUint32(0,r,!0),new DataView(c.buffer).setUint32(4,i,!0),l=new Uint8Array(t.length+c.length+r),l.set(t,0),l.set(c,t.length),l.set(n,t.length+c.length),e=null}else l=new Uint8Array(t.length+U.byteLength),l.set(t,0),l.set(new Uint8Array(U),t.length);U=null}else l=w+z.join("")}(),0===s){if("function"==typeof n)return n("THREE.PCDExporter: No qualifying objects found!"),null;throw new Error("THREE.PCDExporter: No qualifying objects found!")}return"function"==typeof e&&e(l),l}_readFieldValue(t,e,n,r){const{pos:o,normalAttr:i,intensityAttr:s,classificationAttr:a,colorAttr:l,alphaAttr:c,worldMatrix:u,normalMatrix:f,options:m,packColor:y}=r;switch(t.name){case"x":case"y":case"z":return this._tempVec.fromBufferAttribute(o,e),this._tempVec.applyMatrix4(u),"x"===t.name?this._tempVec.x:"y"===t.name?this._tempVec.y:this._tempVec.z;case"normal_x":case"normal_y":case"normal_z":return i?(this._tempVec.fromBufferAttribute(i,e),this._tempVec.applyMatrix3(f).normalize(),"normal_x"===t.name?this._tempVec.x:"normal_y"===t.name?this._tempVec.y:this._tempVec.z):0;case"intensity":return s?s.getX(e):1;case"classification":return a?a.getX(e):0;case"rgb":case"rgba":return y(e,t.type);default:{if("color"===t.source&&null!=t.component){if(!l)return 0;const n=3*e,r=l.array[n+t.component];return Math.round(255*r)}if("a"===t.name&&"alpha"===t.source){if(c){const t=c.getX(e);return Math.round(255*t)}return 255}const r=n.geometry.getAttribute(t.source);if(!r)return missingSourceWarnings.has(t.source)||(console.warn(`PCD Exporter: Missing attribute "${t.source}" for field "${t.name}". Falling back to default value 0.`),missingSourceWarnings.add(t.source)),1===t.count?t.offset:Array(t.count).fill(t.offset);if(r.itemSize<t.count&&console.warn(`PCD Exporter: Attribute "${t.source}" has itemSize ${r.itemSize}, but field "${t.name}" expects count ${t.count}.`),1===t.count){let n=r.getX(e);return n=n*t.scale+t.offset,n}const o=[];for(let n=0;n<t.count;n++){let i=r.getComponent(e,n);i=i*t.scale+t.offset,o.push(i)}return o}}}_writeFieldBinary(t,e,n,r,o){if(1===t.count)return this._writeOne(t,e,n,r,o);for(let i=0;i<t.count;i++)r=this._writeOne(t,e[i],n,r,o);return r}_writeOne(t,e,n,r,o){const i="color"!==t.source||o;switch(t.type){case"F":4===t.size?n.setFloat32(r,e,i):n.setFloat64(r,e,i);break;case"U":1===t.size?n.setUint8(r,e):2===t.size?n.setUint16(r,e,i):n.setUint32(r,e,i);break;case"I":1===t.size?n.setInt8(r,e):2===t.size?n.setInt16(r,e,i):n.setInt32(r,e,i)}return r+t.size}_normalize(t){if(!t)return null;if(0===t.count||0===t.itemSize)return null;if(t.array instanceof Float32Array)return t;const e=t.count,n=t.itemSize,r=new Float32Array(e*n),o=new Array(n).fill(1/0),i=new Array(n).fill(-1/0);for(let r=0;r<e;r++)for(let e=0;e<n;e++){const n=t.getComponent(r,e);n<o[e]&&(o[e]=n),n>i[e]&&(i[e]=n)}for(let s=0;s<e;s++)for(let e=0;e<n;e++){const a=t.getComponent(s,e),l=i[e]-o[e]||1;r[s*n+e]=(a-o[e])/l}return new BufferAttribute(r,n)}_concatTyped(t,e){let n=0;for(const e of t)n+=e.length;const r=new e(n);let o=0;for(const e of t)r.set(e,o),o+=e.length;return r}_mergeGeometries(t){const e=new Set;for(const n of t)for(const t of Object.keys(n.attributes))e.add(t);if(!e.has("position"))throw new Error("All geometries must contain a position attribute");const n={},r=[Float64Array,Float32Array,Uint32Array,Uint16Array,Uint8Array];for(const o of e){let e=null,i=null;for(const n of t){const t=n.getAttribute(o);if(!t)continue;const s=t.array.constructor;(!e||r.indexOf(s)<r.indexOf(e))&&(e=s,i=t.itemSize)}n[o]={itemSize:i,arrayType:e}}const o={};for(const t of e)o[t]=[];for(const r of t){const t=r.getAttribute("position").count;for(const i of e){const e=r.getAttribute(i);if(e)o[i].push(e.array);else{const{itemSize:e,arrayType:r}=n[i],s=new r(t*e);"color"===i||"intensity"===i?s.fill(1):"classification"===i?s.fill(0):"alpha"===i?s.fill(1):s.fill(0),o[i].push(s)}}}const i=new BufferGeometry;for(const t of e){const{itemSize:e,arrayType:r}=n[t],s=this._concatTyped(o[t],r);i.setAttribute(t,new BufferAttribute(s,e))}return i.computeBoundingBox(),i.computeBoundingSphere(),i}_buildSoA(t,e,n){const r=n.reduce(((t,e)=>t+e.size*e.count),0),o=new Uint8Array(e*r),i=new Uint8Array(t);let s=0,a=0;for(let t=0;t<n.length;t++){const l=n[t].size*n[t].count;for(let t=0;t<e;t++){const e=t*r+a;o.set(i.subarray(e,e+l),s),s+=l}a+=l}return o}}export{PCDExporter};