import{Color,BufferAttribute,DoubleSide,InterleavedBufferAttribute,Matrix4,MeshBasicMaterial}from"three";import{decompress}from"https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/utils/TextureUtils.min.js";import{deinterleaveAttribute}from"https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/utils/BufferGeometryUtils.min.js";class ColladaExporter{parse(e,t,r={}){if(null===(r=Object.assign({version:"1.4.1",author:null,textureDirectory:"",upAxis:"Y_UP",unitName:null,unitMeter:null},r)).upAxis.match(/^[XYZ]_UP$/))return null;if(null!==r.unitName&&null===r.unitMeter)return null;if(null!==r.unitMeter&&null===r.unitName)return null;""!==r.textureDirectory&&(r.textureDirectory=`${r.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const a=r.version;if("1.4.1"!==a&&"1.5.0"!==a)return null;let i,n,s;function o(e,t){if(i=i||document.createElement("canvas"),n=n||i.getContext("2d"),i.width=e.width,i.height=e.height,e instanceof ImageData)n.putImageData(e,0,0);else if(e.data&&e.data.constructor===Uint8Array){let t=new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);n.putImageData(t,0,0)}else n.drawImage(e,0,0,i.width,i.height);return function(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0,a=r.length;e<a;e++)r[e]=t.charCodeAt(e);return r}(i.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,""))}function l(e,t="color"){const r=e.attributes[t],a=r.itemSize,i=r.offset,n=r.data;if(void 0===n)return[];let s=new InterleavedBufferAttribute(n,a,i),o=deinterleaveAttribute(s),l=Array(o.array.length);for(let e=0,t=o.array.length;e<t;e++)l[e]=isNaN(o.array[e])?0:o.array[e];return new BufferAttribute(new Float32Array(l),a)}function u(e,t,r,a){const i=e.array;return`<source id="${t}"><float_array id="${t}-array" count="${i.length}">`+i.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(i.length/e.itemSize)}" stride="${e.itemSize}">`+r.map((e=>`<param name="${e}" type="${a}" />`)).join("")+"</accessor></technique_common></source>"}function c(e){let t=f.get(e);if(!t){const n=function(e){const t=["position","normal","color","tangent","uv","uv1","uv2","uv3"];for(const r of t)if(e.attributes[r]&&e.attributes[r].isInterleavedBufferAttribute){if(e.attributes[r].data&&e.attributes[r].data.array){let t=l(e,r);e.deleteAttribute(r),e.setAttribute(r,t)}}else if(e.attributes[r]){const t=e.attributes[r].itemSize,a=e.attributes[r].array;let i=Array(a.length);for(let e=0,t=a.length;e<t;e++)i[e]=isNaN(a[e])?0:a[e];e.deleteAttribute(r),e.setAttribute(r,new BufferAttribute(new Float32Array(i),t))}return e}(e.clone());if(!0!==n.isBufferGeometry)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const s=`Mesh${g.length+1}`,o=n.index?n.index.count*n.index.itemSize:n.attributes.position.count,c=null!=n.groups&&0!==n.groups.length?n.groups:[{start:0,count:o,materialIndex:0}];let m=`<geometry id="${s}"${e.name?` name="${e.name}"`:""}><mesh>`;const p=`${s}-position`,d=`${s}-vertices`;m+=u(n.attributes.position,p,["X","Y","Z"],"float"),m+=`<vertices id="${d}"><input semantic="POSITION" source="#${p}" /></vertices>`;let $=`<input semantic="VERTEX" source="#${d}" offset="0" />`;if("normal"in n.attributes){const e=`${s}-normal`;m+=u(n.attributes.normal,e,["X","Y","Z"],"float"),$+=`<input semantic="NORMAL" source="#${e}" offset="0" />`}if("uv"in n.attributes){const e=`${s}-texcoord`;m+=u(n.attributes.uv,e,["S","T"],"float"),$+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="0" />`}if("uv1"in n.attributes){const e=`${s}-texcoord2`;m+=u(n.attributes.uv1,e,["S","T"],"float"),$+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="1" />`}if("color"in n.attributes){const e=`${s}-color`;m+=u(n.attributes.color,e,["R","G","B"],"float"),$+=`<input semantic="COLOR" source="#${e}" offset="0" />`}let h=null;if(n.index)h=n.index.array;else{h=new Array(o);for(let e=0,t=h.length;e<t;e++)h[e]=e}for(let e=0,t=c.length;e<t;e++){const t=c[e],n=(r=h,a=t.start,i=t.count,Array.isArray(r)?r.slice(a,a+i):new r.constructor(r.buffer,a*r.BYTES_PER_ELEMENT,i)),s=n.length/3;m+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${s}">`,m+=$,m+=`<p>${n.join(" ")}</p>`,m+="</triangles>"}m+="</mesh></geometry>",g.push(m),t={meshid:s,bufferGeometry:n},f.set(e,t)}var r,a,i;return t}function m(e){!0===e.isCompressedTexture&&(e=decompress(e.clone()));let t=d.get(e);if(null==t){t=`image-${h.length+1}`;const i="png",n=(e.name&&(e.name.toUpperCase().endsWith(".PNG")||e.name.toUpperCase().endsWith(".JPG"))?e.name.substring(0,e.name.lastIndexOf(".")):e.name)||t;let s=`<image id="${t}" name="${n}">`;s+="1.5.0"===a?`<init_from><ref>${r.textureDirectory}${n}.${i}</ref></init_from>`:`<init_from>${r.textureDirectory}${n}.${i}</init_from>`,s+="</image>",h.push(s),d.set(e,t),$.push({directory:r.textureDirectory,name:n,ext:i,data:o(e.image,i),original:e})}return t}const f=new WeakMap,p=new WeakMap,d=new WeakMap,$=[],h=[],g=[],y=[],b=[],_=function e(t){let r=`<node name="${t.name}">`;if(r+=function(e){return e.updateMatrix(),s=s||new Matrix4,s.copy(e.matrix),s.transpose(),`<matrix>${s.toArray().join(" ")}</matrix>`}(t),(!0===t.isMesh||!0===t.isPoints)&&t.geometry){const e=c(t.geometry.clone()),a=e.meshid,i=e.bufferGeometry;let n,s=null;const o=t.material?t.material:new MeshBasicMaterial,l=Array.isArray(o)?o:[o];n=i.groups.length>l.length?new Array(i.groups.length):new Array(l.length),s=n.fill().map(((e,t)=>function(e){let t=p.get(e);if(null==t){t=`Mat${y.length+1}`;let r="phong";!0===e.isMeshLambertMaterial?r="lambert":!0===e.isPointsMaterial?r="points":!0===e.isMeshBasicMaterial&&(r="constant",e.map);const a=e.emissive?e.emissive.clone():new Color(0,0,0),i=e.color?e.color.clone():new Color(0,0,0),n=e.specular?e.specular.clone():new Color(1,1,1),s=e.shininess||0,o=e.reflectivity||0;let l="";!0===e.transparent&&(l+="<transparency>"+(e.opacity<1?`<float sid="transparency">${e.opacity}</float>`:'<float sid="transparency">1</float>')+"</transparency>");const u=`<technique sid="common"><${r}><emission>`+(e.emissiveMap?`<texture texture="emissive-sampler" texcoord="TEXCOORD" /><color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`:`<color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`)+"</emission>"+("constant"!==r?"<diffuse>"+(e.map?`<texture texture="diffuse-sampler" texcoord="TEXCOORD" /><color sid="diffuse">${i.r} ${i.g} ${i.b} 1</color>`:`<color sid="diffuse">${i.r} ${i.g} ${i.b} 1</color>`)+"</diffuse>":"")+("constant"!==r?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===r?"<specular>"+(e.specularMap?`<texture texture="specular-sampler" texcoord="TEXCOORD" /><color sid="specular">${n.r} ${n.g} ${n.b} 1</color>`:`<color sid="specular">${n.r} ${n.g} ${n.b} 1</color>`)+"</specular>":"")+`<shininess><float>${s}</float></shininess>`+`<reflective><color>${i.r} ${i.g} ${i.b} 1</color></reflective>`+`<reflectivity><float>${o}</float></reflectivity>`+l+`</${r}></technique>`,c=`<effect id="${t}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${m(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${m(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${m(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${m(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+u+(e.side===DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",f=`<material id="${t}"${e.name?` name="${e.name}"`:""}><instance_effect url="#${t}-effect" /></material>`;b.push(f),y.push(c),p.set(e,t)}return t}(l[t%l.length]))),r+=`<instance_geometry url="#${a}">`+(s.length>0?"<bind_material><technique_common>"+s.map(((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`)).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return t.children.forEach((t=>r+=e(t))),r+="</node>",r}(e);let x=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===a?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${a}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==r.author?`<author>${r.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified>`+(null!==r.unitName?`<unit name="${r.unitName}" meter="${r.unitMeter}" />`:"")+`<up_axis>${r.upAxis}</up_axis></asset>`;x+=`<library_images>${h.join("")}</library_images>`,x+=`<library_effects>${y.join("")}</library_effects>`,x+=`<library_materials>${b.join("")}</library_materials>`,x+=`<library_geometries>${g.join("")}</library_geometries>`,x+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${_}</visual_scene></library_visual_scenes>`,x+='<scene><instance_visual_scene url="#Scene"/></scene>',x+="</COLLADA>";const w={data:function(e){const t=/^<\//,r=/(\?>$)|(\/>$)/,a=/<[^>]+>[^<]*<\/[^<]+>/,i=(e,t)=>t>0?e+i(e,t-1):"";let n=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map((e=>{a.test(e)||r.test(e)||!t.test(e)||n--;const s=`${i("  ",n)}${e}`;return a.test(e)||r.test(e)||t.test(e)||n++,s})).join("\n")}(x),textures:$};return"function"==typeof t&&requestAnimationFrame((()=>t(w))),w}}export{ColladaExporter};