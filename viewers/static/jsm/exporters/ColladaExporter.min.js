import{Color,BufferAttribute,DefaultLoadingManager,DoubleSide,InterleavedBufferAttribute,Matrix4,MeshBasicMaterial}from"three";import{deinterleaveAttribute}from"three/addons/utils/BufferGeometryUtils.min.js";async function import_decompress(){try{const{WebGLRenderer:e}=await import("three"),{decompress:t}=await import("three/addons/utils/TextureUtils.min.js");return{decompress:t,renderer:new e({antialias:!0})}}catch(e){}try{const{CanvasTexture:e,NodeMaterial:t,QuadMesh:r,WebGPURenderer:a,texture:n,uv:i}=await import("three"),s=new a({antialias:!0});await s.init();const o=new r;return{decompress:function(r,a=1/0,s=null){const l=r.clone();0===l.offset.x&&0===l.offset.y&&1===l.repeat.x&&1===l.repeat.y||(l.offset.set(0,0),l.repeat.set(1,1));const u=new t;u.fragmentNode=n(l).uv(i().flipY());const c=Math.min(l.image.width,a),m=Math.min(l.image.height,a);s.setSize(c,m),s.outputColorSpace=l.colorSpace,o.material=u,o.render(s);const f=document.createElement("canvas"),p=f.getContext("2d");f.width=c,f.height=m,p.drawImage(s.domElement,0,0,c,m);const d=new e(f);return d.offset.set(r.offset.x,r.offset.y),d.repeat.set(r.repeat.x,r.repeat.y),d.colorSpace=r.colorSpace,d.minFilter=r.minFilter,d.magFilter=r.magFilter,d.wrapS=r.wrapS,d.wrapT=r.wrapT,d.name=r.name,l.dispose(),d},renderer:s}}catch(e){throw new Error("THREE.OBJExporter: Could not import decompress function!")}}class ColladaExporter{constructor(e){this.manager=e||DefaultLoadingManager,this.decompress=null,this.renderer=null}async parse(e,t,r={}){const a=this,{decompress:n,renderer:i}=await import_decompress();if(a.decompress=n,a.renderer=i,null===(r=Object.assign({version:"1.4.1",author:null,textureDirectory:"",upAxis:"Y_UP",unitName:null,unitMeter:null},r)).upAxis.match(/^[XYZ]_UP$/))return null;if(null!==r.unitName&&null===r.unitMeter)return null;if(null!==r.unitMeter&&null===r.unitName)return null;""!==r.textureDirectory&&(r.textureDirectory=`${r.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const s=r.version;if("1.4.1"!==s&&"1.5.0"!==s)return null;let o,l,u;function c(e,t){if(o=o||document.createElement("canvas"),l=l||o.getContext("2d"),o.width=e.width,o.height=e.height,e instanceof ImageData)l.putImageData(e,0,0);else if(e.data&&e.data.constructor===Uint8Array){let t=new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);l.putImageData(t,0,0)}else l.drawImage(e,0,0,o.width,o.height);return function(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0,a=r.length;e<a;e++)r[e]=t.charCodeAt(e);return r}(o.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,""))}function m(e,t="color"){const r=e.attributes[t],a=r.itemSize,n=r.offset,i=r.data;if(void 0===i)return[];let s=new InterleavedBufferAttribute(i,a,n),o=deinterleaveAttribute(s),l=Array(o.array.length);for(let e=0,t=o.array.length;e<t;e++)l[e]=isNaN(o.array[e])?0:o.array[e];return new BufferAttribute(new Float32Array(l),a)}function f(e,t,r,a){const n=e.array;return`<source id="${t}"><float_array id="${t}-array" count="${n.length}">`+n.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(n.length/e.itemSize)}" stride="${e.itemSize}">`+r.map((e=>`<param name="${e}" type="${a}" />`)).join("")+"</accessor></technique_common></source>"}function p(e){let t=h.get(e);if(!t){const i=function(e){const t=["position","normal","color","tangent","uv","uv1","uv2","uv3"];for(const r of t)if(e.attributes[r]&&e.attributes[r].isInterleavedBufferAttribute){if(e.attributes[r].data&&e.attributes[r].data.array){let t=m(e,r);e.deleteAttribute(r),e.setAttribute(r,t)}}else if(e.attributes[r]){const t=e.attributes[r].itemSize,a=e.attributes[r].array;let n=Array(a.length);for(let e=0,t=a.length;e<t;e++)n[e]=isNaN(a[e])?0:a[e];e.deleteAttribute(r),e.setAttribute(r,new BufferAttribute(new Float32Array(n),t))}return e}(e.clone());if(!0!==i.isBufferGeometry)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const s=`Mesh${w.length+1}`,o=i.index?i.index.count*i.index.itemSize:i.attributes.position.count,l=null!=i.groups&&0!==i.groups.length?i.groups:[{start:0,count:o,materialIndex:0}];let u=`<geometry id="${s}"${e.name?` name="${e.name}"`:""}><mesh>`;const c=`${s}-position`,p=`${s}-vertices`;u+=f(i.attributes.position,c,["X","Y","Z"],"float"),u+=`<vertices id="${p}"><input semantic="POSITION" source="#${c}" /></vertices>`;let d=`<input semantic="VERTEX" source="#${p}" offset="0" />`;if("normal"in i.attributes){const e=`${s}-normal`;u+=f(i.attributes.normal,e,["X","Y","Z"],"float"),d+=`<input semantic="NORMAL" source="#${e}" offset="0" />`}if("uv"in i.attributes){const e=`${s}-texcoord`;u+=f(i.attributes.uv,e,["S","T"],"float"),d+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="0" />`}if("uv1"in i.attributes){const e=`${s}-texcoord2`;u+=f(i.attributes.uv1,e,["S","T"],"float"),d+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="1" />`}if("color"in i.attributes){const e=`${s}-color`;u+=f(i.attributes.color,e,["R","G","B"],"float"),d+=`<input semantic="COLOR" source="#${e}" offset="0" />`}let g=null;if(i.index)g=i.index.array;else{g=new Array(o);for(let e=0,t=g.length;e<t;e++)g[e]=e}for(let e=0,t=l.length;e<t;e++){const t=l[e],i=(r=g,a=t.start,n=t.count,Array.isArray(r)?r.slice(a,a+n):new r.constructor(r.buffer,a*r.BYTES_PER_ELEMENT,n)),s=i.length/3;u+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${s}">`,u+=d,u+=`<p>${i.join(" ")}</p>`,u+="</triangles>"}u+="</mesh></geometry>",w.push(u),t={meshid:s,bufferGeometry:i},h.set(e,t)}var r,a,n;return t}function d(e){!0===e.isCompressedTexture&&(e=a.decompress(e.clone(),1/0,a.renderer));let t=$.get(e);if(null==t){t=`image-${b.length+1}`;const a="png",n=(e.name&&(e.name.toUpperCase().endsWith(".PNG")||e.name.toUpperCase().endsWith(".JPG"))?e.name.substring(0,e.name.lastIndexOf(".")):e.name)||t;let i=`<image id="${t}" name="${n}">`;i+="1.5.0"===s?`<init_from><ref>${r.textureDirectory}${n}.${a}</ref></init_from>`:`<init_from>${r.textureDirectory}${n}.${a}</init_from>`,i+="</image>",b.push(i),$.set(e,t),y.push({directory:r.textureDirectory,name:n,ext:a,data:c(e.image,a),original:e})}return t}const h=new WeakMap,g=new WeakMap,$=new WeakMap,y=[],b=[],w=[],_=[],x=[],M=function e(t){let r=`<node name="${t.name}">`;if(r+=function(e){return e.updateMatrix(),u=u||new Matrix4,u.copy(e.matrix),u.transpose(),`<matrix>${u.toArray().join(" ")}</matrix>`}(t),(!0===t.isMesh||!0===t.isPoints)&&t.geometry){const e=p(t.geometry.clone()),a=e.meshid,n=e.bufferGeometry;let i,s=null;const o=t.material?t.material:new MeshBasicMaterial,l=Array.isArray(o)?o:[o];i=n.groups.length>l.length?new Array(n.groups.length):new Array(l.length),s=i.fill().map(((e,t)=>function(e){let t=g.get(e);if(null==t){t=`Mat${_.length+1}`;let r="phong";!0===e.isMeshLambertMaterial?r="lambert":!0===e.isPointsMaterial?r="points":!0===e.isMeshBasicMaterial&&(r="constant",e.map);const a=e.emissive?e.emissive.clone():new Color(0,0,0),n=e.color?e.color.clone():new Color(0,0,0),i=e.specular?e.specular.clone():new Color(1,1,1),s=e.shininess||0,o=e.reflectivity||0;let l="";!0===e.transparent&&(l+="<transparency>"+(e.opacity<1?`<float sid="transparency">${e.opacity}</float>`:'<float sid="transparency">1</float>')+"</transparency>");const u=`<technique sid="common"><${r}><emission>`+(e.emissiveMap?`<texture texture="emissive-sampler" texcoord="TEXCOORD" /><color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`:`<color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`)+"</emission>"+("constant"!==r?"<diffuse>"+(e.map?`<texture texture="diffuse-sampler" texcoord="TEXCOORD" /><color sid="diffuse">${n.r} ${n.g} ${n.b} 1</color>`:`<color sid="diffuse">${n.r} ${n.g} ${n.b} 1</color>`)+"</diffuse>":"")+("constant"!==r?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===r?"<specular>"+(e.specularMap?`<texture texture="specular-sampler" texcoord="TEXCOORD" /><color sid="specular">${i.r} ${i.g} ${i.b} 1</color>`:`<color sid="specular">${i.r} ${i.g} ${i.b} 1</color>`)+"</specular>":"")+`<shininess><float>${s}</float></shininess>`+`<reflective><color>${n.r} ${n.g} ${n.b} 1</color></reflective>`+`<reflectivity><float>${o}</float></reflectivity>`+l+`</${r}></technique>`,c=`<effect id="${t}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${d(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${d(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${d(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${d(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+u+(e.side===DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",m=`<material id="${t}"${e.name?` name="${e.name}"`:""}><instance_effect url="#${t}-effect" /></material>`;x.push(m),_.push(c),g.set(e,t)}return t}(l[t%l.length]))),r+=`<instance_geometry url="#${a}">`+(s.length>0?"<bind_material><technique_common>"+s.map(((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`)).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return t.children.forEach((t=>r+=e(t))),r+="</node>",r}(e);let v=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===s?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${s}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==r.author?`<author>${r.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified>`+(null!==r.unitName?`<unit name="${r.unitName}" meter="${r.unitMeter}" />`:"")+`<up_axis>${r.upAxis}</up_axis></asset>`;v+=`<library_images>${b.join("")}</library_images>`,v+=`<library_effects>${_.join("")}</library_effects>`,v+=`<library_materials>${x.join("")}</library_materials>`,v+=`<library_geometries>${w.join("")}</library_geometries>`,v+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${M}</visual_scene></library_visual_scenes>`,v+='<scene><instance_visual_scene url="#Scene"/></scene>',v+="</COLLADA>";const A={data:function(e){const t=/^<\//,r=/(\?>$)|(\/>$)/,a=/<[^>]+>[^<]*<\/[^<]+>/,n=(e,t)=>t>0?e+n(e,t-1):"";let i=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map((e=>{a.test(e)||r.test(e)||!t.test(e)||i--;const s=`${n("  ",i)}${e}`;return a.test(e)||r.test(e)||t.test(e)||i++,s})).join("\n")}(v),textures:y};return null!==a.renderer&&(a.renderer.dispose(),a.renderer=null),"function"==typeof t&&requestAnimationFrame((()=>t(A))),A}}export{ColladaExporter};