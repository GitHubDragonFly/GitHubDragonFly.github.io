import{BufferAttribute,DefaultLoadingManager,InterleavedBufferAttribute,Matrix4,Quaternion,Vector3}from"three";import{strToU8,zipSync}from"three/addons/libs/fflate.module.min.js";import{deinterleaveAttribute,mergeVertices}from"three/addons/utils/BufferGeometryUtils.min.js";class AMFExporter{constructor(e){this.manager=e||DefaultLoadingManager}parse(e,t,r,a={}){this.parseAsync(e,a).then(t).catch(r)}async parseAsync(e,t={}){e.updateMatrixWorld(!0,!0),t=Object.assign({filename:"Model"},t);let r=new Date,a=r.toString().split(" ")[0]+" "+r.toLocaleDateString(),n='<?xml version="1.0" encoding="UTF-8"?>\n';n+='<amf unit="millimeter" version="1.1">\n',n+=' <metadata type="name">'+t.filename+"</metadata>\n",n+=' <metadata type="application">Custom AMF Exporter</metadata>\n',n+=' <metadata type="author">GitHubDragonFly</metadata>\n',n+=' <metadata type="date">'+a+"</metadata>\n",n+=await this.createResourcesString(e),n+="</amf>\n";const i={};return i[t.filename+".amf"]=await strToU8(n),zipSync(i,{level:8})}async createResourcesString(e){let t="",r=' <object id="0">\n';return e.traverse((e=>{if(!0===e.isMesh){r+="  <mesh>\n";let a=this.interleaved_buffer_attribute_check(e.geometry.clone()),n=e.material;const i=new Matrix4;i.copy(e.matrixWorld);const o=new Vector3,s=new Quaternion,l=new Vector3;i.decompose(o,s,l);const u=(new Matrix4).compose(o,s,l);let c;if(a.applyMatrix4(u),a.index||(a=mergeVertices(a,1e-6)),a.attributes.normal||a.computeVertexNormals(),a.normalizeNormals(),Array.isArray(n)&&a.groups.length===n.length)n.forEach(((e,n)=>{c=1===e.opacity&&!0===e.transparent?.99:e.opacity,r+=this.generateVertices(a,n),r+=this.generateTriangles(a,e,n);let i=""+e.color.r,o=""+e.color.g,s=""+e.color.b,l=""+c;t+=` <material id="${e.id}"><color><r>${i}</r><g>${o}</g><b>${s}</b><a>${l}</a></color></material>\n`}));else{c=1===n.opacity&&!0===n.transparent?.99:n.opacity,r+=this.generateVertices(a),r+=this.generateTriangles(a,n);let e=""+n.color.r,i=""+n.color.g,o=""+n.color.b,s=""+c;t+=` <material id="${n.id}"><color><r>${e}</r><g>${i}</g><b>${o}</b><a>${s}</a></color></material>\n`}r+="  </mesh>\n"}})),r+=" </object>\n",r+=t,r}generateVertices(e,t=null){const r=e.index.array,a=e.attributes.position.array;let n="   <vertices>\n";const i=null!==t&&void 0!==e.groups[t];let o=!0===i?e.groups[t].start:0,s=!0===i?e.groups[t].start+e.groups[t].count:a.length;if(s===1/0&&(s=r.length),!0===i)for(let e=o;e<s;e++){n+=`    <vertex><coordinates><x>${a[3*r[e]]}</x><y>${a[3*r[e]+1]}</y><z>${a[3*r[e]+2]}</z></coordinates></vertex>\n`}else for(let e=o;e<s;e+=3){n+=`    <vertex><coordinates><x>${a[e]}</x><y>${a[e+1]}</y><z>${a[e+2]}</z></coordinates></vertex>\n`}return n+="   </vertices>\n",n}generateTriangles(e,t,r=null){const a=e.index.array;let n='   <volume materialid="'+t.id+'">\n';const i=null!==r&&void 0!==e.groups[r];let o=!0===i?e.groups[r].start:0,s=!0===i?e.groups[r].start+e.groups[r].count:a.length;s===1/0&&(s=a.length);for(let e=o;e<s;e+=3){n+=`    <triangle><v1>${!0===i?e:a[e]}</v1><v2>${!0===i?e+1:a[e+1]}</v2><v3>${!0===i?e+2:a[e+2]}</v3></triangle>\n`}return n+="   </volume>\n",n}deinterleave(e,t="color"){const r=e.attributes[t],a=r.itemSize,n=r.offset,i=r.data;if(void 0===i)return[];let o=new InterleavedBufferAttribute(i,a,n),s=deinterleaveAttribute(o),l=Array(s.array.length);for(let e=0,t=s.array.length;e<t;e++)l[e]=isNaN(s.array[e])?0:s.array[e];return new BufferAttribute(new Float32Array(l),a)}interleaved_buffer_attribute_check(e){const t=["position","normal","color","tangent","uv","uv1","uv2","uv3"];for(const r of t)if(e.attributes[r]&&e.attributes[r].isInterleavedBufferAttribute){if(e.attributes[r].data&&e.attributes[r].data.array){let t=this.deinterleave(e,r);e.deleteAttribute(r),e.setAttribute(r,t)}}else if(e.attributes[r]&&e.attributes[r].array){const t=e.attributes[r].itemSize,a=e.attributes[r].array,n=Array(a.length);for(let e=0,t=a.length;e<t;e++)n[e]=isNaN(a[e])?0:a[e];e.deleteAttribute(r),e.setAttribute(r,new BufferAttribute(new Float32Array(n),t))}return e}}export{AMFExporter};