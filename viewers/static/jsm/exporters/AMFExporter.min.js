import{BufferAttribute,DefaultLoadingManager,InterleavedBufferAttribute,Matrix4,Quaternion,Vector3}from"three";import{strToU8,zipSync}from"three/addons/libs/fflate.module.min.js";import{deinterleaveAttribute,mergeVertices}from"three/addons/utils/BufferGeometryUtils.min.js";class AMFExporter{constructor(e){this.manager=e||DefaultLoadingManager}parse(e,t,r,a={}){this.parseAsync(e,a).then(t).catch(r)}async parseAsync(e,t={}){e.updateMatrixWorld(!0,!0),t=Object.assign({filename:"Model"},t);let r=new Date,a=r.toString().split(" ")[0]+" "+r.toLocaleDateString(),i='<?xml version="1.0" encoding="UTF-8"?>\n';i+='<amf unit="millimeter" version="1.1">\n',i+=' <metadata type="name">'+t.filename+"</metadata>\n",i+=' <metadata type="application">Custom AMF Exporter</metadata>\n',i+=' <metadata type="author">GitHubDragonFly</metadata>\n',i+=' <metadata type="date">'+a+"</metadata>\n",i+=await this.createResourcesString(e),i+="</amf>\n";const n={};return n[t.filename+".amf"]=await strToU8(i),zipSync(n,{level:8})}async createResourcesString(e){let t="",r=' <object id="0">\n';return e.traverse((e=>{if(!0===e.isMesh){r+="  <mesh>\n";let a=this.interleaved_buffer_attribute_check(e.geometry.clone()),i=e.material;const n=new Matrix4;n.copy(e.matrixWorld);const o=new Vector3,s=new Quaternion,l=new Vector3;n.decompose(o,s,l);const u=(new Matrix4).compose(o,s,l);if(a.applyMatrix4(u),a.index||(a=mergeVertices(a,1e-6)),a.attributes.normal||a.computeVertexNormals(),a.normalizeNormals(),Array.isArray(i)&&a.groups.length===i.length)i.forEach(((e,i)=>{r+=this.generateVertices(a,i),r+=this.generateTriangles(a,e,i);let n=""+e.color.r,o=""+e.color.g,s=""+e.color.b,l=""+e.opacity;t+=` <material id="${e.id}"><color><r>${n}</r><g>${o}</g><b>${s}</b><a>${l}</a></color></material>\n`}));else{r+=this.generateVertices(a),r+=this.generateTriangles(a,i);let e=""+i.color.r,n=""+i.color.g,o=""+i.color.b,s=""+i.opacity;t+=` <material id="${i.id}"><color><r>${e}</r><g>${n}</g><b>${o}</b><a>${s}</a></color></material>\n`}r+="  </mesh>\n"}})),r+=" </object>\n",r+=t,r}generateVertices(e,t=null){const r=e.index.array,a=e.attributes.position.array;let i="   <vertices>\n",n=t&&e.groups[t]?e.groups[t].start:0,o=t&&e.groups[t]?e.groups[t].start+e.groups[t].count:a.length;if(o===1/0&&(o=r.length),t&&e.groups[t])for(let e=n;e<o;e++){i+=`    <vertex><coordinates><x>${a[3*r[e]]}</x><y>${a[3*r[e]+1]}</y><z>${a[3*r[e]+2]}</z></coordinates></vertex>\n`}else for(let e=n;e<o;e+=3){i+=`    <vertex><coordinates><x>${a[e]}</x><y>${a[e+1]}</y><z>${a[e+2]}</z></coordinates></vertex>\n`}return i+="   </vertices>\n",i}generateTriangles(e,t,r=null){const a=e.index.array;let i='   <volume materialid="'+t.id+'">\n',n=r&&e.groups[r]?e.groups[r].start:0,o=r&&e.groups[r]?e.groups[r].start+e.groups[r].count:a.length;o===1/0&&(o=a.length);for(let t=n;t<o;t+=3){i+=`    <triangle><v1>${r&&e.groups[r]?t:a[t]}</v1><v2>${r&&e.groups[r]?t+1:a[t+1]}</v2><v3>${r&&e.groups[r]?t+2:a[t+2]}</v3></triangle>\n`}return i+="   </volume>\n",i}deinterleave(e,t="color"){const r=e.attributes[t],a=r.itemSize,i=r.offset,n=r.data;if(void 0===n)return[];let o=new InterleavedBufferAttribute(n,a,i),s=deinterleaveAttribute(o),l=Array(s.array.length);for(let e=0,t=s.array.length;e<t;e++)l[e]=isNaN(s.array[e])?0:s.array[e];return new BufferAttribute(new Float32Array(l),a)}interleaved_buffer_attribute_check(e){const t=["position","normal","color","tangent","uv","uv1","uv2","uv3"];for(const r of t)if(e.attributes[r]&&e.attributes[r].isInterleavedBufferAttribute){if(e.attributes[r].data&&e.attributes[r].data.array){let t=this.deinterleave(e,r);e.deleteAttribute(r),e.setAttribute(r,t)}}else if(e.attributes[r]&&e.attributes[r].array){const t=e.attributes[r].itemSize,a=e.attributes[r].array,i=Array(a.length);for(let e=0,t=a.length;e<t;e++)i[e]=isNaN(a[e])?0:a[e];e.deleteAttribute(r),e.setAttribute(r,new BufferAttribute(new Float32Array(i),t))}return e}}export{AMFExporter};