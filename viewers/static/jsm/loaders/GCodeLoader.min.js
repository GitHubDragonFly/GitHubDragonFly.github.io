import{BufferGeometry,Euler,FileLoader,Float32BufferAttribute,Group,LineBasicMaterial,LineSegments,Line,Loader,SplineCurve,Vector2}from"three";class GCodeLoader extends Loader{constructor(e){super(e),this.splitLayer=!1}load(e,t,r,o){const i=this,n=new FileLoader(i.manager);n.setResponseType("text"),n.setRequestHeader(i.requestHeader),n.setWithCredentials(i.withCredentials),n.load(e,function(r){try{(r=r.replace(/\r\n/g,"\n").replace(/\r/g,"\n")).endsWith("\n")||(r+="\n");const n=r.split("\n").map(e=>e.replace(/;.*$/,"").trim());if(r.startsWith("version https://git-lfs.github.com/spec"))return alert("The selected file is stored in Git LFS!"),o?void o("The selected file is stored in Git LFS!"):void console.error("The selected file is stored in Git LFS!");const s=i.parse(n);t(s)}catch(t){o?o(t):console.error(t),i.manager.itemError(e)}},r,o)}parse(e){let t,r={x:0,y:0,z:0,e:0,f:0,i:0,j:0,extruding:!1,relative:!1};const o=[];let i=void 0;const n=new LineBasicMaterial({color:10818837});n.name="path";const s=new LineBasicMaterial({color:1418517});s.name="extruded";const a=new Group;function l(e){i={vertex:[],pathVertex:[],z:e.z},o.push(i)}function d(e,t){void 0===i&&l(e),r.extruding?(i.vertex.push(e.x,e.y,e.z),i.vertex.push(t.x,t.y,t.z)):(i.pathVertex.push(e.x,e.y,e.z),i.pathVertex.push(t.x,t.y,t.z))}function c(e,t){return r.relative?t:t-e}function f(e,t){return r.relative?e+t:t}a.name="gcode";const u=/(([XxYyZz]) *(-?\d+.?\d*)) *(([XxYyZz]) *(-?\d+.?\d*))? *(([XxYyZz]) *(-?\d+.?\d*))?/g;for(const o of e){const e=o.split(" ");t=e[0].toUpperCase();const n={};if(e.splice(0).forEach(function(e){if(void 0!==e[0]){const t=e[0].toLowerCase(),r=parseFloat(e.substring(1));n[t]=r}}),"G00"===t||"G0"===t||"G01"===t||"G1"===t||u.test(t)){const e={x:void 0!==n.x?f(r.x,n.x):r.x,y:void 0!==n.y?f(r.y,n.y):r.y,z:void 0!==n.z?f(r.z,n.z):r.z,e:void 0!==n.e?f(r.e,n.e):r.e,f:void 0!==n.f?f(r.f,n.f):r.f};c(r.e,e.e)>0&&(r.extruding=!0,null!=i&&e.z==i.z||l(e)),d(r,e),r=e}else if("G02"===t||"G2"===t||"G03"===t||"G3"===t){const e={x:void 0!==n.x?f(r.x,n.x):r.x,y:void 0!==n.y?f(r.y,n.y):r.y,z:void 0!==n.z?f(r.z,n.z):r.z,i:void 0!==n.i?f(r.i,n.i):r.i,j:void 0!==n.j?f(r.j,n.j):r.j,e:void 0!==n.e?f(r.e,n.e):r.e,f:void 0!==n.f?f(r.f,n.f):r.f};c(r.e,e.e)>0&&(r.extruding=!0,null!=i&&e.z==i.z||l(e)),d(r,e),r=e}else if("G90"===t)r.relative=!1;else if("G91"===t)r.relative=!0;else if("G92"===t){const e=r;e.x=void 0!==n.x?n.x:e.x,e.y=void 0!==n.y?n.y:e.y,e.z=void 0!==n.z?n.z:e.z,e.e=void 0!==n.e?n.e:e.e,r=e}}function x(e,t,o,i){if("G02"!=i||"G03"!=i||"G2"!=i||"G3"!=i){const r=new BufferGeometry;r.setAttribute("position",new Float32BufferAttribute(e,3));const i=new LineSegments(r,t?s:n);i.name="layer"+o,a.add(i)}else{const e=new SplineCurve([new Vector2(r.x,r.y),new Vector2(args.x,args.y)]).getPoints(50),i=(new BufferGeometry).setFromPoints(e),l=new Line(i,t?s:n);l.name="layer"+o,a.add(l)}}if(this.splitLayer)for(let e=0;e<o.length;e++){const r=o[e];x(r.vertex,!0,e,t),x(r.pathVertex,!1,e,t)}else{const e=[],r=[];for(const t of o){const o=t.vertex,i=t.pathVertex;for(let t=0;t<o.length;t++)e.push(o[t]);for(let e=0;e<i.length;e++)r.push(i[e])}x(e,!0,o.length,t),x(r,!1,o.length,t)}return a.quaternion.setFromEuler(new Euler(-Math.PI/2,0,0)),a}}export{GCodeLoader};