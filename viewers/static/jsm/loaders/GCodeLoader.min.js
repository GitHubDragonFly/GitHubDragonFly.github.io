import{BufferGeometry,Euler,FileLoader,Float32BufferAttribute,Group,LineBasicMaterial,LineSegments,Line,Loader,SplineCurve,Vector2}from"three";class GCodeLoader extends Loader{constructor(e){super(e),this.splitLayer=!1}load(e,t,r,o){const n=this,i=new FileLoader(n.manager);i.setPath(n.path),i.setRequestHeader(n.requestHeader),i.setWithCredentials(n.withCredentials),i.load(e,(function(r){try{t(n.parse(r))}catch(t){o&&o(t),n.manager.itemError(e)}}),r,o)}parse(e){let t={x:0,y:0,z:0,e:0,f:0,i:0,j:0,extruding:!1,relative:!1};const r=[];let o;const n=new LineBasicMaterial({color:10818837});n.name="path";const i=new LineBasicMaterial({color:1418517});function s(e){o={vertex:[],pathVertex:[],z:e.z},r.push(o)}function a(e,r){void 0===o&&s(e),t.extruding?(o.vertex.push(e.x,e.y,e.z),o.vertex.push(r.x,r.y,r.z)):(o.pathVertex.push(e.x,e.y,e.z),o.pathVertex.push(r.x,r.y,r.z))}function l(e,r){return t.relative?r:r-e}function d(e,r){return t.relative?e+r:r}let u;i.name="extruded";const f=e.replace(/;.+/g,"").split("\n");for(let e=0;e<f.length;e++){const r=f[e].split(" ");u=r[0].toUpperCase();const n={};if(r.splice(0).forEach((function(e){if(void 0!==e[0]){const t=e[0].toLowerCase(),r=parseFloat(e.substring(1));n[t]=r}})),"G00"===u||"G0"===u||"G01"===u||"G1"===u||/(([XxYyZz]) *(-?\d+.?\d*)) *(([XxYyZz]) *(-?\d+.?\d*))? *(([XxYyZz]) *(-?\d+.?\d*))?/g.test(u)){const e={x:void 0!==n.x?d(t.x,n.x):t.x,y:void 0!==n.y?d(t.y,n.y):t.y,z:void 0!==n.z?d(t.z,n.z):t.z,e:void 0!==n.e?d(t.e,n.e):t.e,f:void 0!==n.f?d(t.f,n.f):t.f};l(t.e,e.e)>0&&(t.extruding=l(t.e,e.e)>0,null!=o&&e.z==o.z||s(e)),a(t,e),t=e}else if("G02"===u||"G2"===u||"G03"===u||"G3"===u){const e={x:void 0!==n.x?d(t.x,n.x):t.x,y:void 0!==n.y?d(t.y,n.y):t.y,z:void 0!==n.z?d(t.z,n.z):t.z,i:void 0!==n.i?d(t.i,n.i):t.i,j:void 0!==n.j?d(t.j,n.j):t.j,e:void 0!==n.e?d(t.e,n.e):t.e,f:void 0!==n.f?d(t.f,n.f):t.f};l(t.e,e.e)>0&&(t.extruding=l(t.e,e.e)>0,null!=o&&e.z==o.z||s(e)),a(t,e),t=e}else if("G90"===u)t.relative=!1;else if("G91"===u)t.relative=!0;else if("G92"===u){const e=t;e.x=void 0!==n.x?n.x:e.x,e.y=void 0!==n.y?n.y:e.y,e.z=void 0!==n.z?n.z:e.z,e.e=void 0!==n.e?n.e:e.e,t=e}}function c(e,r,o,s){if("G02"!=s||"G03"!=s||"G2"!=s||"G3"!=s){const t=new BufferGeometry;t.setAttribute("position",new Float32BufferAttribute(e,3));const s=new LineSegments(t,r?i:n);s.name="layer"+o,x.add(s)}else{const e=new SplineCurve([new Vector2(t.x,t.y),new Vector2(args.x,args.y)]).getPoints(50),s=(new BufferGeometry).setFromPoints(e),a=new Line(s,r?i:n);a.name="layer"+o,x.add(a)}}const x=new Group;if(x.name="gcode",this.splitLayer)for(let e=0;e<r.length;e++){const t=r[e];c(t.vertex,!0,e,u),c(t.pathVertex,!1,e,u)}else{const e=[],t=[];for(let o=0;o<r.length;o++){const n=r[o],i=n.vertex,s=n.pathVertex;for(let t=0;t<i.length;t++)e.push(i[t]);for(let e=0;e<s.length;e++)t.push(s[e])}c(e,!0,r.length,u),c(t,!1,r.length,u)}return x.quaternion.setFromEuler(new Euler(-Math.PI/2,0,0)),x}}export{GCodeLoader};