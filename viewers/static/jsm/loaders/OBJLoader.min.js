import{BufferGeometry,FileLoader,Float32BufferAttribute,Group,LineBasicMaterial,LineSegments,Loader,Material,Mesh,MeshPhongMaterial,Points,PointsMaterial,Vector3,Color}from"three";const _object_pattern=/^[og]\s*(.+)?/,_material_library_pattern=/^mtllib /,_material_use_pattern=/^usemtl /,_map_use_pattern=/^usemap /,_face_vertex_data_separator_pattern=/\s+/,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_ab=new Vector3,_cb=new Vector3,_color=new Color;function ParserState(){let t=0;const e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],uvs1:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=!1!==e);const s=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:!1!==e,geometry:{vertices:[],normals:[],colors:[],uvs:[],uvs1:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,e){const s=this._finalize(!1);s&&(s.inherited||s.groupCount<=0)&&this.materials.splice(s.index,1);const o={index:this.materials.length,name:t||"",mtllib:Array.isArray(e)&&e.length>0?e[e.length-1]:"",smooth:void 0!==s?s.smooth:this.smooth,groupStart:void 0!==s?s.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(t){const e={index:"number"==typeof t?t:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return e.clone=this.clone.bind(e),e}};return this.materials.push(o),o},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const e=this.currentMaterial();if(e&&-1===e.groupEnd&&(e.groupEnd=this.geometry.vertices.length/3,e.groupCount=e.groupEnd-e.groupStart,e.inherited=!1),t&&this.materials.length>1)for(let t=this.materials.length-1;t>=0;t--)this.materials[t].groupCount<=0&&this.materials.splice(t,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),e}},s&&s.name&&"function"==typeof s.clone){const t=s.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const s=parseInt(t,10);return 3*(s>=0?s-1:s+e/3)},parseNormalIndex:function(t,e){const s=parseInt(t,10);return 3*(s>=0?s-1:s+e/3)},parseUVIndex:function(t,e){const s=parseInt(t,10);return 2*(s>=0?s-1:s+e/2)},addVertex:function(t,e,s){const o=this.vertices,r=this.object.geometry.vertices;r.push(o[t+0],o[t+1],o[t+2]),r.push(o[e+0],o[e+1],o[e+2]),r.push(o[s+0],o[s+1],o[s+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,s){const o=this.normals,r=this.object.geometry.normals;r.push(o[t+0],o[t+1],o[t+2]),r.push(o[e+0],o[e+1],o[e+2]),r.push(o[s+0],o[s+1],o[s+2])},addFaceNormal:function(t,e,s){const o=this.vertices,r=this.object.geometry.normals;_vA.fromArray(o,t),_vB.fromArray(o,e),_vC.fromArray(o,s),_cb.subVectors(_vC,_vB),_ab.subVectors(_vA,_vB),_cb.cross(_ab),_cb.normalize(),r.push(_cb.x,_cb.y,_cb.z),r.push(_cb.x,_cb.y,_cb.z),r.push(_cb.x,_cb.y,_cb.z)},addColor:function(t,e,s){const o=this.colors,r=this.object.geometry.colors;void 0!==o[t]&&r.push(o[t+0],o[t+1],o[t+2]),void 0!==o[e]&&r.push(o[e+0],o[e+1],o[e+2]),void 0!==o[s]&&r.push(o[s+0],o[s+1],o[s+2])},addUV:function(e,s,o){const r=this.uvs,i=this.object.geometry.uvs;if(i.push(r[e+0],r[e+1]),i.push(r[s+0],r[s+1]),i.push(r[o+0],r[o+1]),this.uvs1.length>0){const e=this.uvs1,s=this.object.geometry.uvs1;s.push(e[t],e[t+1]),s.push(e[t+2],e[t+3]),s.push(e[t+4],e[t+5]),t+=6}},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,s,o,r,i,n,a,l){const c=this.vertices.length;let h=this.parseVertexIndex(t,c),u=this.parseVertexIndex(e,c),p=this.parseVertexIndex(s,c);if(this.addVertex(h,u,p),this.addColor(h,u,p),void 0!==n&&""!==n){const t=this.normals.length;h=this.parseNormalIndex(n,t),u=this.parseNormalIndex(a,t),p=this.parseNormalIndex(l,t),this.addNormal(h,u,p)}else this.addFaceNormal(h,u,p);if(void 0!==o&&""!==o){const t=this.uvs.length;h=this.parseUVIndex(o,t),u=this.parseUVIndex(r,t),p=this.parseUVIndex(i,t),this.addUV(h,u,p),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let s=0,o=t.length;s<o;s++){const o=this.parseVertexIndex(t[s],e);this.addVertexPoint(o),this.addColor(o)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const s=this.vertices.length,o=this.uvs.length;for(let e=0,o=t.length;e<o;e++){const o=this.parseVertexIndex(t[e],s);this.addVertexLine(o),this.addColor(o)}for(let t=0,s=e.length;t<s;t++)this.addUVLine(this.parseUVIndex(e[t],o))}};return e.startObject("",!1),e}class OBJLoader extends Loader{constructor(t){super(t),this.materials=null}load(t,e,s,o){const r=this,i=new FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(function(s){try{e(r.parse(s))}catch(e){o&&o(e),r.manager.itemError(t)}}),s,o)}setMaterials(t){return this.materials=t,this}parse(t){const e=new ParserState;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const s=t.split("\n");let o=[];for(let t=0,r=s.length;t<r;t++){const r=s[t].trimStart();if(0===r.length)continue;const i=r.charAt(0);if("#"!==i)if("v"===i){const t=r.split(_face_vertex_data_separator_pattern);switch(t[0]){case"v":e.vertices.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),t.length>=7?(_color.setRGB(parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6])).convertSRGBToLinear(),e.colors.push(_color.r,_color.g,_color.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":e.uvs.push(parseFloat(t[1]),parseFloat(t[2]));break;case"vt1":e.uvs1.push(parseFloat(t[1]),parseFloat(t[2]));break}}else if("f"===i){const t=r.slice(1).trim().split(_face_vertex_data_separator_pattern),s=[];for(let e=0,o=t.length;e<o;e++){const o=t[e];if(o.length>0){const t=o.split("/");s.push(t)}}const o=s[0];for(let t=1,r=s.length-1;t<r;t++){const r=s[t],i=s[t+1];e.addFace(o[0],r[0],i[0],o[1],r[1],i[1],o[2],r[2],i[2])}}else if("l"===i){const t=r.substring(1).trim().split(" ");let s=[];const o=[];if(-1===r.indexOf("/"))s=t;else for(let e=0,r=t.length;e<r;e++){const r=t[e].split("/");""!==r[0]&&s.push(r[0]),""!==r[1]&&o.push(r[1])}e.addLineGeometry(s,o)}else if("p"===i){const t=r.slice(1).trim().split(" ");e.addPointGeometry(t)}else if(null!==(o=_object_pattern.exec(r))){const t=(" "+o[0].slice(1).trim()).slice(1);e.startObject(t)}else if(_material_use_pattern.test(r))e.object.startMaterial(r.substring(7).trim(),e.materialLibraries);else if(_material_library_pattern.test(r))e.materialLibraries.push(r.substring(7).trim());else if(_map_use_pattern.test(r));else{if("s"!==i){if("\0"===r)continue;throw new Error('THREE.OBJLoader: Unexpected line: "'+r+'"')}{if(o=r.split(" "),o.length>1){const t=o[1].trim().toLowerCase();e.object.smooth="0"!==t&&"off"!==t}else e.object.smooth=!0;const t=e.object.currentMaterial();t&&(t.smooth=e.object.smooth)}}}e.finalize();const r=new Group;r.materialLibraries=[].concat(e.materialLibraries);if(!0===!(1===e.objects.length&&0===e.objects[0].geometry.vertices.length))for(let t=0,s=e.objects.length;t<s;t++){const s=e.objects[t],o=s.geometry,i=s.materials,n="Line"===o.type,a="Points"===o.type;let l=!1;if(0===o.vertices.length)continue;const c=new BufferGeometry;c.setAttribute("position",new Float32BufferAttribute(o.vertices,3)),o.normals.length>0&&c.setAttribute("normal",new Float32BufferAttribute(o.normals,3)),o.colors.length>0&&(l=!0,c.setAttribute("color",new Float32BufferAttribute(o.colors,3))),!0===o.hasUVIndices&&(c.setAttribute("uv",new Float32BufferAttribute(o.uvs,2)),o.uvs1.length>0&&c.setAttribute("uv1",new Float32BufferAttribute(o.uvs1,2)));const h=[];for(let t=0,s=i.length;t<s;t++){const s=i[t],o=s.name+"_"+s.smooth+"_"+l;let r=e.materials[o];if(null!==this.materials)if(r=this.materials.create(s.name),!n||!r||r instanceof LineBasicMaterial){if(a&&r&&!(r instanceof PointsMaterial)){const t=new PointsMaterial({size:10,sizeAttenuation:!1});Material.prototype.copy.call(t,r),t.color.copy(r.color),t.map=r.map,r=t}}else{const t=new LineBasicMaterial;Material.prototype.copy.call(t,r),t.color.copy(r.color),r=t}void 0===r&&(r=n?new LineBasicMaterial:a?new PointsMaterial({size:1,sizeAttenuation:!1}):new MeshPhongMaterial,r.name=s.name,r.flatShading=!s.smooth,r.vertexColors=l,e.materials[o]=r),h.push(r)}let u;if(h.length>1){for(let t=0,e=i.length;t<e;t++){const e=i[t];c.addGroup(e.groupStart,e.groupCount,t)}u=n?new LineSegments(c,h):a?new Points(c,h):new Mesh(c,h)}else u=n?new LineSegments(c,h[0]):a?new Points(c,h[0]):new Mesh(c,h[0]);u.name=s.name,r.add(u)}else if(e.vertices.length>0){const t=new PointsMaterial({size:1,sizeAttenuation:!1}),s=new BufferGeometry;s.setAttribute("position",new Float32BufferAttribute(e.vertices,3)),e.colors.length>0&&void 0!==e.colors[0]&&(s.setAttribute("color",new Float32BufferAttribute(e.colors,3)),t.vertexColors=!0);const o=new Points(s,t);r.add(o)}return r}}export{OBJLoader};