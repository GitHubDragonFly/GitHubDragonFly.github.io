import{BackSide,BoxGeometry,BufferAttribute,BufferGeometry,ClampToEdgeWrapping,Color,ConeGeometry,CylinderGeometry,DataTexture,DoubleSide,FileLoader,Float32BufferAttribute,FrontSide,Group,LineBasicMaterial,LineSegments,Loader,LoaderUtils,Mesh,MeshBasicMaterial,MeshPhongMaterial,Object3D,Points,PointsMaterial,Quaternion,RGBAFormat,RepeatWrapping,Scene,ShapeUtils,SphereGeometry,TextureLoader,Vector2,Vector3}from"three";class VRMLLoader extends Loader{constructor(e){if(super(e),"undefined"==typeof chevrotain)throw Error("THREE.VRMLLoader: External library chevrotain.min.js required.");this.loader=null,this.inlineNodes=[],this.local_ImageTextures=""}load(e,t,r,n,o){const a=this;""!==o&&(a.local_ImageTextures=o);const s=""===a.path?LoaderUtils.extractUrlBase(e):a.path;a.loader=new FileLoader(a.manager),a.loader.setPath(a.path),a.loader.setRequestHeader(a.requestHeader),a.loader.setWithCredentials(a.withCredentials),a.loader.load(e,(async function(r){try{t(await a.parse(r,s))}catch(t){n&&n(t),a.manager.itemError(e)}}),r,n)}async parse(e,t){const r=this,n={};function o(e){const t=function(){const e=chevrotain.createToken,t=e({name:"RouteIdentifier",pattern:/[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*[\.][^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/}),r=e({name:"Identifier",pattern:/[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]([^\0-\x20\x22\x27\x23\x2b\x2c\x2e\x5b\x5d\x5c\x7b\x7d])*/,longer_alt:t}),n=["Anchor","Billboard","Collision","Group","Transform","Inline","LOD","Switch","AudioClip","DirectionalLight","PointLight","Script","Shape","Sound","SpotLight","WorldInfo","CylinderSensor","PlaneSensor","ProximitySensor","SphereSensor","TimeSensor","TouchSensor","VisibilitySensor","Box","Cone","Cylinder","ElevationGrid","Extrusion","IndexedFaceSet","IndexedLineSet","PointSet","Sphere","Color","Coordinate","Normal","TextureCoordinate","Appearance","FontStyle","ImageTexture","Material","MovieTexture","PixelTexture","TextureTransform","ColorInterpolator","CoordinateInterpolator","NormalInterpolator","OrientationInterpolator","PositionInterpolator","ScalarInterpolator","Background","Fog","NavigationInfo","Viewpoint","Text"],o=e({name:"Version",pattern:/#VRML.*/,longer_alt:r}),a=e({name:"NodeName",pattern:new RegExp(n.join("|")),longer_alt:r}),s=e({name:"DEF",pattern:/DEF/,longer_alt:r}),i=e({name:"USE",pattern:/USE/,longer_alt:r}),l=e({name:"ROUTE",pattern:/ROUTE/,longer_alt:r}),c=e({name:"TO",pattern:/TO/,longer_alt:r}),u=e({name:"StringLiteral",pattern:/"(?:[^\\"\n\r]|\\[bfnrtv"\\/]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*"/}),f=e({name:"HexLiteral",pattern:/0[xX][0-9a-fA-F]+/}),d=e({name:"NumberLiteral",pattern:/[-+]?([0-9]+\.?[0-9]*|\.?[0-9]+)([eE][-+]?[0-9]+)?/}),h=e({name:"TrueLiteral",pattern:/TRUE/}),p=e({name:"FalseLiteral",pattern:/FALSE/}),b=e({name:"NullLiteral",pattern:/NULL/}),m=e({name:"LSquare",pattern:/\[/}),x=e({name:"RSquare",pattern:/]/}),g=e({name:"LCurly",pattern:/{/}),k=e({name:"RCurly",pattern:/}/}),y=e({name:"Comment",pattern:/#.*/,group:chevrotain.Lexer.SKIPPED}),E=[e({name:"WhiteSpace",pattern:/[ ,\s]/,group:chevrotain.Lexer.SKIPPED}),a,s,i,l,c,h,p,b,o,r,t,u,f,d,m,x,g,k,y],w={};for(let e=0,t=E.length;e<t;e++){const t=E[e];w[t.name]=t}return{tokens:E,tokenVocabulary:w}}(),r=new VRMLLexer(t.tokens),n=new VRMLParser(t.tokenVocabulary),o=function(e){function t(){e.call(this),this.validateVisitor()}function r(e,t){const r={type:null,values:[]};if(t.node){r.type="node";for(let n=0,o=t.node.length;n<o;n++){const o=t.node[n];r.values.push(e.visit(o))}}if(t.use){r.type="use";for(let n=0,o=t.use.length;n<o;n++){const o=t.use[n];r.values.push(e.visit(o))}}if(t.StringLiteral){r.type="string";for(let e=0,n=t.StringLiteral.length;e<n;e++){const n=t.StringLiteral[e];r.values.push(n.image.replace(/'|"/g,""))}}if(t.NumberLiteral){r.type="number";for(let e=0,n=t.NumberLiteral.length;e<n;e++){const n=t.NumberLiteral[e];r.values.push(parseFloat(n.image))}}if(t.HexLiteral){r.type="hex";for(let e=0,n=t.HexLiteral.length;e<n;e++){const n=t.HexLiteral[e];r.values.push(n.image)}}if(t.TrueLiteral){r.type="boolean";for(let e=0,n=t.TrueLiteral.length;e<n;e++){"TRUE"===t.TrueLiteral[e].image&&r.values.push(!0)}}if(t.FalseLiteral){r.type="boolean";for(let e=0,n=t.FalseLiteral.length;e<n;e++){"FALSE"===t.FalseLiteral[e].image&&r.values.push(!1)}}return t.NullLiteral&&(r.type="null",t.NullLiteral.forEach((function(){r.values.push(null)}))),r}return t.prototype=Object.assign(Object.create(e.prototype),{constructor:t,vrml:function(e){const t={version:this.visit(e.version),nodes:[],routes:[]};for(let r=0,n=e.node.length;r<n;r++){const n=e.node[r];t.nodes.push(this.visit(n))}if(e.route)for(let r=0,n=e.route.length;r<n;r++){const n=e.route[r];t.routes.push(this.visit(n))}return t},version:function(e){return e.Version[0].image},node:function(e){const t={name:e.NodeName[0].image,fields:[]};if(e.field)for(let r=0,n=e.field.length;r<n;r++){const n=e.field[r];t.fields.push(this.visit(n))}return e.def&&(t.DEF=this.visit(e.def[0])),t},field:function(e){const t={name:e.Identifier[0].image,type:null,values:null};let r;return e.singleFieldValue&&(r=this.visit(e.singleFieldValue[0])),e.multiFieldValue&&(r=this.visit(e.multiFieldValue[0])),t.type=r.type,t.values=r.values,t},def:function(e){return(e.Identifier||e.NodeName)[0].image},use:function(e){return{USE:(e.Identifier||e.NodeName)[0].image}},singleFieldValue:function(e){return r(this,e)},multiFieldValue:function(e){return r(this,e)},route:function(e){return{FROM:e.RouteIdentifier[0].image,TO:e.RouteIdentifier[1].image}}}),new t}(n.getBaseCstVisitorConstructor()),a=r.lex(e);n.input=a.tokens;const s=n.vrml();if(n.errors.length>0)throw Error("THREE.VRMLLoader: Parsing errors detected.");return o.visit(s)}function a(e){const t=e.nodes,r=new Scene;for(let e=0,r=t.length;e<r;e++){s(t[e])}for(const e of t){const t=i(e);t instanceof Object3D&&r.add(t),"WorldInfo"===e.name&&(r.userData.worldInfo=t)}return r}function s(e){e.DEF&&(n[e.DEF]=e);const t=e.fields;for(let e=0,r=t.length;e<r;e++){const r=t[e];if("node"===r.type){const e=r.values;for(let t=0,r=e.length;t<r;t++)s(e[t])}}}function i(e){return e.USE?function(e){const t=i(n[e]);return t.isObject3D||t.isMaterial?t.clone():t}(e.USE):(void 0!==e.build||(e.build=function(e){let t;switch(e.name){case"Group":case"Transform":case"Collision":t=function(e){const t=new Group,r=e.fields;for(const n of r){const r=n.name,o=n.values;switch(r){case"bboxCenter":break;case"bboxSize":break;case"center":break;case"children":u(o,t,e);break;case"collide":break;case"rotation":const r=new Vector3(o[0],o[1],o[2]).normalize(),n=o[3];t.quaternion.setFromAxisAngle(r,n);break;case"scale":t.scale.set(o[0],o[1],o[2]);break;case"scaleOrientation":break;case"translation":t.position.set(o[0],o[1],o[2]);break;case"proxy":break;default:break}}return t}(e);break;case"Background":t=function(e){const t=new Group;let r,n,o,a;const s=e.fields;for(let e=0,t=s.length;e<t;e++){const t=s[e],i=t.name,l=t.values;switch(i){case"groundAngle":r=l;break;case"groundColor":n=l;break;case"backUrl":break;case"bottomUrl":break;case"frontUrl":break;case"leftUrl":break;case"rightUrl":break;case"topUrl":break;case"skyAngle":o=l;break;case"skyColor":a=l;break;default:break}}const i=1e4;if(a){const e=new SphereGeometry(i,32,16),r=new MeshBasicMaterial({fog:!1,side:BackSide,depthWrite:!1,depthTest:!1});a.length>3?(M(e,i,o,R(a),!0),r.vertexColors=!0):r.color.setRGB(a[0],a[1],a[2]);const n=new Mesh(e,r);t.add(n)}if(n&&n.length>0){const e=new SphereGeometry(i,32,16,0,2*Math.PI,.5*Math.PI,1.5*Math.PI),o=new MeshBasicMaterial({fog:!1,side:BackSide,vertexColors:!0,depthWrite:!1,depthTest:!1});M(e,i,r,R(n),!1);const a=new Mesh(e,o);t.add(a)}return t.renderOrder=-1/0,t}(e);break;case"Shape":t=function(e){const t=e.fields;let r,n,o=new MeshBasicMaterial({color:0});for(let e=0,n=t.length;e<n;e++){const n=t[e],a=n.name,s=n.values;switch(a){case"appearance":null!==s[0]&&(o=i(s[0]));break;case"geometry":null!==s[0]&&(r=i(s[0]));break;default:break}}if(r&&r.attributes.position){const e=r._type;if("points"===e){const e=new PointsMaterial({color:16777215});void 0!==r.attributes.color?e.vertexColors=!0:o.isMeshPhongMaterial&&e.color.copy(o.emissive),n=new Points(r,e)}else if("line"===e){const e=new LineBasicMaterial({color:16777215});void 0!==r.attributes.color?e.vertexColors=!0:o.isMeshPhongMaterial&&e.color.copy(o.emissive),n=new LineSegments(r,e)}else void 0!==r._solid&&(o.side=r._solid?FrontSide:DoubleSide),void 0!==r.attributes.color&&(o.vertexColors=!0),n=new Mesh(r,o)}else n=new Object3D,n.visible=!1;return n}(e);break;case"Appearance":t=function(e){let t,r=new MeshPhongMaterial;const n=e.fields;for(let e=0,o=n.length;e<o;e++){const o=n[e],a=o.name,s=o.values;switch(a){case"material":if(null!==s[0]){const e=i(s[0]);e.diffuseColor&&r.color.copy(e.diffuseColor),e.emissiveColor&&r.emissive.copy(e.emissiveColor),e.shininess&&(r.shininess=e.shininess),e.specularColor&&r.specular.copy(e.specularColor),e.transparency&&(r.opacity=1-e.transparency),e.transparency>0&&(r.transparent=!0)}else r=new MeshBasicMaterial({color:0});break;case"texture":const e=s[0];null!==e&&("ImageTexture"!==e.name&&"PixelTexture"!==e.name||(r.map=i(e)));break;case"textureTransform":null!==s[0]&&(t=i(s[0]));break;default:break}}if(r.map){if(r.map.__type){switch(r.map.__type){case TEXTURE_TYPE.INTENSITY_ALPHA:r.opacity=1;break;case TEXTURE_TYPE.RGB:r.color.set(16777215);break;case TEXTURE_TYPE.RGBA:r.color.set(16777215),r.opacity=1;break;default:}delete r.map.__type}t&&(r.map.center.copy(t.center),r.map.rotation=t.rotation,r.map.repeat.copy(t.scale),r.map.offset.copy(t.translation))}return r}(e);break;case"Material":t=function(e){const t={},r=e.fields;for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,a=n.values;switch(o){case"ambientIntensity":break;case"diffuseColor":t.diffuseColor=new Color(a[0],a[1],a[2]);break;case"emissiveColor":t.emissiveColor=new Color(a[0],a[1],a[2]);break;case"shininess":t.shininess=a[0];break;case"specularColor":t.emissiveColor=new Color(a[0],a[1],a[2]);break;case"transparency":t.transparency=a[0];break;default:break}}return t}(e);break;case"ImageTexture":t=function(e){let t,n=RepeatWrapping,o=RepeatWrapping;const a=e.fields;for(let e=0,s=a.length;e<s;e++){const s=a[e],i=s.name,l=s.values;switch(i){case"url":let e=l[0];if(e&&""!==r.local_ImageTextures){let t=!1,n=r.local_ImageTextures.split(",");n.forEach(((r,o)=>{r===e&&(t||(e=n[o+1],t=!0))}))}e&&(t=I.load(e));break;case"repeatS":!1===l[0]&&(n=ClampToEdgeWrapping);break;case"repeatT":!1===l[0]&&(o=ClampToEdgeWrapping);break;default:break}}t&&(t.wrapS=n,t.wrapT=o);return t}(e);break;case"PixelTexture":t=function(e){let t,r=RepeatWrapping,n=RepeatWrapping;const o=e.fields;for(let e=0,a=o.length;e<a;e++){const a=o[e],s=a.name,i=a.values;switch(s){case"image":const e=i[0],o=i[1],a=i[2],s=2===a||4===a,u=c(a),f=new Uint8Array(e*o*(!0===s?4:3)),d={r:0,g:0,b:0,a:0};for(let e=3,t=0,r=i.length;e<r;e++,t++)if(l(i[e],u,d),!0===s){const e=4*t;f[e+0]=d.r,f[e+1]=d.g,f[e+2]=d.b,f[e+3]=d.a}else{const e=3*t;f[e+0]=d.r,f[e+1]=d.g,f[e+2]=d.b}t=new DataTexture(f,e,o,RGBAFormat),t.needsUpdate=!0,t.__type=u;break;case"repeatS":!1===i[0]&&(r=ClampToEdgeWrapping);break;case"repeatT":!1===i[0]&&(n=ClampToEdgeWrapping);break;default:break}}t&&(t.wrapS=r,t.wrapT=n);return t}(e);break;case"TextureTransform":t=function(e){const t={center:new Vector2,rotation:new Vector2,scale:new Vector2,translation:new Vector2},r=e.fields;for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,a=n.values;switch(o){case"center":t.center.set(a[0],a[1]);break;case"rotation":t.rotation=a[0];break;case"scale":t.scale.set(a[0],a[1]);break;case"translation":t.translation.set(a[0],a[1]);break;default:break}}return t}(e);break;case"IndexedFaceSet":t=function(e){let t,r,n,o,a,s,l,c,u=!0,p=!0,b=0,m=!0,x=!0;const g=e.fields;for(let e=0,f=g.length;e<f;e++){const f=g[e],d=f.name,h=f.values;switch(d){case"color":const e=h[0];null!==e&&(t=i(e));break;case"coord":const f=h[0];null!==f&&(r=i(f));break;case"normal":const d=h[0];null!==d&&(n=i(d));break;case"texCoord":const g=h[0];null!==g&&(o=i(g));break;case"ccw":u=h[0];break;case"colorIndex":a=h;break;case"colorPerVertex":m=h[0];break;case"convex":break;case"coordIndex":s=h;break;case"creaseAngle":b=h[0];break;case"normalIndex":l=h;break;case"normalPerVertex":x=h[0];break;case"solid":p=h[0];break;case"texCoordIndex":c=h;break;default:break}}if(void 0===s)return new BufferGeometry;const k=f(s,u);let y,E,S;if(t)if(!0===m)if(a&&a.length>0){y=w(k,f(a,u),t,3)}else y=L(k,new Float32BufferAttribute(t,3));else if(a&&a.length>0){y=T(k,d(h(t,a),s))}else{y=T(k,d(t,s))}if(n)if(!0===x)if(l&&l.length>0){E=w(k,f(l,u),n,3)}else E=L(k,new Float32BufferAttribute(n,3));else if(l&&l.length>0){E=T(k,d(h(n,l),s))}else{E=T(k,d(n,s))}else E=C(k,r,b);if(o)if(c&&c.length>0){S=w(k,f(c,u),o,2)}else S=L(k,new Float32BufferAttribute(o,2));const A=new BufferGeometry,v=L(k,new Float32BufferAttribute(r,3));A.setAttribute("position",v),A.setAttribute("normal",E),y&&A.setAttribute("color",y);S&&A.setAttribute("uv",S);return A._solid=p,A._type="mesh",A}(e);break;case"IndexedLineSet":t=function(e){let t,r,n,o,a=!0;const s=e.fields;for(let e=0,l=s.length;e<l;e++){const l=s[e],c=l.name,u=l.values;switch(c){case"color":const e=u[0];null!==e&&(t=i(e));break;case"coord":const s=u[0];null!==s&&(r=i(s));break;case"colorIndex":n=u;break;case"colorPerVertex":a=u[0];break;case"coordIndex":o=u;break;default:break}}let l;const c=p(o);if(t)if(!0===a)if(n.length>0){l=w(c,p(n),t,3)}else l=L(c,new Float32BufferAttribute(t,3));else if(n.length>0){l=S(c,b(h(t,n),o))}else{l=S(c,b(t,o))}const u=new BufferGeometry,f=L(c,new Float32BufferAttribute(r,3));u.setAttribute("position",f),l&&u.setAttribute("color",l);return u._type="line",u}(e);break;case"PointSet":t=function(e){let t,r;const n=e.fields;for(let e=0,o=n.length;e<o;e++){const o=n[e],a=o.name,s=o.values;switch(a){case"color":const e=s[0];null!==e&&(t=i(e));break;case"coord":const n=s[0];null!==n&&(r=i(n));break;default:break}}const o=new BufferGeometry;o.setAttribute("position",new Float32BufferAttribute(r,3)),t&&o.setAttribute("color",new Float32BufferAttribute(t,3));return o._type="points",o}(e);break;case"Box":t=function(e){const t=new Vector3(2,2,2),r=e.fields;for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,a=n.values;switch(o){case"size":t.x=a[0],t.y=a[1],t.z=a[2];break;default:break}}return new BoxGeometry(t.x,t.y,t.z)}(e);break;case"Cone":t=function(e){let t=1,r=2,n=!1;const o=e.fields;for(let e=0,a=o.length;e<a;e++){const a=o[e],s=a.name,i=a.values;switch(s){case"bottom":n=!i[0];break;case"bottomRadius":t=i[0];break;case"height":r=i[0];break;case"side":break;default:break}}return new ConeGeometry(t,r,16,1,n)}(e);break;case"Cylinder":t=function(e){let t=1,r=2;const n=e.fields;for(let e=0,o=n.length;e<o;e++){const o=n[e],a=o.name,s=o.values;switch(a){case"bottom":break;case"radius":t=s[0];break;case"height":r=s[0];break;case"side":break;case"top":break;default:break}}return new CylinderGeometry(t,t,r,16,1)}(e);break;case"Sphere":t=function(e){let t=1;const r=e.fields;for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,a=n.values;switch(o){case"radius":t=a[0];break;default:break}}return new SphereGeometry(t,16,16)}(e);break;case"ElevationGrid":t=function(e){let t,r,n,o,a=!0,s=!0,l=!0,c=!0,u=0,f=2,d=2,h=1,p=1;const b=e.fields;for(let e=0,m=b.length;e<m;e++){const m=b[e],x=m.name,g=m.values;switch(x){case"color":const e=g[0];null!==e&&(t=i(e));break;case"normal":const b=g[0];null!==b&&(r=i(b));break;case"texCoord":const m=g[0];null!==m&&(n=i(m));break;case"height":o=g;break;case"ccw":c=g[0];break;case"colorPerVertex":a=g[0];break;case"creaseAngle":u=g[0];break;case"normalPerVertex":s=g[0];break;case"solid":l=g[0];break;case"xDimension":f=g[0];break;case"xSpacing":h=g[0];break;case"zDimension":d=g[0];break;case"zSpacing":p=g[0];break;default:break}}const m=[],x=[],g=[],k=[];for(let e=0;e<d;e++)for(let i=0;i<f;i++){const l=e*f+i,c=h*e,u=o[l],b=p*i;if(m.push(c,u,b),t&&!0===a){const e=t[3*l+0],r=t[3*l+1],n=t[3*l+2];g.push(e,r,n)}if(r&&!0===s){const e=r[3*l+0],t=r[3*l+1],n=r[3*l+2];x.push(e,t,n)}if(n){const e=n[2*l+0],t=n[2*l+1];k.push(e,t)}else k.push(e/(f-1),i/(d-1))}const y=[];for(let e=0;e<f-1;e++)for(let t=0;t<d-1;t++){const r=e+t*f,n=e+(t+1)*f,o=e+1+(t+1)*f,a=e+1+t*f;!0===c?(y.push(r,o,n),y.push(o,r,a)):(y.push(r,n,o),y.push(o,a,r))}const E=L(y,new Float32BufferAttribute(m,3)),w=L(y,new Float32BufferAttribute(k,2));let T,S;if(t)if(!1===a){for(let e=0;e<f-1;e++)for(let r=0;r<d-1;r++){const n=e+r*(f-1),o=t[3*n+0],a=t[3*n+1],s=t[3*n+2];g.push(o,a,s),g.push(o,a,s),g.push(o,a,s),g.push(o,a,s),g.push(o,a,s),g.push(o,a,s)}T=new Float32BufferAttribute(g,3)}else T=L(y,new Float32BufferAttribute(g,3));if(r)if(!1===s){for(let e=0;e<f-1;e++)for(let t=0;t<d-1;t++){const n=e+t*(f-1),o=r[3*n+0],a=r[3*n+1],s=r[3*n+2];x.push(o,a,s),x.push(o,a,s),x.push(o,a,s),x.push(o,a,s),x.push(o,a,s),x.push(o,a,s)}S=new Float32BufferAttribute(x,3)}else S=L(y,new Float32BufferAttribute(x,3));else S=C(y,m,u);const A=new BufferGeometry;A.setAttribute("position",E),A.setAttribute("normal",S),A.setAttribute("uv",w),T&&A.setAttribute("color",T);return A._solid=l,A._type="mesh",A}(e);break;case"Extrusion":t=function(e){let t,r,n=[1,1,1,-1,-1,-1,-1,1,1,1],o=[0,0,0,0,1,0],a=!0,s=!0,i=0,l=!0,c=!0;const u=e.fields;for(let e=0,f=u.length;e<f;e++){const f=u[e],d=f.name,h=f.values;switch(d){case"beginCap":a=h[0];break;case"ccw":s=h[0];break;case"convex":break;case"creaseAngle":i=h[0];break;case"crossSection":n=h;break;case"endCap":l=h[0];break;case"orientation":r=h;break;case"scale":t=h;break;case"solid":c=h[0];break;case"spine":o=h;break;default:break}}const f=n[0]===n[n.length-2]&&n[1]===n[n.length-1],d=[],h=new Vector3,p=new Vector3,b=new Vector3,m=new Vector3,x=new Quaternion;for(let e=0,a=0,s=0,i=o.length;e<i;e+=3,a+=2,s+=4){h.fromArray(o,e),p.x=t?t[a+0]:1,p.y=1,p.z=t?t[a+1]:1,b.x=r?r[s+0]:0,b.y=r?r[s+1]:0,b.z=r?r[s+2]:1;const i=r?r[s+3]:0;for(let e=0,t=n.length;e<t;e+=2)m.x=n[e+0],m.y=0,m.z=n[e+1],m.multiply(p),x.setFromAxisAngle(b.normalize(),i),m.applyQuaternion(x),m.add(h),d.push(m.x,m.y,m.z)}const g=[],k=o.length/3,y=n.length/2;for(let e=0;e<k-1;e++)for(let t=0;t<y-1;t++){const r=t+e*y;let n=t+1+e*y;const o=t+(e+1)*y;let a=t+1+(e+1)*y;t===y-2&&!0===f&&(n=e*y,a=(e+1)*y),!0===s?(g.push(r,n,o),g.push(o,n,a)):(g.push(r,o,n),g.push(o,a,n))}if(!0===a||!0===l){const e=[];for(let t=0,r=n.length;t<r;t+=2)e.push(new Vector2(n[t],n[t+1]));const t=ShapeUtils.triangulateShape(e,[]),r=[];for(let e=0,n=t.length;e<n;e++){const n=t[e];r.push(n[0],n[1],n[2])}if(!0===a)for(let e=0,t=r.length;e<t;e+=3)!0===s?g.push(r[e+0],r[e+1],r[e+2]):g.push(r[e+0],r[e+2],r[e+1]);if(!0===l){const e=y*(k-1);for(let t=0,n=r.length;t<n;t+=3)!0===s?g.push(e+r[t+0],e+r[t+2],e+r[t+1]):g.push(e+r[t+0],e+r[t+1],e+r[t+2])}}const E=L(g,new Float32BufferAttribute(d,3)),w=C(g,d,i),T=new BufferGeometry;return T.setAttribute("position",E),T.setAttribute("normal",w),T._solid=c,T._type="mesh",T}(e);break;case"Color":case"Coordinate":case"Normal":case"TextureCoordinate":t=function(e){return e.fields[0].values}(e);break;case"WorldInfo":t=function(e){const t={},r=e.fields;for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,a=n.values;switch(o){case"title":t.title=a[0];break;case"info":t.info=a;break;default:break}}return t}(e);break;case"Inline":case"Anchor":case"Billboard":case"LOD":case"Switch":case"AudioClip":case"DirectionalLight":case"PointLight":case"Script":case"Sound":case"SpotLight":case"CylinderSensor":case"PlaneSensor":case"ProximitySensor":case"SphereSensor":case"TimeSensor":case"TouchSensor":case"VisibilitySensor":case"Text":case"FontStyle":case"MovieTexture":case"ColorInterpolator":case"CoordinateInterpolator":case"NormalInterpolator":case"OrientationInterpolator":case"PositionInterpolator":case"ScalarInterpolator":case"Fog":case"NavigationInfo":case"Viewpoint":break;default:break}void 0!==t&&void 0!==e.DEF&&!0===t.hasOwnProperty("name")&&(t.name=e.DEF);return t}(e)),e.build)}function l(e,t,r){let n;switch(t){case TEXTURE_TYPE.INTENSITY:n=parseInt(e),r.r=n,r.g=n,r.b=n;break;case TEXTURE_TYPE.INTENSITY_ALPHA:n=parseInt("0x"+e.substring(2,4)),r.r=n,r.g=n,r.b=n,r.a=parseInt("0x"+e.substring(4,6));break;case TEXTURE_TYPE.RGB:r.r=parseInt("0x"+e.substring(2,4)),r.g=parseInt("0x"+e.substring(4,6)),r.b=parseInt("0x"+e.substring(6,8));break;case TEXTURE_TYPE.RGBA:r.r=parseInt("0x"+e.substring(2,4)),r.g=parseInt("0x"+e.substring(4,6)),r.b=parseInt("0x"+e.substring(6,8)),r.a=parseInt("0x"+e.substring(8,10));break;default:}}function c(e){let t;switch(e){case 1:t=TEXTURE_TYPE.INTENSITY;break;case 2:t=TEXTURE_TYPE.INTENSITY_ALPHA;break;case 3:t=TEXTURE_TYPE.RGB;break;case 4:t=TEXTURE_TYPE.RGBA;break;default:}return t}function u(e,t,n){for(const o of e)if(o.name&&"Inline"===o.name&&void 0===o.build)r.inlineNodes.push({child:o,node:n});else{const e=i(o);e instanceof Object3D&&t.add(e)}}function f(e,t){const r=[];let n=0;for(let o=0,a=e.length;o<a;o++){const s=e[n],i=e[o+(t?1:2)],l=e[o+(t?2:1)];r.push(s,i,l),(-1===e[o+3]||o+3>=a)&&(o+=3,n=o+1)}return r}function d(e,t){const r=[];let n=0;for(let o=0,a=t.length;o<a;o++){const s=3*n,i=e[s],l=e[s+1],c=e[s+2];r.push(i,l,c),(-1===t[o+3]||o+3>=a)&&(o+=3,n++)}return r}function h(e,t){const r=[];for(let n=0,o=t.length;n<o;n++){const o=3*t[n],a=e[o],s=e[o+1],i=e[o+2];r.push(a,s,i)}return r}function p(e){const t=[];for(let r=0,n=e.length;r<n;r++){const o=e[r],a=e[r+1];t.push(o,a),(-1===e[r+2]||r+2>=n)&&(r+=2)}return t}function b(e,t){const r=[];let n=0;for(let o=0,a=t.length;o<a;o++){const s=3*n,i=e[s],l=e[s+1],c=e[s+2];r.push(i,l,c),(-1===t[o+2]||o+2>=a)&&(o+=2,n++)}return r}const m=new Vector3,x=new Vector3,g=new Vector3,k=new Vector2,y=new Vector2,E=new Vector2;function w(e,t,r,n){const o=[];for(let a=0,s=e.length;a<s;a+=3){const e=t[a],s=t[a+1],i=t[a+2];2===n?(k.fromArray(r,e*n),y.fromArray(r,s*n),E.fromArray(r,i*n),o.push(k.x,k.y),o.push(y.x,y.y),o.push(E.x,E.y)):(m.fromArray(r,e*n),x.fromArray(r,s*n),g.fromArray(r,i*n),o.push(m.x,m.y,m.z),o.push(x.x,x.y,x.z),o.push(g.x,g.y,g.z))}return new Float32BufferAttribute(o,n)}function T(e,t){const r=[];for(let n=0,o=0,a=e.length;n<a;n+=3,o++)m.fromArray(t,3*o),r.push(m.x,m.y,m.z),r.push(m.x,m.y,m.z),r.push(m.x,m.y,m.z);return new Float32BufferAttribute(r,3)}function S(e,t){const r=[];for(let n=0,o=0,a=e.length;n<a;n+=2,o++)m.fromArray(t,3*o),r.push(m.x,m.y,m.z),r.push(m.x,m.y,m.z);return new Float32BufferAttribute(r,3)}function L(e,t){const r=t.array,n=t.itemSize,o=new r.constructor(e.length*n);let a=0,s=0;for(let t=0,i=e.length;t<i;t++){a=e[t]*n;for(let e=0;e<n;e++)o[s++]=r[a++]}return new Float32BufferAttribute(o,n)}const A=new Vector3,v=new Vector3;function C(e,t,r){const n=[],o={};for(let r=0,a=e.length;r<a;r+=3){const a=e[r],s=e[r+1],i=e[r+2],l=new Face(a,s,i);m.fromArray(t,3*a),x.fromArray(t,3*s),g.fromArray(t,3*i),v.subVectors(g,x),A.subVectors(m,x),v.cross(A),v.normalize(),l.normal.copy(v),void 0===o[a]&&(o[a]=[]),void 0===o[s]&&(o[s]=[]),void 0===o[i]&&(o[i]=[]),o[a].push(l.normal),o[s].push(l.normal),o[i].push(l.normal),n.push(l)}const a=[];for(let e=0,s=n.length;e<s;e++){const s=n[e],i=U(o[s.a],s.normal,r),l=U(o[s.b],s.normal,r),c=U(o[s.c],s.normal,r);m.fromArray(t,3*s.a),x.fromArray(t,3*s.b),g.fromArray(t,3*s.c),a.push(i.x,i.y,i.z),a.push(l.x,l.y,l.z),a.push(c.x,c.y,c.z)}return new Float32BufferAttribute(a,3)}function U(e,t,r){const n=new Vector3;if(0===r)n.copy(t);else for(let o=0,a=e.length;o<a;o++)e[o].angleTo(t)<r&&n.add(e[o]);return n.normalize()}function R(e){const t=[];for(let r=0,n=e.length;r<n;r+=3)t.push(new Color(e[r],e[r+1],e[r+2]));return t}function M(e,t,r,n,o){const a=[],s=!0===o?0:Math.PI;for(let e=0,i=n.length;e<i;e++){let n=0===e?0:r[e-1];n=!0===o?n:s-n;const i=new Vector3;i.setFromSphericalCoords(t,n,0),a.push(i)}const i=e.index,l=e.attributes.position,c=new BufferAttribute(new Float32Array(3*e.attributes.position.count),3),u=new Vector3,f=new Color;for(let e=0;e<i.count;e++){const t=i.getX(e);let r,s;u.fromBufferAttribute(l,t);let d=1;for(let e=1;e<a.length;e++){r=e-1,s=e;const t=a[r],n=a[s];if(!0===o){if(u.y<=t.y&&u.y>n.y){d=Math.abs(t.y-u.y)/Math.abs(t.y-n.y);break}}else if(u.y>=t.y&&u.y<n.y){d=Math.abs(t.y-u.y)/Math.abs(t.y-n.y);break}}const h=n[r],p=n[s];f.copy(h).lerp(p,d),c.setXYZ(t,f.r,f.g,f.b)}e.setAttribute("color",c)}const I=new TextureLoader(this.manager);if(I.setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin),-1===e.indexOf("#VRML V2.0"))throw Error("THREE.VRMLLexer: Version of VRML asset not supported.");async function N(e,t){let r;const n=e.fields;for(const e of n){const n=e.name;e.values;switch(n){case"bboxCenter":break;case"bboxSize":break;case"url":try{let e=await o(t);await new Promise((t=>{t(r=a(e))}))}catch(e){}break;default:break}}return r}const B=await o(e);return await new Promise((e=>{e(r.scene=a(B))})),r.inlineNodes.length>0&&await Promise.all(r.inlineNodes.map((e=>fetch(r.resourcePath+e.child.fields[0].values[0])))).then((e=>Promise.all(e.map((e=>e.arrayBuffer()))))).then((async e=>{let t=0;for(const n of r.inlineNodes){let o=(new TextDecoder).decode(new Uint8Array(e[t]));n.child.build=await N(n.child,o),void 0!==n.child.build&&void 0!==n.node.DEF&&!0===n.child.build.hasOwnProperty("name")&&(n.child.build.name=n.node.DEF);for(const e of n.node.fields)if("rotation"===e.name){const t=new Vector3(e.values[0],e.values[1],e.values[2]).normalize(),r=e.values[3];n.child.build.quaternion.setFromAxisAngle(t,r)}else"scale"===e.name?n.child.build.scale.set(e.values[0],e.values[1],e.values[2]):"translation"===e.name&&n.child.build.position.set(e.values[0],e.values[1],e.values[2]);r.scene.children[0].children[t]=n.child.build,t++}})),r.scene}}class VRMLLexer{constructor(e){this.lexer=new chevrotain.Lexer(e)}lex(e){const t=this.lexer.tokenize(e);if(t.errors.length>0)throw Error("THREE.VRMLLexer: Lexing errors detected.");return t}}const CstParser=chevrotain.CstParser;class VRMLParser extends CstParser{constructor(e){super(e);const t=this,r=e.Version,n=e.LCurly,o=e.RCurly,a=e.LSquare,s=e.RSquare,i=e.Identifier,l=e.RouteIdentifier,c=e.StringLiteral,u=e.HexLiteral,f=e.NumberLiteral,d=e.TrueLiteral,h=e.FalseLiteral,p=e.NullLiteral,b=e.DEF,m=e.USE,x=e.ROUTE,g=e.TO,k=e.NodeName;t.RULE("vrml",(function(){t.SUBRULE(t.version),t.AT_LEAST_ONE((function(){t.SUBRULE(t.node)})),t.MANY((function(){t.SUBRULE(t.route)}))})),t.RULE("version",(function(){t.CONSUME(r)})),t.RULE("node",(function(){t.OPTION((function(){t.SUBRULE(t.def)})),t.CONSUME(k),t.CONSUME(n),t.MANY((function(){t.SUBRULE(t.field)})),t.CONSUME(o)})),t.RULE("field",(function(){t.CONSUME(i),t.OR2([{ALT:function(){t.SUBRULE(t.singleFieldValue)}},{ALT:function(){t.SUBRULE(t.multiFieldValue)}}])})),t.RULE("def",(function(){t.CONSUME(b),t.OR([{ALT:function(){t.CONSUME(i)}},{ALT:function(){t.CONSUME(k)}}])})),t.RULE("use",(function(){t.CONSUME(m),t.OR([{ALT:function(){t.CONSUME(i)}},{ALT:function(){t.CONSUME(k)}}])})),t.RULE("singleFieldValue",(function(){t.AT_LEAST_ONE((function(){t.OR([{ALT:function(){t.SUBRULE(t.node)}},{ALT:function(){t.SUBRULE(t.use)}},{ALT:function(){t.CONSUME(c)}},{ALT:function(){t.CONSUME(u)}},{ALT:function(){t.CONSUME(f)}},{ALT:function(){t.CONSUME(d)}},{ALT:function(){t.CONSUME(h)}},{ALT:function(){t.CONSUME(p)}}])}))})),t.RULE("multiFieldValue",(function(){t.CONSUME(a),t.MANY((function(){t.OR([{ALT:function(){t.SUBRULE(t.node)}},{ALT:function(){t.SUBRULE(t.use)}},{ALT:function(){t.CONSUME(c)}},{ALT:function(){t.CONSUME(u)}},{ALT:function(){t.CONSUME(f)}},{ALT:function(){t.CONSUME(p)}}])})),t.CONSUME(s)})),t.RULE("route",(function(){t.CONSUME(x),t.CONSUME(l),t.CONSUME(g),t.CONSUME2(l)})),this.performSelfAnalysis()}}class Face{constructor(e,t,r){this.a=e,this.b=t,this.c=r,this.normal=new Vector3}}const TEXTURE_TYPE={INTENSITY:1,INTENSITY_ALPHA:2,RGB:3,RGBA:4};export{VRMLLoader};