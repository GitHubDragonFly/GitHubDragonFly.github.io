import{AmbientLight,AnimationClip,Bone,BufferAttribute,BufferGeometry,ClampToEdgeWrapping,Color,DirectionalLight,EquirectangularReflectionMapping,Euler,FileLoader,Float32BufferAttribute,Group,Line,LineBasicMaterial,Loader,LoaderUtils,MathUtils,Matrix3,Matrix4,Mesh,MeshLambertMaterial,MeshPhongMaterial,NumberKeyframeTrack,Object3D,OrthographicCamera,PerspectiveCamera,PointLight,Points,PointsMaterial,PropertyBinding,Quaternion,QuaternionKeyframeTrack,RepeatWrapping,Skeleton,SkinnedMesh,SpotLight,Texture,TextureLoader,Uint16BufferAttribute,Vector3,Vector4,VectorKeyframeTrack,SRGBColorSpace}from"three";import*as fflate from"https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/libs/fflate.module.min.js";import{NURBSCurve}from"https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/curves/NURBSCurve.min.js";let isPoints,fbxTree,connections,sceneGraph,localPath="";class FBXLoader extends Loader{constructor(e){super(e)}load(e,t,r,n,a=""){isPoints=!1;const o=this,s=""===o.path?LoaderUtils.extractUrlBase(e):o.path,i=new FileLoader(this.manager);localPath=a,i.setPath(o.path),i.setResponseType("arraybuffer"),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials),i.load(e,(function(r){try{t(o.parse(r,s))}catch(t){n&&n(t),o.manager.itemError(e)}}),r,n)}parse(e,t){if(isFbxFormatBinary(e))fbxTree=(new BinaryParser).parse(e);else{const t=convertArrayBufferToString(e);if(!isFbxFormatASCII(t))throw new Error("THREE.FBXLoader: Unknown format.");if(getFbxVersion(t)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+getFbxVersion(t));fbxTree=(new TextParser).parse(t)}const r=new TextureLoader(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new FBXTreeParser(r,this.manager).parse(fbxTree)}}class FBXTreeParser{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){connections=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),r=this.parseMaterials(t),n=this.parseDeformers(),a=(new GeometryParser).parse(n);return this.parseScene(n,a,r),sceneGraph}parseConnections(){const e=new Map;if("Connections"in fbxTree){fbxTree.Connections.connections.forEach((function(t){const r=t[0],n=t[1],a=t[2];e.has(r)||e.set(r,{parents:[],children:[]});const o={ID:n,relationship:a};e.get(r).parents.push(o),e.has(n)||e.set(n,{parents:[],children:[]});const s={ID:r,relationship:a};e.get(n).children.push(s)}))}return e}parseImages(){const e={},t={};if("Video"in fbxTree.Objects){const r=fbxTree.Objects.Video;for(const n in r){const a=r[n],o=parseInt(n);if(e[o]=a.RelativeFilename||a.Filename,"Content"in a){const r=a.Content instanceof ArrayBuffer&&a.Content.byteLength>0,n="string"==typeof a.Content&&""!==a.Content;if(r||n){const r=this.parseImage(a);t[e[o]]=r}}else t[e[o]]="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAAWSURBVBhXY/wPBAxogAlKowCKBBkYAJrrBAb3Gn8+AAAAAElFTkSuQmCC"}}for(const r in e){const n=e[r];void 0!==t[n]?e[r]=t[n]:e[r].indexOf("\\")>-1?e[r]=e[r].split("\\").pop():e[r].indexOf("/")>-1&&(e[r]=e[r].split("/").pop())}return e}parseImage(e){const t=e.Content,r=e.RelativeFilename||e.Filename;let n;switch(r.slice(r.lastIndexOf(".")+1).toLowerCase()){case"bmp":n="image/bmp";break;case"jpg":case"jpeg":n="image/jpeg";break;case"png":n="image/png";break;case"tif":n="image/tiff";break;case"tga":this.manager.getHandler(".tga"),n="image/tga";break;case"dds":this.manager.getHandler(".dds"),n="image/vnd-ms.dds";break;default:return}if("string"==typeof t)return"data:"+n+";base64,"+t;{const e=new Uint8Array(t);return window.URL.createObjectURL(new Blob([e],{type:n}))}}parseTextures(e){const t=new Map;if("Texture"in fbxTree.Objects){const r=fbxTree.Objects.Texture;for(const n in r){const a=this.parseTexture(r[n],e);t.set(parseInt(n),a)}}return t}parseTexture(e,t){let r,n;if(""!==localPath){let a=localPath.split(",");a.forEach(((t,r)=>{e.FileName.toUpperCase().endsWith(t.toUpperCase())&&(n={},n.FileName=a[r+1],n.ext=t.slice(-3).toLowerCase())})),r=n?this.loadTexture(n,t):this.loadTexture(e,t)}else r=this.loadTexture(e,t);r.ID=e.id,r.name=e.attrName;const a=e.WrapModeU,o=e.WrapModeV,s=void 0!==a?a.value:0,i=void 0!==o?o.value:0;if(r.wrapS=0===s?RepeatWrapping:ClampToEdgeWrapping,r.wrapT=0===i?RepeatWrapping:ClampToEdgeWrapping,"Scaling"in e){const t=e.Scaling.value;r.repeat.x=t[0],r.repeat.y=t[1]}return r}loadTexture(e,t){let r;const n=this.textureLoader.path;if(e.id){let n=connections.get(e.id).children;void 0!==n&&n.length>0&&void 0!==t[n[0].ID]&&(r=t[n[0].ID],(r.startsWith("blob:")||r.startsWith("data:"))&&this.textureLoader.setPath(void 0))}else r=e.FileName,void 0!==r&&(r.startsWith("blob:")||r.startsWith("data:"))&&this.textureLoader.setPath(void 0);let a;if(!e.ext&&!e.FileName)return a=(new TextureLoader).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAAWSURBVBhXY/wPBAxogAlKowCKBBkYAJrrBAb3Gn8+AAAAAElFTkSuQmCC"),a.colorSpace=SRGBColorSpace,a;let o=e.ext||e.FileName.slice(-3).toLowerCase();if("tga"===o){const e=this.manager.getHandler(".tga");null===e?a=new Texture:(e.setPath(this.textureLoader.path),a=e.load(r))}else if("dds"===o){const e=this.manager.getHandler(".dds");null===e?a=new Texture:(e.setPath(this.textureLoader.path),a=e.load(r),a.repeat.y=-1)}else a="psd"===o?new Texture:this.textureLoader.load(r);return this.textureLoader.setPath(n),a}parseMaterials(e){const t=new Map;if("Material"in fbxTree.Objects){const r=fbxTree.Objects.Material;for(const n in r){const a=this.parseMaterial(r[n],e);null!==a&&t.set(parseInt(n),a)}}return t}parseMaterial(e,t){const r=e.id,n=e.attrName;let a=e.ShadingModel;if("object"==typeof a&&(a=a.value),!connections.has(r))return null;const o=this.parseParameters(e,t,r);let s;switch(a.toLowerCase()){case"phong":s=new MeshPhongMaterial;break;case"lambert":s=new MeshLambertMaterial;break;default:s=new MeshPhongMaterial;break}return s.setValues(o),s.name=n,s}parseParameters(e,t,r){const n={};e.BumpFactor&&(n.bumpScale=e.BumpFactor.value),e.Diffuse?n.color=(new Color).fromArray(e.Diffuse.value):!e.DiffuseColor||"Color"!==e.DiffuseColor.type&&"ColorRGB"!==e.DiffuseColor.type||(n.color=(new Color).fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(n.displacementScale=e.DisplacementFactor.value),e.Emissive?n.emissive=(new Color).fromArray(e.Emissive.value):!e.EmissiveColor||"Color"!==e.EmissiveColor.type&&"ColorRGB"!==e.EmissiveColor.type||(n.emissive=(new Color).fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(n.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.TransparencyFactor&&(e.TransparencyFactor.value<1||!e.Opacity)?n.opacity=1-parseFloat(e.TransparencyFactor.value):e.Opacity&&(n.opacity=parseFloat(e.Opacity.value)),n.opacity<1&&(n.transparent=!0),e.ReflectionFactor&&(n.reflectivity=e.ReflectionFactor.value),e.Shininess&&(n.shininess=e.Shininess.value),e.Specular?n.specular=(new Color).fromArray(e.Specular.value):e.SpecularColor&&"Color"===e.SpecularColor.type&&(n.specular=(new Color).fromArray(e.SpecularColor.value));const a=this;return connections.get(r).children.forEach((function(r){switch(r.relationship){case"Bump":n.bumpMap=a.getTexture(t,r.ID);break;case"AmbientColor":case"Maya|TEX_ao_map":n.aoMap=a.getTexture(t,r.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":n.map=a.getTexture(t,r.ID),n.map.colorSpace=SRGBColorSpace;break;case"DisplacementColor":n.displacementMap=a.getTexture(t,r.ID);break;case"EmissiveColor":n.emissiveMap=a.getTexture(t,r.ID),n.emissiveMap.colorSpace=SRGBColorSpace;break;case"NormalMap":case"Maya|TEX_normal_map":"lambert"!==e.ShadingModel&&(n.normalMap=a.getTexture(t,r.ID));break;case"ReflectionColor":n.envMap=a.getTexture(t,r.ID),n.envMap.mapping=EquirectangularReflectionMapping,n.envMap.colorSpace=SRGBColorSpace;break;case"SpecularColor":n.specularMap=a.getTexture(t,r.ID),n.specularMap.colorSpace=SRGBColorSpace;break;case"TransparentColor":case"TransparencyFactor":n.alphaMap=a.getTexture(t,r.ID),n.transparent=!n.opacity||n.opacity<1==!0;break;case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:break}})),n}getTexture(e,t){return"LayeredTexture"in fbxTree.Objects&&t in fbxTree.Objects.LayeredTexture&&(t=connections.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in fbxTree.Objects){const r=fbxTree.Objects.Deformer;for(const n in r){const a=r[n],o=connections.get(parseInt(n));if("Skin"===a.attrType){const t=this.parseSkeleton(o,r);t.ID=n,o.parents.length,t.geometryID=o.parents[0].ID,e[n]=t}else if("BlendShape"===a.attrType){const e={id:n};e.rawTargets=this.parseMorphTargets(o,r),e.id=n,o.parents.length,t[n]=e}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const r=[];return e.children.forEach((function(e){const n=t[e.ID];if("Cluster"!==n.attrType)return;const a={ID:e.ID,indices:[],weights:[],transformLink:(new Matrix4).fromArray(n.TransformLink.a)};"Indexes"in n&&(a.indices=n.Indexes.a,a.weights=n.Weights.a),r.push(a)})),{rawBones:r,bones:[]}}parseMorphTargets(e,t){const r=[];for(let n=0;n<e.children.length;n++){const a=e.children[n],o=t[a.ID],s={name:o.attrName,initialWeight:o.DeformPercent,id:o.id,fullWeights:o.FullWeights.a};if("BlendShapeChannel"!==o.attrType)return;s.geoID=connections.get(parseInt(a.ID)).children.filter((function(e){return void 0===e.relationship}))[0].ID,r.push(s)}return r}parseScene(e,t,r){sceneGraph=new Group;const n=this.parseModels(e.skeletons,t,r),a=fbxTree.Objects.Model,o=this;n.forEach((function(e){const t=a[e.ID];if(o.setLookAtProperties(e,t),void 0!==connections.get(e.ID)){connections.get(e.ID).parents.forEach((function(t){const r=n.get(t.ID);void 0!==r&&r.add(e)}))}null===e.parent&&sceneGraph.add(e)})),this.bindSkeleton(e.skeletons,t,n),this.createAmbientLight(),this.setupMorphMaterials(),sceneGraph.traverse((function(e){if(e.userData.transformData){e.parent&&(e.userData.transformData.parentMatrix=e.parent.matrix,e.userData.transformData.parentMatrixWorld=e.parent.matrixWorld);const t=generateTransform(e.userData.transformData);e.applyMatrix4(t),e.updateWorldMatrix()}}));const s=(new AnimationParser).parse();1===sceneGraph.children.length&&sceneGraph.children[0].isGroup&&(sceneGraph.children[0].animations=s,sceneGraph=sceneGraph.children[0]),sceneGraph.animations=s}parseModels(e,t,r){const n=new Map,a=fbxTree.Objects.Model;for(const o in a){const s=parseInt(o),i=a[o],l=connections.get(s);let c=this.buildSkeleton(l,e,s,i.attrName);if(!c){switch(i.attrType){case"Camera":c=this.createCamera(l);break;case"Light":c=this.createLight(l);break;case"Mesh":c=this.createMesh(l,t,r);break;case"NurbsCurve":c=this.createCurve(l,t);break;case"LimbNode":case"Root":c=new Bone;break;case"Null":default:c=new Group;break}c.name=i.attrName?PropertyBinding.sanitizeNodeName(i.attrName):"",c.ID=s}this.getTransformData(c,i),n.set(s,c)}return n}buildSkeleton(e,t,r,n){if(!e)return null;let a=null;return e.parents.forEach((function(e){for(const o in t){const s=t[o];s.rawBones.forEach((function(t,o){if(t.ID===e.ID){const e=a;a=new Bone,a.matrixWorld.copy(t.transformLink),a.name=n?PropertyBinding.sanitizeNodeName(n):"",a.ID=r,s.bones[o]=a,null!==e&&a.add(e)}}))}})),a}createCamera(e){let t,r;if(e.children.forEach((function(e){const t=fbxTree.Objects.NodeAttribute[e.ID];void 0!==t&&(r=t)})),void 0===r)t=new Object3D;else{let e=0;void 0!==r.CameraProjectionType&&1===r.CameraProjectionType.value&&(e=1);let n=1;void 0!==r.NearPlane&&(n=r.NearPlane.value/1e3);let a=1e3;void 0!==r.FarPlane&&(a=r.FarPlane.value/1e3);let o=window.innerWidth,s=window.innerHeight;void 0!==r.AspectWidth&&void 0!==r.AspectHeight&&(o=r.AspectWidth.value,s=r.AspectHeight.value);const i=o/s;let l=45;void 0!==r.FieldOfView&&(l=r.FieldOfView.value);const c=r.FocalLength?r.FocalLength.value:null;switch(e){case 0:t=new PerspectiveCamera(l,i,n,a),null!==c&&t.setFocalLength(c);break;case 1:t=new OrthographicCamera(-o/2,o/2,s/2,-s/2,n,a);break;default:t=new Object3D;break}}return t}createLight(e){let t,r;if(e.children.forEach((function(e){const t=fbxTree.Objects.NodeAttribute[e.ID];void 0!==t&&(r=t)})),void 0===r)t=new Object3D;else{let e;e=void 0===r.LightType?0:r.LightType.value;let n=16777215;void 0!==r.Color&&(n=(new Color).fromArray(r.Color.value));let a=void 0===r.Intensity?1:r.Intensity.value/100;void 0!==r.CastLightOnObject&&0===r.CastLightOnObject.value&&(a=0);let o=0;void 0!==r.FarAttenuationEnd&&(o=void 0!==r.EnableFarAttenuation&&0===r.EnableFarAttenuation.value?0:r.FarAttenuationEnd.value);const s=1;switch(e){case 0:t=new PointLight(n,a,o,s);break;case 1:t=new DirectionalLight(n,a);break;case 2:let e=Math.PI/3;void 0!==r.InnerAngle&&(e=MathUtils.degToRad(r.InnerAngle.value));let i=0;void 0!==r.OuterAngle&&(i=MathUtils.degToRad(r.OuterAngle.value),i=Math.max(i,1)),t=new SpotLight(n,a,o,e,i,s);break;default:t=new PointLight(n,a);break}void 0!==r.CastShadows&&1===r.CastShadows.value&&(t.castShadow=!0)}return t}createMesh(e,t,r){let n,a=null,o=null;const s=[];return e.children.forEach((function(e){t.has(e.ID)?a=t.get(e.ID):!0===isPoints?s.push(new PointsMaterial({size:.01,color:13421772})):r.has(e.ID)&&s.push(r.get(e.ID))})),s.length>1?o=s:s.length>0?o=s[0]:(o=new MeshPhongMaterial({color:13421772}),s.push(o)),"color"in a.attributes&&s.forEach((function(e){e.vertexColors=!0})),a.FBX_Deformer?(n=new SkinnedMesh(a,o),n.normalizeSkinWeights()):n=!0===isPoints?new Points(a,o):new Mesh(a,o),n}createCurve(e,t){const r=e.children.reduce((function(e,r){return t.has(r.ID)&&(e=t.get(r.ID)),e}),null),n=new LineBasicMaterial({color:3342591,linewidth:1});return new Line(r,n)}getTransformData(e,t){const r={};"InheritType"in t&&(r.inheritType=parseInt(t.InheritType.value)),r.eulerOrder="RotationOrder"in t?getEulerOrder(t.RotationOrder.value):"ZYX","Lcl_Translation"in t&&(r.translation=t.Lcl_Translation.value),"PreRotation"in t&&(r.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(r.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(r.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(r.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(r.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(r.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(r.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(r.rotationPivot=t.RotationPivot.value),e.userData.transformData=r}setLookAtProperties(e,t){if("LookAtProperty"in t){connections.get(e.ID).children.forEach((function(t){if("LookAtProperty"===t.relationship){const r=fbxTree.Objects.Model[t.ID];if("Lcl_Translation"in r){const t=r.Lcl_Translation.value;void 0!==e.target?(e.target.position.fromArray(t),sceneGraph.add(e.target)):e.lookAt((new Vector3).fromArray(t))}}}))}}bindSkeleton(e,t,r){const n=this.parsePoseNodes();for(const a in e){const o=e[a];connections.get(parseInt(o.ID)).parents.forEach((function(e){if(t.has(e.ID)){const t=e.ID;connections.get(t).parents.forEach((function(e){if(r.has(e.ID)){r.get(e.ID).bind(new Skeleton(o.bones),n[e.ID])}}))}}))}}parsePoseNodes(){const e={};if("Pose"in fbxTree.Objects){const t=fbxTree.Objects.Pose;for(const r in t)if("BindPose"===t[r].attrType&&t[r].NbPoseNodes>0){const n=t[r].PoseNode;Array.isArray(n)?n.forEach((function(t){e[t.Node]=(new Matrix4).fromArray(t.Matrix.a)})):e[n.Node]=(new Matrix4).fromArray(n.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in fbxTree&&"AmbientColor"in fbxTree.GlobalSettings){const e=fbxTree.GlobalSettings.AmbientColor.value,t=e[0],r=e[1],n=e[2];if(0!==t||0!==r||0!==n){const e=new Color(t,r,n);sceneGraph.add(new AmbientLight(e,1))}}}setupMorphMaterials(){const e=this;sceneGraph.traverse((function(t){t.isMesh&&t.geometry.morphAttributes.position&&t.geometry.morphAttributes.position.length&&(Array.isArray(t.material)?t.material.forEach((function(r,n){e.setupMorphMaterial(t,r,n)})):e.setupMorphMaterial(t,t.material))}))}setupMorphMaterial(e,t,r){const n=e.uuid,a=t.uuid;let o=!1;if(sceneGraph.traverse((function(e){e.isMesh&&(Array.isArray(e.material)?e.material.forEach((function(t){t.uuid===a&&e.uuid!==n&&(o=!0)})):e.material.uuid===a&&e.uuid!==n&&(o=!0))})),!0===o){const n=t.clone();n.morphTargets=!0,void 0===r?e.material=n:e.material[r]=n}else t.morphTargets=!0}}class GeometryParser{parse(e){const t=new Map;if("Geometry"in fbxTree.Objects){const r=fbxTree.Objects.Geometry;for(const n in r){const a=connections.get(parseInt(n)),o=this.parseGeometry(a,r[n],e);t.set(parseInt(n),o)}}return t}parseGeometry(e,t,r){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,r);break;case"NurbsCurve":return this.parseNurbsGeometry(t);break}}parseMeshGeometry(e,t,r){const n=r.skeletons,a=[],o=e.parents.map((function(e){return fbxTree.Objects.Model[e.ID]}));if(0===o.length)return;const s=e.children.reduce((function(e,t){return void 0!==n[t.ID]&&(e=n[t.ID]),e}),null);e.children.forEach((function(e){void 0!==r.morphTargets[e.ID]&&a.push(r.morphTargets[e.ID])}));const i=o[0],l={};"RotationOrder"in i&&(l.eulerOrder=getEulerOrder(i.RotationOrder.value)),"InheritType"in i&&(l.inheritType=parseInt(i.InheritType.value)),"GeometricTranslation"in i&&(l.translation=i.GeometricTranslation.value),"GeometricRotation"in i&&(l.rotation=i.GeometricRotation.value),"GeometricScaling"in i&&(l.scale=i.GeometricScaling.value);const c=generateTransform(l);return this.genGeometry(t,s,a,c)}genGeometry(e,t,r,n){const a=new BufferGeometry;e.attrName&&(a.name=e.attrName);const o=this.parseGeoNode(e,t),s=this.genBuffers(o),i=new Float32BufferAttribute(s.vertex,3);if(i.applyMatrix4(n),a.setAttribute("position",i),s.colors.length>0&&a.setAttribute("color",new Float32BufferAttribute(s.colors,3)),t&&(a.setAttribute("skinIndex",new Uint16BufferAttribute(s.weightsIndices,4)),a.setAttribute("skinWeight",new Float32BufferAttribute(s.vertexWeights,4)),a.FBX_Deformer=t),s.normal.length>0){const e=(new Matrix3).getNormalMatrix(n),t=new Float32BufferAttribute(s.normal,3);t.applyNormalMatrix(e),a.setAttribute("normal",t)}if(s.uvs.forEach((function(e,t){let r="uv"+(t+1).toString();0===t&&(r="uv"),a.setAttribute(r,new Float32BufferAttribute(s.uvs[t],2))})),o.material&&"AllSame"!==o.material.mappingType){let e=s.materialIndex[0],t=0;if(s.materialIndex.forEach((function(r,n){r!==e&&(a.addGroup(t,n-t,e),e=r,t=n)})),a.groups.length>0){const t=a.groups[a.groups.length-1],r=t.start+t.count;r!==s.materialIndex.length&&a.addGroup(r,s.materialIndex.length-r,e)}0===a.groups.length&&a.addGroup(0,s.materialIndex.length,s.materialIndex[0])}return this.addMorphTargets(a,e,r,n),a}parseGeoNode(e,t){const r={};if(r.vertexPositions=void 0!==e.Vertices?e.Vertices.a:[],r.vertexIndices=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(r.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(r.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&e.LayerElementNormal[0].Normals&&(r.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){r.uv=[];let t=0;for(;e.LayerElementUV[t];)e.LayerElementUV[t].UV&&r.uv.push(this.parseUVs(e.LayerElementUV[t])),t++}return r.weightTable={},null!==t&&(r.skeleton=t,t.rawBones.forEach((function(e,t){e.indices.forEach((function(n,a){void 0===r.weightTable[n]&&(r.weightTable[n]=[]),r.weightTable[n].push({id:t,weight:e.weights[a]})}))}))),r}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let r=0,n=0,a=!1,o=[],s=[],i=[],l=[],c=[],u=[];const p=this;let h=[];return e.vertexIndices.forEach((function(f,d){let m,g=!1;f<0&&(f^=-1,g=!0);let y=[],v=[];if(o.push(3*f,3*f+1,3*f+2),e.color){const t=getData(d,r,f,e.color);i.push(t[0],t[1],t[2]),h.push(t[0],t[1],t[2])}if(e.skeleton){if(void 0!==e.weightTable[f]&&e.weightTable[f].forEach((function(e){v.push(e.weight),y.push(e.id)})),v.length>4){a||(a=!0);const e=[0,0,0,0],t=[0,0,0,0];v.forEach((function(r,n){let a=r,o=y[n];t.forEach((function(t,r,n){if(a>t){n[r]=a,a=t;const s=e[r];e[r]=o,o=s}}))})),y=e,v=t}for(;v.length<4;)v.push(0),y.push(0);for(let e=0;e<4;++e)c.push(v[e]),u.push(y[e])}if(e.normal){const t=getData(d,r,f,e.normal);s.push(t[0],t[1],t[2])}e.material&&"AllSame"!==e.material.mappingType&&(m=getData(d,r,f,e.material)[0]),m<0&&(m=0),e.uv&&e.uv.forEach((function(e,t){const n=getData(d,r,f,e);void 0===l[t]&&(l[t]=[]),l[t].push(n[0]),l[t].push(n[1])})),n++,g&&(p.genFace(t,e,o,m,s,i,l,c,u,n),r++,n=0,o=[],s=[],i=[],l=[],c=[],u=[])})),0===t.vertex.length?(t.vertex=e.vertexPositions,h.length>0&&(slice(t.colors,h,0,h.length),h.length=0),isPoints=!0):h.length>0?(h.length=0,isPoints=!1):isPoints=!1,t}genFace(e,t,r,n,a,o,s,i,l,c){for(let u=2;u<c;u++)e.vertex.push(t.vertexPositions[r[0]]||0),e.vertex.push(t.vertexPositions[r[1]]||0),e.vertex.push(t.vertexPositions[r[2]]||0),e.vertex.push(t.vertexPositions[r[3*(u-1)]]||0),e.vertex.push(t.vertexPositions[r[3*(u-1)+1]]||0),e.vertex.push(t.vertexPositions[r[3*(u-1)+2]]||0),e.vertex.push(t.vertexPositions[r[3*u]]||0),e.vertex.push(t.vertexPositions[r[3*u+1]]||0),e.vertex.push(t.vertexPositions[r[3*u+2]]||0),t.skeleton&&(e.vertexWeights.push(i[0]),e.vertexWeights.push(i[1]),e.vertexWeights.push(i[2]),e.vertexWeights.push(i[3]),e.vertexWeights.push(i[4*(u-1)]),e.vertexWeights.push(i[4*(u-1)+1]),e.vertexWeights.push(i[4*(u-1)+2]),e.vertexWeights.push(i[4*(u-1)+3]),e.vertexWeights.push(i[4*u]),e.vertexWeights.push(i[4*u+1]),e.vertexWeights.push(i[4*u+2]),e.vertexWeights.push(i[4*u+3]),e.weightsIndices.push(l[0]),e.weightsIndices.push(l[1]),e.weightsIndices.push(l[2]),e.weightsIndices.push(l[3]),e.weightsIndices.push(l[4*(u-1)]),e.weightsIndices.push(l[4*(u-1)+1]),e.weightsIndices.push(l[4*(u-1)+2]),e.weightsIndices.push(l[4*(u-1)+3]),e.weightsIndices.push(l[4*u]),e.weightsIndices.push(l[4*u+1]),e.weightsIndices.push(l[4*u+2]),e.weightsIndices.push(l[4*u+3])),t.color&&(e.colors.push(o[0]),e.colors.push(o[1]),e.colors.push(o[2]),e.colors.push(o[3*(u-1)]),e.colors.push(o[3*(u-1)+1]),e.colors.push(o[3*(u-1)+2]),e.colors.push(o[3*u]),e.colors.push(o[3*u+1]),e.colors.push(o[3*u+2])),t.material&&"AllSame"!==t.material.mappingType&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(a[0]),e.normal.push(a[1]),e.normal.push(a[2]),e.normal.push(a[3*(u-1)]),e.normal.push(a[3*(u-1)+1]),e.normal.push(a[3*(u-1)+2]),e.normal.push(a[3*u]),e.normal.push(a[3*u+1]),e.normal.push(a[3*u+2])),t.uv&&t.uv.forEach((function(t,r){void 0===e.uvs[r]&&(e.uvs[r]=[]),e.uvs[r].push(s[r][0]),e.uvs[r].push(s[r][1]),e.uvs[r].push(s[r][2*(u-1)]),e.uvs[r].push(s[r][2*(u-1)+1]),e.uvs[r].push(s[r][2*u]),e.uvs[r].push(s[r][2*u+1])}))}addMorphTargets(e,t,r,n){if(0===r.length)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const a=this;r.forEach((function(r){r.rawTargets.forEach((function(r){const o=fbxTree.Objects.Geometry[r.geoID];void 0!==o&&a.genMorphGeometry(e,t,o,n,r.name)}))}))}genMorphGeometry(e,t,r,n,a){const o=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],s=void 0!==r.Vertices?r.Vertices.a:[],i=void 0!==r.Indexes?r.Indexes.a:[],l=3*e.attributes.position.count,c=new Float32Array(l);for(let e=0;e<i.length;e++){const t=3*i[e];c[t]=s[3*e],c[t+1]=s[3*e+1],c[t+2]=s[3*e+2]}const u={vertexIndices:o,vertexPositions:c},p=this.genBuffers(u),h=new Float32BufferAttribute(p.vertex,3);h.name=a||r.attrName,h.applyMatrix4(n),e.morphAttributes.position.push(h)}parseNormals(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Normals.a;let a=[];return"IndexToDirect"===r&&("NormalIndex"in e?a=e.NormalIndex.a:"NormalsIndex"in e&&(a=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:a,mappingType:t,referenceType:r}}parseUVs(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.UV.a;let a=[];return"IndexToDirect"===r&&(a=e.UVIndex.a),{dataSize:2,buffer:n,indices:a,mappingType:t,referenceType:r}}parseVertexColors(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Colors.a;let a=[];return"IndexToDirect"===r&&(a=e.ColorIndex.a),{dataSize:4,buffer:n,indices:a,mappingType:t,referenceType:r}}parseMaterialIndices(e){const t=e.MappingInformationType,r=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:r};const n=e.Materials.a,a=[];for(let e=0;e<n.length;++e)a.push(e);return{dataSize:1,buffer:n,indices:a,mappingType:t,referenceType:r}}parseNurbsGeometry(e){if(void 0===NURBSCurve)return new BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return new BufferGeometry;const r=t-1,n=e.KnotVector.a,a=[],o=e.Points.a;for(let e=0,t=o.length;e<t;e+=4)a.push((new Vector4).fromArray(o,e));let s,i;if("Closed"===e.Form)a.push(a[0]);else if("Periodic"===e.Form){s=r,i=n.length-1-s;for(let e=0;e<r;++e)a.push(a[e])}const l=new NURBSCurve(r,n,a,s,i).getPoints(7*a.length),c=new Float32Array(3*l.length);l.forEach((function(e,t){e.toArray(c,3*t)}));const u=new BufferGeometry;return u.setAttribute("position",new BufferAttribute(c,3)),u}}class AnimationParser{parse(){const e=[],t=this.parseClips();if(void 0!==t)for(const r in t){const n=t[r],a=this.addClip(n);e.push(a)}return e}parseClips(){if(void 0===fbxTree.Objects.AnimationCurve)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=fbxTree.Objects.AnimationCurveNode,t=new Map;for(const r in e){const n=e[r];if(null!==n.attrName.match(/S|R|T|DeformPercent/)){const e={id:n.id,attr:n.attrName,curves:{}};t.set(e.id,e)}}return t}parseAnimationCurves(e){const t=fbxTree.Objects.AnimationCurve;for(const r in t){const n={id:t[r].id,times:t[r].KeyTime.a.map(convertFBXTimeToSeconds),values:t[r].KeyValueFloat.a},a=connections.get(n.id);if(void 0!==a){const t=a.parents[0].ID,r=a.parents[0].relationship;r.match(/X/)?e.get(t).curves.x=n:r.match(/Y/)?e.get(t).curves.y=n:r.match(/Z/)?e.get(t).curves.z=n:r.match(/d|DeformPercent/)&&e.has(t)&&(e.get(t).curves.morph=n)}}}parseAnimationLayers(e){const t=fbxTree.Objects.AnimationLayer,r=new Map;for(const n in t){const t=[],a=connections.get(parseInt(n));if(void 0!==a){a.children.forEach((function(r,n){if(e.has(r.ID)){const a=e.get(r.ID);if(void 0!==a.curves.x||void 0!==a.curves.y||void 0!==a.curves.z){if(void 0===t[n]){const e=connections.get(r.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID;if(void 0!==e){const r=fbxTree.Objects.Model[e.toString()];if(void 0===r)return;const a={modelName:r.attrName?PropertyBinding.sanitizeNodeName(r.attrName):"",ID:r.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};sceneGraph.traverse((function(e){e.ID===r.id&&(a.transform=e.matrix,e.userData.transformData&&(a.eulerOrder=e.userData.transformData.eulerOrder))})),a.transform||(a.transform=new Matrix4),"PreRotation"in r&&(a.preRotation=r.PreRotation.value),"PostRotation"in r&&(a.postRotation=r.PostRotation.value),t[n]=a}}t[n]&&(t[n][a.attr]=a)}else if(void 0!==a.curves.morph){if(void 0===t[n]){const e=connections.get(r.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID,a=connections.get(e).parents[0].ID,o=connections.get(a).parents[0].ID,s=connections.get(o).parents[0].ID,i=fbxTree.Objects.Model[s],l={modelName:i.attrName?PropertyBinding.sanitizeNodeName(i.attrName):"",morphName:fbxTree.Objects.Deformer[e].attrName};t[n]=l}t[n][a.attr]=a}}})),r.set(parseInt(n),t)}}return r}parseAnimStacks(e){const t=fbxTree.Objects.AnimationStack,r={};for(const n in t){const a=connections.get(parseInt(n)).children;a.length;const o=e.get(a[0].ID);r[n]={name:t[n].attrName,layer:o}}return r}addClip(e){let t=[];const r=this;return e.layer.forEach((function(e){t=t.concat(r.generateTracks(e))})),new AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let r=new Vector3,n=new Vector3;if(e.transform&&e.transform.decompose(r,new Quaternion,n),r=r.toArray(),n=n.toArray(),void 0!==e.T&&Object.keys(e.T.curves).length>0){const n=this.generateVectorTrack(e.modelName,e.T.curves,r,"position");void 0!==n&&t.push(n)}if(void 0!==e.R&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);void 0!==r&&t.push(r)}if(void 0!==e.S&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,n,"scale");void 0!==r&&t.push(r)}if(void 0!==e.DeformPercent){const r=this.generateMorphTrack(e);void 0!==r&&t.push(r)}return t}generateVectorTrack(e,t,r,n){const a=this.getTimesForAllAxes(t),o=this.getKeyframeTrackValues(a,t,r);return new VectorKeyframeTrack(e+"."+n,a,o)}generateRotationTrack(e,t,r,n,a){let o,s;if(void 0!==t.x&&void 0!==t.y&&void 0!==t.z){const e=this.interpolateRotations(t.x,t.y,t.z,a);o=e[0],s=e[1]}void 0!==r&&((r=r.map(MathUtils.degToRad)).push(a),r=(new Euler).fromArray(r),r=(new Quaternion).setFromEuler(r)),void 0!==n&&((n=n.map(MathUtils.degToRad)).push(a),n=(new Euler).fromArray(n),n=(new Quaternion).setFromEuler(n).invert());const i=new Quaternion,l=new Euler,c=[];if(!s||!o)return new QuaternionKeyframeTrack(e+".quaternion",[0],[0]);for(let e=0;e<s.length;e+=3){if(l.set(s[e],s[e+1],s[e+2],a),i.setFromEuler(l),void 0!==r&&i.premultiply(r),void 0!==n&&i.multiply(n),e>2){(new Quaternion).fromArray(c,(e-3)/3*4).dot(i)<0&&i.set(-i.x,-i.y,-i.z,-i.w)}i.toArray(c,e/3*4)}return new QuaternionKeyframeTrack(e+".quaternion",o,c)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,r=t.values.map((function(e){return e/100})),n=sceneGraph.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+n+"]",t.times,r)}getTimesForAllAxes(e){let t=[];if(void 0!==e.x&&(t=t.concat(e.x.times)),void 0!==e.y&&(t=t.concat(e.y.times)),void 0!==e.z&&(t=t.concat(e.z.times)),t=t.sort((function(e,t){return e-t})),t.length>1){let e=1,r=t[0];for(let n=1;n<t.length;n++){const a=t[n];a!==r&&(t[e]=a,r=a,e++)}t=t.slice(0,e)}return t}getKeyframeTrackValues(e,t,r){const n=r,a=[];let o=-1,s=-1,i=-1;return e.forEach((function(e){if(t.x&&(o=t.x.times.indexOf(e)),t.y&&(s=t.y.times.indexOf(e)),t.z&&(i=t.z.times.indexOf(e)),-1!==o){const e=t.x.values[o];a.push(e),n[0]=e}else a.push(n[0]);if(-1!==s){const e=t.y.values[s];a.push(e),n[1]=e}else a.push(n[1]);if(-1!==i){const e=t.z.values[i];a.push(e),n[2]=e}else a.push(n[2])})),a}interpolateRotations(e,t,r,n){const a=[],o=[];a.push(e.times[0]),o.push(MathUtils.degToRad(e.values[0])),o.push(MathUtils.degToRad(t.values[0])),o.push(MathUtils.degToRad(r.values[0]));for(let s=1;s<e.values.length;s++){const i=[e.values[s-1],t.values[s-1],r.values[s-1]];if(isNaN(i[0])||isNaN(i[1])||isNaN(i[2]))continue;const l=i.map(MathUtils.degToRad),c=[e.values[s],t.values[s],r.values[s]];if(isNaN(c[0])||isNaN(c[1])||isNaN(c[2]))continue;const u=c.map(MathUtils.degToRad),p=[c[0]-i[0],c[1]-i[1],c[2]-i[2]],h=[Math.abs(p[0]),Math.abs(p[1]),Math.abs(p[2])];if(h[0]>=180||h[1]>=180||h[2]>=180){const t=Math.max(...h)/180,r=new Euler(...l,n),i=new Euler(...u,n),c=(new Quaternion).setFromEuler(r),p=(new Quaternion).setFromEuler(i);c.dot(p)&&p.set(-p.x,-p.y,-p.z,-p.w);const f=e.times[s-1],d=e.times[s]-f,m=new Quaternion,g=new Euler;for(let e=0;e<1;e+=1/t)m.copy(c.clone().slerp(p.clone(),e)),a.push(f+e*d),g.setFromQuaternion(m,n),o.push(g.x),o.push(g.y),o.push(g.z)}else a.push(e.times[s]),o.push(MathUtils.degToRad(e.values[s])),o.push(MathUtils.degToRad(t.values[s])),o.push(MathUtils.degToRad(r.values[s]))}return[a,o]}}class TextParser{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new FBXTree,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,r=e.split(/[\r\n]+/);return r.forEach((function(e,n){const a=e.match(/^[\s\t]*;/),o=e.match(/^[\s\t]*$/);if(a||o)return;const s=e.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),i=e.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=e.match("^\\t{"+(t.currentIndent-1)+"}}");s?t.parseNodeBegin(e,s):i?t.parseNodeProperty(e,i,r[++n]):l?t.popStack():e.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(e)})),this.allNodes}parseNodeBegin(e,t){const r=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map((function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")})),a={name:r},o=this.parseNodeAttr(n),s=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(r,a):r in s?("PoseNode"===r?s.PoseNode.push(a):void 0!==s[r].id&&(s[r]={},s[r][s[r].id]=s[r]),""!==o.id&&(s[r][o.id]=a)):"number"==typeof o.id?(s[r]={},s[r][o.id]=a):"Properties70"!==r&&(s[r]="PoseNode"===r?[a]:a),"number"==typeof o.id&&(a.id=o.id),""!==o.name&&(a.attrName=o.name),""!==o.type&&(a.attrType=o.type),this.pushStack(a)}parseNodeAttr(e){let t=e[0];""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let r="",n="";return e.length>1&&(r=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:r,type:n}}parseNodeProperty(e,t,r){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),a=t[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===n&&","===a&&(a=r.replace(/"/g,"").replace(/,$/,"").trim());const o=this.getCurrentNode();if("Properties70"!==o.name){if("C"===n){const e=a.split(",").slice(1),t=parseInt(e[0]),r=parseInt(e[1]);let s=a.split(",").slice(3);s=s.map((function(e){return e.trim().replace(/^"/,"")})),n="connections",a=[t,r],append(a,s),void 0===o[n]&&(o[n]=[])}"Node"===n&&(o.id=a),n in o&&Array.isArray(o[n])?o[n].push(a):"a"!==n?o[n]=a:o.a=a,this.setCurrentProp(o,n),"a"===n&&","!==a.slice(-1)&&(o.a=parseNumberArray(a))}else this.parseNodeSpecialProperty(e,n,a)}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,","!==e.slice(-1)&&(t.a=parseNumberArray(t.a))}parseNodeSpecialProperty(e,t,r){const n=r.split('",').map((function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")})),a=n[0],o=n[1],s=n[2],i=n[3];let l=n[4];switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=parseNumberArray(l);break}this.getPrevNode()[a]={type:o,type2:s,flag:i,value:l},this.setCurrentProp(this.getPrevNode(),a)}}class BinaryParser{parse(e){const t=new BinaryReader(e);t.skip(23);const r=t.getUint32();if(r<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+r);const n=new FBXTree;for(;!this.endOfContent(t);){const e=this.parseNode(t,r);null!==e&&n.add(e.name,e)}return n}endOfContent(e){return e.size()%16==0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const r={},n=t>=7500?e.getUint64():e.getUint32(),a=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const o=e.getUint8(),s=e.getString(o);if(0===n)return null;const i=[];for(let t=0;t<a;t++)i.push(this.parseProperty(e));const l=i.length>0?i[0]:"",c=i.length>1?i[1]:"",u=i.length>2?i[2]:"";for(r.singleProperty=1===a&&e.getOffset()===n;n>e.getOffset();){const n=this.parseNode(e,t);null!==n&&this.parseSubNode(s,r,n)}return r.propertyList=i,"number"==typeof l&&(r.id=l),""!==c&&(r.attrName=c),""!==u&&(r.attrType=u),""!==s&&(r.name=s),r}parseSubNode(e,t,r){if(!0===r.singleProperty){const e=r.propertyList[0];Array.isArray(e)?(t[r.name]=r,r.a=e):t[r.name]=e}else if("Connections"===e&&"C"===r.name){const e=[];r.propertyList.forEach((function(t,r){0!==r&&e.push(t)})),void 0===t.connections&&(t.connections=[]),t.connections.push(e)}else if("Properties70"===r.name){Object.keys(r).forEach((function(e){t[e]=r[e]}))}else if("Properties70"===e&&"P"===r.name){let e=r.propertyList[0],n=r.propertyList[1];const a=r.propertyList[2],o=r.propertyList[3];let s;0===e.indexOf("Lcl ")&&(e=e.replace("Lcl ","Lcl_")),0===n.indexOf("Lcl ")&&(n=n.replace("Lcl ","Lcl_")),s="Color"===n||"ColorRGB"===n||"Vector"===n||"Vector3D"===n||0===n.indexOf("Lcl_")?[r.propertyList[4],r.propertyList[5],r.propertyList[6]]:r.propertyList[4],t[e]={type:n,type2:a,flag:o,value:s}}else void 0===t[r.name]?"number"==typeof r.id?(t[r.name]={},t[r.name][r.id]=r):t[r.name]=r:"PoseNode"===r.name?(Array.isArray(t[r.name])||(t[r.name]=[t[r.name]]),t[r.name].push(r)):void 0===t[r.name][r.id]&&(t[r.name][r.id]=r)}parseProperty(e){const t=e.getString(1);let r;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return r=e.getUint32(),e.getArrayBuffer(r);case"S":return r=e.getUint32(),e.getString(r);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),a=e.getUint32(),o=e.getUint32();if(0===a)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const s=fflate.unzlibSync(new Uint8Array(e.getArrayBuffer(o))),i=new BinaryReader(s.buffer);switch(t){case"b":case"c":return i.getBooleanArray(n);case"d":return i.getFloat64Array(n);case"f":return i.getFloat32Array(n);case"i":return i.getInt32Array(n);case"l":return i.getInt64Array(n)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class BinaryReader{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return 1==(1&this.getUint8())}getBooleanArray(e){const t=[];for(let r=0;r<e;r++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,e=4294967295&~e,4294967295===e&&(t=t+1&4294967295),e=e+1&4294967295,-(4294967296*t+e)):4294967296*t+e}getInt64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let r=0;r<e;r++)t[r]=this.getUint8();const r=t.indexOf(0);return r>=0&&(t=t.slice(0,r)),(new TextDecoder).decode(new Uint8Array(t))}}class FBXTree{add(e,t){this[e]=t}}function isFbxFormatBinary(e){const t="Kaydara FBX Binary  \0";return e.byteLength>=t.length&&t===convertArrayBufferToString(e,0,t.length)}function isFbxFormatASCII(e){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let r=0;function n(t){const n=e[t-1];return e=e.slice(r+t),r++,n}for(let e=0;e<t.length;++e){if(n(1)===t[e])return!1}return!0}function getFbxVersion(e){const t=e.match(/FBXVersion: (\d+)/);if(t){return parseInt(t[1])}throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function convertFBXTimeToSeconds(e){return e/46186158e3}const dataArray=[];function getData(e,t,r,n){let a;switch(n.mappingType){case"ByPolygonVertex":a=e;break;case"ByPolygon":a=t;break;case"ByVertice":a=r;break;case"AllSame":a=n.indices[0];break;default:}"IndexToDirect"===n.referenceType&&(a=n.indices[a]);const o=a*n.dataSize,s=o+n.dataSize;return slice(dataArray,n.buffer,o,s)}const tempEuler=new Euler,tempVec=new Vector3;function generateTransform(e){const t=new Matrix4,r=new Matrix4,n=new Matrix4,a=new Matrix4,o=new Matrix4,s=new Matrix4,i=new Matrix4,l=new Matrix4,c=new Matrix4,u=new Matrix4,p=new Matrix4,h=new Matrix4,f=e.inheritType?e.inheritType:0;if(e.translation&&t.setPosition(tempVec.fromArray(e.translation)),e.preRotation){const t=e.preRotation.map(MathUtils.degToRad);t.push(e.eulerOrder||Euler.DefaultOrder),r.makeRotationFromEuler(tempEuler.fromArray(t))}if(e.rotation){const t=e.rotation.map(MathUtils.degToRad);t.push(e.eulerOrder||Euler.DefaultOrder),n.makeRotationFromEuler(tempEuler.fromArray(t))}if(e.postRotation){const t=e.postRotation.map(MathUtils.degToRad);t.push(e.eulerOrder||Euler.DefaultOrder),a.makeRotationFromEuler(tempEuler.fromArray(t)),a.invert()}e.scale&&o.scale(tempVec.fromArray(e.scale)),e.scalingOffset&&i.setPosition(tempVec.fromArray(e.scalingOffset)),e.scalingPivot&&s.setPosition(tempVec.fromArray(e.scalingPivot)),e.rotationOffset&&l.setPosition(tempVec.fromArray(e.rotationOffset)),e.rotationPivot&&c.setPosition(tempVec.fromArray(e.rotationPivot)),e.parentMatrixWorld&&(p.copy(e.parentMatrix),u.copy(e.parentMatrixWorld));const d=r.clone().multiply(n).multiply(a),m=new Matrix4;m.extractRotation(u);const g=new Matrix4;g.copyPosition(u);const y=g.clone().invert().multiply(u),v=m.clone().invert().multiply(y),A=o,x=new Matrix4;if(0===f)x.copy(m).multiply(d).multiply(v).multiply(A);else if(1===f)x.copy(m).multiply(v).multiply(d).multiply(A);else{const e=(new Matrix4).scale((new Vector3).setFromMatrixScale(p)).clone().invert(),t=v.clone().multiply(e);x.copy(m).multiply(d).multiply(t).multiply(A)}const b=c.clone().invert(),T=s.clone().invert();let w=t.clone().multiply(l).multiply(c).multiply(r).multiply(n).multiply(a).multiply(b).multiply(i).multiply(s).multiply(o).multiply(T);const I=(new Matrix4).copyPosition(w),M=u.clone().multiply(I);return h.copyPosition(M),w=h.clone().multiply(x),w.premultiply(u.invert()),w}function getEulerOrder(e){const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(e=e||0)?t[0]:t[e]}function parseNumberArray(e){return e.split(",").map((function(e){return parseFloat(e)}))}function convertArrayBufferToString(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.byteLength),(new TextDecoder).decode(new Uint8Array(e,t,r))}function append(e,t){for(let r=0,n=e.length,a=t.length;r<a;r++,n++)e[n]=t[r]}function slice(e,t,r,n){for(let a=r,o=0;a<n;a++,o++)e[o]=t[a];return e}export{FBXLoader};