import{Box3,BufferGeometry,BufferAttribute,Loader,Sphere,Vector3}from 'three';import{createLazPerf}from 'laz-perf';import{Copc}from 'copc';const LAZ_PERF_WASM_URL='https://cdn.jsdelivr.net/npm/laz-perf@0.0.7/lib/laz-perf.wasm';const LazPerf=await createLazPerf({locateFile:(path)=>{if(path.endsWith('.wasm')){return LAZ_PERF_WASM_URL}return path}});class COPCStreamLoader extends Loader{constructor(manager){super(manager);this.skipPoints=1;this.skipColor=false;this.skipIntensity=false;this.skipClassification=false;this.applyIntensityToColor=true;this.intensityGammaFactor=0.1;this.lodDepthLimit=0}setDepthLimit(depth){if(!Number.isInteger(depth)){depth=0}else{depth=Math.max(Math.min(depth,8),0)}this.lodDepthLimit=depth;return this}setSkipPoints(number_of_points){if(!Number.isInteger(number_of_points)){number_of_points=1}else{number_of_points=Math.max(Math.min(number_of_points,100),1)}this.skipPoints=number_of_points;return this}setSkipColor(flag){this.skipColor=flag;return this}setSkipIntensity(flag){this.skipIntensity=flag;return this}setSkipClassification(flag){this.skipClassification=flag;return this}setIntensityGammaFactor(gamma){gamma=Number(gamma);if(!isFinite(gamma)||gamma<=0){gamma=0.1}gamma=Math.min(Math.max(gamma,0.1),2.0);this.intensityGammaFactor=gamma;return this}setApplyIntensityToColor(flag){this.applyIntensityToColor=flag;return this}async _mapWithConcurrency(items,limit,fn){const queue=[...items];const workers=[limit].fill(null).map(async()=>{while(queue.length){const item=queue.shift();await fn(item)}});await Promise.all(workers)}async _loadNodePointsToGeometry(url,copc,node,globalZRange){const isBuffer=url instanceof ArrayBuffer||ArrayBuffer.isView(url);const decompressedBuffer=isBuffer?url:await Copc.loadPointDataBuffer(url,copc.header,node,LazPerf);const count=node.pointCount;const{pointDataRecordLength,pointDataRecordFormat,scale,offset}=copc.header;const dv=new DataView(decompressedBuffer.buffer,decompressedBuffer.byteOffset,decompressedBuffer.byteLength);const skipPoints=(this.skipPoints&&this.skipPoints>1)?this.skipPoints:1;const keptPoints=Math.ceil(count/skipPoints);const positions=new Float32Array(keptPoints*3);const colors=!this.skipColor?new Float32Array(keptPoints*3):null;const intensities=!this.skipIntensity?new Float32Array(keptPoints):null;const classifications=!this.skipClassification?new Uint8Array(keptPoints):null;const formatsWithColor=[2,3,5,7,8,10];const hasNativeColor=formatsWithColor.includes(pointDataRecordFormat);let targetIdx=0;for(let i=0;i<count;i+=skipPoints){const writeIdx=targetIdx*3,div=65535.0;const pStart=i*pointDataRecordLength;const rawX=dv.getInt32(pStart+0,true);const rawY=dv.getInt32(pStart+4,true);const rawZ=dv.getInt32(pStart+8,true);const x=(rawX*scale[0])+offset[0];const y=(rawY*scale[1])+offset[1];const z=(rawZ*scale[2])+offset[2];positions[writeIdx+0]=x;positions[writeIdx+1]=y;positions[writeIdx+2]=z;let currentIntensity=1.0;if(!this.skipIntensity){const rawIntensity=dv.getUint16(pStart+12,true);const currentIntensity=Math.pow(rawIntensity/div,this.intensityGammaFactor);intensities[targetIdx]=currentIntensity}if(!this.skipClassification){const classOffset=pointDataRecordFormat>=6?16:15;classifications[targetIdx]=dv.getUint8(pStart+classOffset)}const colorOffset=pointDataRecordFormat>=6?30:20;if(!this.skipColor&&(pStart+colorOffset+6<=decompressedBuffer.byteLength)){if(hasNativeColor){const mult=this.applyIntensityToColor?intensities[targetIdx]:1.0;colors[writeIdx+0]=(dv.getUint16(pStart+colorOffset+0,true)/div)*mult;colors[writeIdx+1]=(dv.getUint16(pStart+colorOffset+2,true)/div)*mult;colors[writeIdx+2]=(dv.getUint16(pStart+colorOffset+4,true)/div)*mult}}targetIdx+=1;}const geometry=new BufferGeometry();geometry.setAttribute('position',new BufferAttribute(positions,3));if(!this.skipColor&&hasNativeColor){geometry.setAttribute('color',new BufferAttribute(colors,3))}if(!this.skipIntensity){geometry.setAttribute('intensity',new BufferAttribute(intensities,1))}if(!this.skipClassification){geometry.setAttribute('classification',new BufferAttribute(classifications,1))}const{min,max}=copc.header;const box=new Box3(new Vector3(min[0],min[1],min[2]),new Vector3(max[0],max[1],max[2]));geometry.boundingBox=box;geometry.boundingSphere=box.getBoundingSphere(new Sphere());return geometry}load(url,onLoad,onProgress,onError){try{this.parse(url,onLoad,onError)}catch(err){if(onError){onError(err)}else{console.error(err)}}}async parse(url,onNodeLoaded,onNodeError){const copc=await Copc.create(url);const{nodes,pages}=await Copc.loadHierarchyPage(url,copc.info.rootHierarchyPage);const filteredNodes=[];Object.keys(nodes).forEach(key=>{const str=key.toString();const depth=parseInt(key.split('-')[0]);if(depth<=this.lodDepthLimit){filteredNodes.push(str)}});const totalSelectedNodes=filteredNodes.length;const rootNode=nodes['0-0-0-0'];let globalZRange;if(rootNode){const rootBuffer=await Copc.loadPointDataBuffer(url,copc.header,rootNode,LazPerf);const count=rootNode.pointCount;const{pointDataRecordLength,scale,offset}=copc.header;const dv=new DataView(rootBuffer.buffer,rootBuffer.byteOffset,rootBuffer.byteLength);const rootZValues=[];for(let i=0;i<count;i+=1){const pStart=i*pointDataRecordLength;const z=(dv.getInt32(pStart+8,true)*scale[2])+offset[2];rootZValues.push(z)}rootZValues.sort((a,b)=>a-b);const p1=rootZValues[Math.floor(count*0.01)];const p99=rootZValues[Math.floor(count*0.99)];globalZRange={min:p1,max:p99,range:(p99-p1)||1.0};const rootGeom=await this._loadNodePointsToGeometry(rootBuffer,copc,rootNode,globalZRange);if(rootGeom&&onNodeLoaded){if(filteredNodes.indexOf('0-0-0-0')!==-1){filteredNodes.splice(filteredNodes.indexOf('0-0-0-0'),1)}console.log('Node 0-0-0-0');onNodeLoaded(rootGeom,totalSelectedNodes,'0-0-0-0',globalZRange)}}else{globalZRange={min:copc.header.min[2],max:copc.header.max[2],range:(copc.header.max[2]-copc.header.min[2])||1.0}}const CONCURRENCY=4;await this._mapWithConcurrency(filteredNodes,CONCURRENCY,async(key)=>{try{const geom=await this._loadNodePointsToGeometry(url,copc,nodes[key],globalZRange);if(geom&&onNodeLoaded){console.log('Node ',key);onNodeLoaded(geom,totalSelectedNodes,key,globalZRange)}}catch(err){if(onNodeError){onNodeError(err)}else{console.error(`Node ${ key } failed:`,err)}}});return true}}export{COPCStreamLoader};