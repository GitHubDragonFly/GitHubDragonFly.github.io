import{BufferGeometry,Color,DoubleSide,Float32BufferAttribute,Line,LineBasicMaterial,Loader,Mesh,MeshStandardMaterial,Vector2,Vector3}from"three";class DSTLoader extends Loader{constructor(e){super(e),this.quads=!0,this.resetInProgress=!1,this.threadThickness=2,this.jumpThreadThickness=.01,this.palette=["#FF0000","#00FF00","#0000FF","#FFFFFF","#808080","#000000"],this.v0=new Vector3,this.buffer=new ArrayBuffer(0)}decodeCoordinate(e,t,r){let s,a,n=e|t<<8|r<<16,o=0,i=0,h=e=>n&1<<e;return h(23)&&(i+=1),h(22)&&(i-=1),h(21)&&(i+=9),h(20)&&(i-=9),h(19)&&(o-=9),h(18)&&(o+=9),h(17)&&(o-=1),h(16)&&(o+=1),h(15)&&(i+=3),h(14)&&(i-=3),h(13)&&(i+=27),h(12)&&(i-=27),h(11)&&(o-=27),h(10)&&(o+=27),h(9)&&(o-=3),h(8)&&(o+=3),h(7)&&(s=!0),h(6)&&(a=!0),h(5)&&(i+=81),h(4)&&(i-=81),h(3)&&(o-=81),h(2)&&(o+=81),{x:o,y:i,jump:s,cstop:a}}async loadBinaryData(e,t){const r=this;try{const s=await fetch(e);if(!s.ok){if(!t)throw new Error(`HTTP error! status: ${s.status}`);return t(`HTTP error! status: ${s.status}`),r.manager.itemError(e),[]}return await s.arrayBuffer()}catch(e){if(!t)throw new Error("Failed to load binary data: ",e);t("Failed to load binary data: ",e)}}parseDST(){const e=this;let t=new DataView(e.buffer),r=[],s=[],a=[],n=[],o=[],i=0,h=0,d=1,l=1,p=1,u=String.fromCharCode.apply(String,new Uint8Array(e.buffer,0,512)),m=u.indexOf("CO:"),c=0;m>0&&(c=parseInt(u.slice(m+3,m+7)));let g,f=0,T=!1,w=0;for(e.palette||(e.palette=[]);e.palette.length<c+1;)d=Math.random(),l=Math.random(),p=Math.random(),e.v0.set(d,l,p).normalize(),e.palette.push("#"+new Color(e.v0.x,e.v0.y,e.v0.z).getHexString());g=[];for(let t=0;t<e.palette.length;t++){g[t]=new Color(e.palette[t]);let r=g[w%g.length];d=r.r,l=r.g,p=r.b}for(let u=512;u<t.byteLength&&!(u>=t.byteLength-3);u+=3){let m=t.getUint8(u),c=t.getUint8(u+1),y=t.getUint8(u+2);if(0===m&&0===c&&243===y)break;let{x:b,y:v,cstop:k,jump:F}=this.decodeCoordinate(y,c,m),M=i,P=h;if(i+=b,h+=v,k)if(g){w++;let e=g[w%g.length];d=e.r,l=e.g,p=e.b}else d=Math.random(),l=Math.random(),p=Math.random(),e.v0.set(d,l,p).normalize(),d=e.v0.x,l=e.v0.y,p=e.v0.z;if(e.quads){let t=-(h-P),u=i-M,m=e.v0.set(t,u,0).length();m&&e.v0.multiplyScalar(1/m);let c=T?e.jumpThreadThickness:e.threadThickness;t=e.v0.x*c,u=e.v0.y*c,s.push(M+t,P+u,0),s.push(M-t,P-u,0),s.push(i-t,h-u,0),s.push(i+t,h+u,0);let g=.5*Math.random();o.push(0,0+g,1,0+g,1,m/80+g,0,m/80+g),a.push(d,l,p),a.push(d,l,p),a.push(d,l,p),a.push(d,l,p),n.push(0,0,1,-0,-0,1,-0,-0,1,0,0,1),r.push(f,f+1,f+2,f+2,f+3,f+0),f+=4}else s.push(i,h,0),a.push(d,l,p);T=F||k}let y=new BufferGeometry;return y.setAttribute("position",new Float32BufferAttribute(s,3)),y.setAttribute("color",new Float32BufferAttribute(a,3)),o.length&&y.setAttribute("uv",new Float32BufferAttribute(o,2)),n.length&&y.setAttribute("normal",new Float32BufferAttribute(n,3)),r.length&&y.setIndex(r),y}loadAsync=async(e,t)=>new Promise(((r,s)=>this.load(e,r,void 0,s,t)));load(e,t,r,s,a={}){const n=this;n.palette=[],n.loadBinaryData(e,s).then((e=>{function r(){void 0!==a.quads&&(n.quads=a.quads),void 0!==a.resetInProgress&&(n.resetInProgress=a.resetInProgress),void 0!==a.threadThickness&&(n.threadThickness=a.threadThickness),void 0!==a.jumpThreadThickness&&(n.jumpThreadThickness=a.jumpThreadThickness),void 0!==a.palette&&(n.palette=a.palette),a.quads=n.quads,a.resetInProgress=n.resetInProgress,a.threadThickness=n.threadThickness,a.jumpThreadThickness=n.jumpThreadThickness;let e=n.parseDST(n.buffer,a);a.palette=n.palette;let t=n.quads?new Mesh(e.clone(),new MeshStandardMaterial({color:"white",vertexColors:!0,side:DoubleSide,depthTest:!1,metalness:0,roughness:.9,normalScale:new Vector2(.8,.8)})):new Line(e.clone(),new LineBasicMaterial({color:"white",vertexColors:!0}));return t.scale.set(.01,.01,.01),t.updateMatrixWorld(!0),e.dispose(),t}n.buffer=e;let s=r(),o={mesh:s,get resetInProgress(){return a.resetInProgress},set resetInProgress(e){a.resetInProgress=e},get quads(){return a.quads||!1},set quads(e){a.quads=!0===e,o.meshNeedsUpdate=!0},get threadThickness(){return a.threadThickness},set threadThickness(e){a.threadThickness=parseFloat(e),o.meshNeedsUpdate=!0},get jumpThreadThickness(){return a.jumpThreadThickness},set jumpThreadThickness(e){a.jumpThreadThickness=parseFloat(e),o.meshNeedsUpdate=!0},get palette(){return a.palette},set palette(e){a.palette=e,o.meshNeedsUpdate=!0},toTexture(e,t,r){if(!a.map){e.render(t,r);const s=e.domElement.toDataURL("image/png").replace(/^data:image\/(png|jpg|jpeg);base64,/,""),a=atob(s),n=new Uint8Array(a.length);for(let e=0,t=n.length;e<t;e++)n[e]=a.charCodeAt(e);return n}},get normalMap(){}},i=!1,h=!1;s.onBeforeRender=async function(){if(void 0!==o.drawRange){let e=o.mesh.geometry.index?o.mesh.geometry.index.count:o.mesh.geometry.attributes.position.count;o.mesh.geometry.drawRange.count=o.drawRange*e|0}if(!0===o.meshNeedsUpdate&&!1===a.resetInProgress){if(i)return;i=!0,await new Promise((e=>{let t=r();o.mesh.geometry.dispose(),t.position.copy(o.mesh.position),t.scale.copy(o.mesh.scale),t.rotation.copy(o.mesh.rotation),t.material.map=s.material.map,s.material.map.dispose(),t.material.normalMap=s.material.normalMap,s.material.normalMap.dispose(),s.material.dispose(),o.mesh.parent.add(t),t.onBeforeRender=o.mesh.onBeforeRender,o.mesh.parent.remove(o.mesh),o.mesh=t,e(i=!1)})),o.meshNeedsUpdate=!1}else if(!0===a.resetInProgress)await new Promise((e=>{e(o.mesh.parent.remove(o.mesh))}));else if(!0===o.needsUpdate){if(h)return;h=!0,await new Promise((e=>{o.mesh.geometry.dispose(),o.mesh.geometry=r().geometry,e(h=!1)})),o.needsUpdate=!1}o.meshNeedsUpdate=!1,o.needsUpdate=!1},t(o)}))}}export{DSTLoader};