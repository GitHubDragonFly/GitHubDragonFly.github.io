import{BufferAttribute,BufferGeometry,Loader}from"three";import*as fzstd from"https://cdn.skypack.dev/fzstd?min";import{LASZLoader}from"./LASZLoader.min.js";const GIT_LFS_THRESHOLD_BYTES=150;class EPTStreamLoader extends Loader{constructor(e){super(e),this.skipPoints=1,this.lodDepthLimit=0,this.globalMinZ=null,this.globalMaxZ=null,this.localBlobs=null,this.contrastFactor=1,this.potreeTileBounds={},this.zdecompressor=fzstd,this.lasLoader=new LASZLoader(e)}setZstdDecompressor(e=null){if(!e||"function"!=typeof e.decode&&"function"!=typeof e.decompress)throw new Error("Zstd decompressor must have a decode( Uint8Array ) or decompress( Uint8Array ) function.");return this.zdecompressor=e,this}setLocalBlobMap(e){return this.localBlobs=e,this}setTileDepthLimit(e){return e=Number.isInteger(e)?Math.max(Math.min(e,8),0):0,this.lodDepthLimit=e,this}setSkipPoints(e){return e=Number.isInteger(e)?Math.max(Math.min(e,100),1):1,this.lasLoader.setSkipPoints(e),this.skipPoints=e,this}setSkipColor(e){return this.lasLoader.setSkipColor(e),this}setSkipIntensity(e){return this.lasLoader.setSkipIntensity(e),this}setSkipClassification(e){return this.lasLoader.setSkipClassification(e),this}setIntensityGammaFactor(e){return e=Number(e),(!isFinite(e)||e<=0)&&(e=1),e=Math.min(Math.max(e,.1),2),this.lasLoader.setIntensityGammaFactor(e),this.contrastFactor=e,this}setApplyIntensityToColor(e){return this.lasLoader.setApplyIntensityToColor(e),this}_getValue(e,t,s,r,i=!0){switch(s.toLowerCase()){case"int8":return e.getInt8(t);case"uint8":return e.getUint8(t);case"int16":return e.getInt16(t,i);case"uint16":return e.getUint16(t,i);case"int32":return e.getInt32(t,i);case"uint32":return e.getUint32(t,i);case"float":case"float32":return e.getFloat32(t,i);case"int64":return Number(e.getBigInt64(t,i));case"uint64":return Number(e.getBigUint64(t,i));case"double":case"float64":return e.getFloat64(t,i);case"integer":case"scaledinteger":case"signed":case"unsigned":switch(r){case 1:return"unsigned"===s?e.getUint8(t):e.getInt8(t);case 2:return"unsigned"===s?e.getUint16(t,i):e.getInt16(t,i);case 4:return"unsigned"===s?e.getUint32(t,i):e.getInt32(t,i);case 8:return Number("unsigned"===s?e.getBigUint64(t,i):e.getBigInt64(t,i));default:return console.warn("Unsupported integer size:",a.size),0}default:return console.warn("Unknown attribute type:",s),0}}_sizeOf(e){switch(e.type.toLowerCase()){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float":case"float32":return 4;case"int64":case"uint64":case"float64":case"double":return 8;case"signed":case"unsigned":case"integer":case"scaledinteger":return e.size;default:return console.warn("Unknown EPT attribute type:",e.type),0}}_normalizeCI(e,t){let s;return s=1===t.size?e/255:2===t.size?e<=255?e/255:e/65535:e,Math.min(1,s)}async _loadBinTile(e,t,s,r){try{const i=new DataView(e),n=t.attributes||t.schema,a=t.scale||[1,1,1],o=t.offset||[0,0,0];let l=null;this.potreeTileBounds&&r&&(l=this.potreeTileBounds[s]?.min);let c=0;const u=[];for(const e of n){const t=this._sizeOf(e),s=e.type.toLowerCase(),r=e.name.toLowerCase();u.push({name:r,type:s,size:t,byteOffset:c,raw:e}),c+=t}if(0===c)return null;const h=e.byteLength/c|0,y=this.skipPoints&&this.skipPoints>1?this.skipPoints:1,p=Math.ceil(h/y),f=new Float32Array(3*p),d=new Float32Array(3*p),m=new Float32Array(p);let b=0;for(let e=0;e<h;e+=y){const t=e*c;for(const e of u){const s=e.raw,r=this._getValue(i,t+e.byteOffset,e.type,e.size,!0);switch(e.name){case"x":f[3*b+0]=(l?l.x:0)+r*(a[0]||(s.scale[0]??s.scale))+(o[0]||(s.offset[0]??s.offset));break;case"y":f[3*b+1]=(l?l.y:0)+r*(a[1]||(s.scale[1]??s.scale))+(o[1]||(s.offset[1]??s.offset));break;case"z":f[3*b+2]=(l?l.z:0)+r*(a[2]||(s.scale[2]??s.scale))+(o[2]||(s.offset[2]??s.offset));break;case"intensity":m[b]=this._normalizeCI(r,s);break;case"red":d[3*b+0]=this._normalizeCI(r,s);break;case"green":d[3*b+1]=this._normalizeCI(r,s);break;case"blue":d[3*b+2]=this._normalizeCI(r,s)}}b++}for(let e=0;e<d.length;e++)d[e]=Math.pow(d[e],this.contrastFactor);const g=new BufferGeometry;return g.setAttribute("position",new BufferAttribute(f,3)),g.setAttribute("color",new BufferAttribute(d,3)),g.setAttribute("intensity",new BufferAttribute(m,1)),g}catch(e){return null}}_isPDAL(e){return!!e.schema&&!e.attributes}_getTileDepth(e,t,s){return s?Math.max(0,e.length-1):this._isPDAL(t)?parseInt(e.split("-")[0],10):e.split("-").length-1}async _probePotreeLayout(e,t){if(console.warn("Probing existence of folders and extensions for Potree Layout!"),t._potreeLayout)return t._potreeLayout;const s={isPotree:!0,tileFolder:null,tileExt:null,hasEmbeddedHierarchy:!!t.hierarchy,hasBinaryHierarchy:!1};if(this.localBlobs){for(const e of Object.keys(this.localBlobs))"r.bin"===e?s.tileExt=".bin":"r.las"===e?s.tileExt=".las":"r.laz"===e?s.tileExt=".laz":"r.hrc"===e&&(s.hasBinaryHierarchy=!0);return s.tileExt||(s.tileExt=".bin"),t._potreeLayout=s,t.dataType=".bin"===s.tileExt?"binary":".laz"===s.tileExt?"laszip":"las",s}const r=["data/r/","data/"];let i=null;for(const t of r){const r=`${e}${t}r.bin`;try{if((await fetch(r,{method:"HEAD"})).ok){i=t,s.tileExt=".bin";break}}catch(e){continue}}if(!i)for(const t of r){const r=`${e}${t}r.laz`;try{if((await fetch(r,{method:"HEAD"})).ok){i=t,s.tileExt=".laz";break}}catch(e){continue}}if(!i)for(const t of r){const r=`${e}${t}r.las`;try{if((await fetch(r,{method:"HEAD"})).ok){i=t,s.tileExt=".las";break}}catch(e){continue}}if(s.tileFolder=i||"data/r/",s.tileExt||(s.tileExt=".bin"),!s.hasEmbeddedHierarchy){const t=`${e}${s.tileFolder}r.hrc`;try{const e=await fetch(t,{method:"HEAD"});s.hasBinaryHierarchy=e.ok}catch(e){s.hasBinaryHierarchy=!1}}return t._potreeLayout=s,t.dataType=".bin"===s.tileExt?"binary":".laz"===s.tileExt?"laszip":"las",s}_potreeChildIndexToXYZ(e){return{x:4&e?1:0,y:2&e?1:0,z:1&e?1:0}}_computePotreeTileBounds(e,t){let s={x:t[0],y:t[1],z:t[2]},r={x:t[3],y:t[4],z:t[5]};for(let t=1;t<e.length;t++){const i=parseInt(e[t],10),{x:n,y:a,z:o}=this._potreeChildIndexToXYZ(i),l={x:(r.x-s.x)/2,y:(r.y-s.y)/2,z:(r.z-s.z)/2};s.x+=l.x*n,s.y+=l.y*a,s.z+=l.z*o,r.x=s.x+l.x,r.y=s.y+l.y,r.z=s.z+l.z}return{min:s,max:r}}async _loadHierarchyForDepth(e){try{const t=await fetch(e);return t.ok?await t.json():null}catch{return null}}async _loadPotreeBinaryHierarchy(e,t){try{const s=await fetch(e);if(!s.ok)return null;const r=await s.arrayBuffer(),i=new DataView(r),n={},a=5;let o=[t],l=0;for(console.log("buffer.byteLength ",r.byteLength);o.length>0&&l+a<=r.byteLength;){const e=o.shift(),t=i.getUint8(l),s=i.getUint32(l+1,!0);n[e]=s;for(let s=0;s<8;s++)0!=(t&1<<s)&&o.push(e+s);l+=a}return n}catch(e){return console.error("Potree Hierarchy Error: ",e),null}}async _discoverHierarchy(e,t,s,r,i){if(i&&t.hierarchy&&"r"===e)return console.log("Using embedded hierarchy from cloud.js"),void t.hierarchy.forEach((e=>{const[t,s,i]=e;r[t]=i}));if(this._getTileDepth(e,t,i)>this.lodDepthLimit)return;let n;if(i){const r=t._potreeLayout.tileFolder,i=".hrc";n=this.localBlobs?this.localBlobs[`${e}${i}`]:`${s}${r}${e}${i}`}else n=this.localBlobs?this.localBlobs[`${e}.json`]:`${s}ept-hierarchy/${e}.json`;const a=i?t._potreeLayout.hasBinaryHierarchy?await this._loadPotreeBinaryHierarchy(n,e):null:await this._loadHierarchyForDepth(n);if(a){Object.assign(r,a);for(const e of Object.keys(a)){i&&(this.potreeTileBounds[e]=this._computePotreeTileBounds(e,t.bounds));const n=this._getTileDepth(e,t,i);-1===a[e]&&n<=this.lodDepthLimit&&await this._discoverHierarchy(e,t,s,r,i)}}}_mortonSort(e,t){return e.sort(((e,s)=>{if(t)return e.length!==s.length?e.length-s.length:e.localeCompare(s);{const[t,r,i,n]=e.split("-").map(Number),[a,o,l,c]=s.split("-").map(Number);if(t!==a)return t-a;return(r<<40|i<<20|n)-(o<<40|l<<20|c)}}))}async _mapWithConcurrency(e,t,s,r){console.log("Requesting tiles with concurrency limit of ",t);const i=new Array(e.length),n=e.indexOf(r?"r":"0-0-0-0");n>0&&([e[0],e[n]]=[e[n],e[0]]),i[0]=await s(e[0]);let a=1;const o=async()=>{for(;;){const t=a++;if(t>=e.length)break;const r=e[t];try{i[t]=await s(r)}catch(e){console.warn("Task failed for item:",r,e),i[t]=null}}},l=[],c=Math.min(t,e.length);for(let e=0;e<c;e++)l.push(o());return await Promise.all(l),i}load(e,t,s,r){try{this.parse(e,t,r)}catch(e){r?r(e):console.error(e)}}async parse(e,t,s){const r={POSITION_CARTESIAN:[{name:"x",type:"uint32",size:4},{name:"y",type:"uint32",size:4},{name:"z",type:"uint32",size:4}],NORMAL:[{name:"normal_x",type:"float",size:4},{name:"normal_y",type:"float",size:4},{name:"normal_z",type:"float",size:4}],NORMAL_FLOATS:[{name:"normal_x",type:"float",size:4},{name:"normal_y",type:"float",size:4},{name:"normal_z",type:"float",size:4}],NORMAL_OCT16:[{name:"normal",type:"unsigned",size:2}],NORMAL_SPHEREMAPPED:[{name:"normal",type:"unsigned",size:2}],COLOR_PACKED:[{name:"red",type:"uint8",size:1},{name:"green",type:"uint8",size:1},{name:"blue",type:"uint8",size:1},{name:"alpha",type:"uint8",size:1}],RGBA_PACKED:[{name:"red",type:"uint8",size:1},{name:"green",type:"uint8",size:1},{name:"blue",type:"uint8",size:1},{name:"alpha",type:"uint8",size:1}],RGB_PACKED:[{name:"red",type:"uint8",size:1},{name:"green",type:"uint8",size:1},{name:"blue",type:"uint8",size:1}],INTENSITY:[{name:"intensity",type:"uint16",size:2}],CLASSIFICATION:[{name:"classification",type:"uint8",size:1}]};let i,n,a,o=!1;try{if(i=await fetch(e),!i.ok)return s&&s({type:"network",message:"Bad response for ept.json"}),!1;n=await i.json()}catch(e){return s?s({type:"exception",message:e.toString()}):console.error({type:"exception",message:e.toString()}),!1}let l=!1;if(n.pointAttributes&&(l=!0),a=e.replace(l?"cloud.js":"ept.json",""),l){const e=[];if(Array.isArray(n.pointAttributes))for(const t of n.pointAttributes){const s=r[t];s&&e.push(...s)}else if("LAS"===n.pointAttributes)n.isPotreeLAS=!0;else if("LAZ"===n.pointAttributes)n.isPotreeLAZ=!0;else{const t=r[n.pointAttributes];t&&e.push(...t)}n.schema=e,await this._probePotreeLayout(a,n);const t=n.boundingBox;n.bounds=[t.lx,t.ly,t.lz,t.ux,t.uy,t.uz];const s=n.scale||1;n.scale=[s,s,s],n.offset=n.offset||[t.lx,t.ly,t.lz]}if("zstandard"===n.dataType&&!this.zdecompressor)return s?s({type:"unsupported",message:"Zstandard requires a decompressor"}):console.error({type:"unsupported",message:"Zstandard requires a decompressor"}),!1;this.globalMinZ=n.bounds?.[2],this.globalMaxZ=n.bounds?.[5];let c={};await this._discoverHierarchy(l?"r":"0-0-0-0",n,a,c,l);const u=Object.keys(c);console.log("Total Tiles:",u.length);let h=u.filter((e=>this._getTileDepth(e,n,l)<=this.lodDepthLimit)),y=h.length;h=this._mortonSort(h,l),console.log("Selected Tiles:",y);const p=this.localBlobs?9:4;return await this._mapWithConcurrency(h,p,(async e=>{let r;try{const i=l?n._potreeLayout.tileExt:"binary"===n.dataType?".bin":"zstandard"===n.dataType?".zst":".laz",c=l?n._potreeLayout.tileFolder:"ept-data/",u=`${a}${c}${e}${i}`,h=this.localBlobs?this.localBlobs[`${e}${i}`]:u,p=await fetch(h);if(!p.ok)return void(s?s({type:"network",message:"Fetching URL failed with status: "+p.status}):console.error({type:"network",message:"Fetching URL failed with status: "+p.status}));if(r=await p.arrayBuffer(),r.byteLength<=150){if((new TextDecoder).decode(r).includes("git-lfs.github.com/spec"))return void(o=!0)}let f;if(".bin"===i)f=await this._loadBinTile(r,n,e,l);else if(".zst"===i){let t;const s=new Uint8Array(r);if(t=this.zdecompressor.decode?await this.zdecompressor.decode(s):await this.zdecompressor.decompress(s),!(t instanceof Uint8Array))throw new Error("Zstd decompressor must return a Uint8Array");const i=0===t.byteOffset&&t.byteLength===t.buffer.byteLength?t.buffer:t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);f=await this._loadBinTile(i,n,e,l)}else f=await this.lasLoader.parse(r);f&&t&&(console.log("Tile ",e+i),t(f,y,e))}catch(t){console.warn(`Tile ${e} failed to load:`,t),y-=1}}),l),o&&(s?s("Files are Git LFS pointers. Data not loaded."):console.error("Files are Git LFS pointers. Data not loaded.")),!0}}export{EPTStreamLoader};