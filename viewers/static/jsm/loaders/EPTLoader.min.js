import{BufferAttribute,BufferGeometry,Loader}from"three";import{LASZLoader}from"./LASZLoader.min.js";const GIT_LFS_THRESHOLD_BYTES=150;class EPTLoader extends Loader{constructor(t){super(t),this.localBlobs=null,this.lodDepthLimit=0,this.lasLoader=new LASZLoader(t)}setLocalBlobMap(t){return this.localBlobs=t,this}setTileDepthLimit(t){return t=Number.isInteger(t)?Math.max(Math.min(t,8),0):0,this.lodDepthLimit=t,this}setSkipPoints(t){return t=Number.isInteger(t)?Math.max(Math.min(t,100),1):1,this.lasLoader.setSkipPoints(t),this}setSkipColor(t){return this.lasLoader.setSkipColor(t),this}setSkipIntensity(t){return this.lasLoader.setSkipIntensity(t),this}setSkipClassification(t){return this.lasLoader.setSkipClassification(t),this}setIntensityGammaFactor(t){return t=Number(t),(!isFinite(t)||t<=0)&&(t=1),t=Math.min(Math.max(t,.1),2),this.lasLoader.setIntensityGammaFactor(t),this}setApplyIntensityToColor(t){return this.lasLoader.setApplyIntensityToColor(t),this}concatFloat32(t){let e=0;for(const s of t)e+=s.length;const s=new Float32Array(e);let i=0;for(const e of t)s.set(e,i),i+=e.length;return s}mergeGeometries(t){const e=[],s=[],i=[],r=[];let o=!1,a=!1,n=!1;for(const l of t){const t=l.getAttribute("position");t&&e.push(t.array);const c=l.getAttribute("color");c&&(o=!0,s.push(c.array));const h=l.getAttribute("intensity");h&&(a=!0,i.push(h.array));const u=l.getAttribute("classification");u&&(n=!0,r.push(u.array))}const l=new BufferGeometry;return l.setAttribute("position",new BufferAttribute(this.concatFloat32(e),3)),o&&l.setAttribute("color",new BufferAttribute(this.concatFloat32(s),3)),a&&l.setAttribute("intensity",new BufferAttribute(this.concatFloat32(i),1)),n&&l.setAttribute("classification",new BufferAttribute(this.concatFloat32(r),1)),l.computeBoundingBox(),l.computeBoundingSphere(),l}sizeOf(t){switch(t.type){case"int32":case"uint32":case"float":return 4;case"uint16":return 2;case"uint8":return 1;case"signed":case"unsigned":return t.size;default:return 0}}async loadBinTile(t,e){try{const s=new DataView(t),i=e.attributes||e.schema,r=e.scale,o=e.offset;let a=0;for(const t of i)a+=this.sizeOf(t);const n=t.byteLength/a,l=new Float32Array(3*n),c=new Float32Array(3*n),h=new Float32Array(n);for(let t=0;t<n;t++){let e=t*a;for(const a of i){switch(a.name.toLowerCase()){case"x":l[3*t+0]=s.getInt32(e,!0)*(a.scale||r[0])+(a.offset||o[0]),e+=4;break;case"y":l[3*t+1]=s.getInt32(e,!0)*(a.scale||r[1])+(a.offset||o[1]),e+=4;break;case"z":l[3*t+2]=s.getInt32(e,!0)*(a.scale||r[2])+(a.offset||o[2]),e+=4;break;case"intensity":h[t]=s.getUint16(e,!0),e+=2;break;case"red":c[3*t+0]=s.getUint16(e,!0)/(2===a.size?255:65535),e+=2;break;case"green":c[3*t+1]=s.getUint16(e,!0)/(2===a.size?255:65535),e+=2;break;case"blue":c[3*t+2]=s.getUint16(e,!0)/(2===a.size?255:65535),e+=2;break;default:e+=this.sizeOf(a)}}}const u=new BufferGeometry;return u.setAttribute("position",new BufferAttribute(l,3)),u.setAttribute("color",new BufferAttribute(c,3)),u.setAttribute("intensity",new BufferAttribute(h,1)),u}catch(t){return null}}isPDAL(t){return!!t.schema&&!t.attributes}getTileDepth(t,e){return this.isPDAL(e)?parseInt(t.split("-")[0],10):t.split("-").length-1}async _loadHierarchyForDepth(t){try{const e=await fetch(t);return e.ok?await e.json():null}catch{return null}}async discoverHierarchy(t,e,s,i){if(this.getTileDepth(t,e)>this.lodDepthLimit)return;const r=this.localBlobs?this.localBlobs[`${t}.json`]:`${s}ept-hierarchy/${t}.json`,o=await this._loadHierarchyForDepth(r);if(o){Object.assign(i,o);for(const t of Object.keys(o)){const r=this.getTileDepth(t,e);-1===o[t]&&r<=this.lodDepthLimit&&await this.discoverHierarchy(t,e,s,i)}}}async _mapWithConcurrency(t,e,s){console.log("Requesting tiles with concurrency limit of ",e);const i=new Array(t.length);let r=0;const o=async()=>{for(;;){const e=r++;if(e>=t.length)break;const o=t[e];try{i[e]=await s(o)}catch(t){console.warn("Task failed for item:",o,t),i[e]=null}}},a=[],n=Math.min(e,t.length);for(let t=0;t<n;t++)a.push(o());return await Promise.all(a),i}load(t,e,s,i){this.parse(t).then((t=>e(t))).catch((t=>{i?i(t):console.error(t)}))}async parse(t){let e,s;try{e=await(await fetch(t)).json(),s=this.base||t.replace("ept.json","")}catch(e){throw new Error("Failed to load url: "+t+" "+e)}let i={};await this.discoverHierarchy("0-0-0-0",e,s,i);const r=Object.keys(i);console.log("Total Tiles:",r.length);const o=r.filter((t=>this.getTileDepth(t,e)<=this.lodDepthLimit));console.log("Selected Tiles:",o.length);let a=!1,n=0;const l=(await this._mapWithConcurrency(o,4,(async t=>{if(console.log(n++),"zstandard"===e.dataType)return null;if("binary"===e.dataType){const i=s+"ept-data/"+t+".bin",r=this.localBlobs?this.localBlobs[`${t}.bin`]:i;try{const t=await fetch(r);if(!t.ok)return null;const s=await t.arrayBuffer();if(s.byteLength<=150){if((new TextDecoder).decode(s).includes("git-lfs.github.com/spec"))return console.warn("The selected file is stored in Git LFS!"),a=!0,null}const i=await this.loadBinTile(s,e);if(i)return i}catch(t){console.warn("BIN load failed:",r,t)}return null}{const e=s+"ept-data/"+t+".laz",i=this.localBlobs?this.localBlobs[`${t}.laz`]:e;try{const t=await fetch(i);if(!t.ok)return null;const e=await t.arrayBuffer();if(e.byteLength<=150){if((new TextDecoder).decode(e).includes("git-lfs.github.com/spec"))return console.warn("The selected file is stored in Git LFS!"),a=!0,null}return await this.lasLoader.parse(e)}catch(t){console.warn("LAZ load failed:",i,t)}}}))).filter((t=>t));if(0===l.length)throw new Error("No EPT tiles could be loaded."+(a?" Files stored in Git LFS!":""));return this.mergeGeometries(l)}}export{EPTLoader};