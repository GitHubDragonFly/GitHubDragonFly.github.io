import{BufferAttribute,BufferGeometry,Loader}from"three";import{LASZLoader}from"./LASZLoader.min.js";const GIT_LFS_THRESHOLD_BYTES=150;class EPTLoader extends Loader{constructor(t){super(t),this.skipPoints=1,this.lodDepthLimit=0,this.localBlobs=null,this.contrastFactor=1,this.lasLoader=new LASZLoader(t)}setLocalBlobMap(t){return this.localBlobs=t,this}setTileDepthLimit(t){return t=Number.isInteger(t)?Math.max(Math.min(t,8),0):0,this.lodDepthLimit=t,this}setSkipPoints(t){return t=Number.isInteger(t)?Math.max(Math.min(t,100),1):1,this.lasLoader.setSkipPoints(t),this.skipPoints=t,this}setSkipColor(t){return this.lasLoader.setSkipColor(t),this}setSkipIntensity(t){return this.lasLoader.setSkipIntensity(t),this}setSkipClassification(t){return this.lasLoader.setSkipClassification(t),this}setIntensityGammaFactor(t){return t=Number(t),(!isFinite(t)||t<=0)&&(t=1),t=Math.min(Math.max(t,.1),2),this.lasLoader.setIntensityGammaFactor(t),this.contrastFactor=t,this}setApplyIntensityToColor(t){return this.lasLoader.setApplyIntensityToColor(t),this}concatFloat32(t){let e=0,r=0;for(const r of t)e+=r.length;const s=new Float32Array(e);for(const e of t)s.set(e,r),r+=e.length;return s}mergeGeometries(t){const e=[],r=[],s=[],i=[];let n=!1,a=!1,o=!1;for(const c of t){const t=c.getAttribute("position");t&&e.push(t.array);const l=c.getAttribute("color");l&&(n=!0,r.push(l.array));const u=c.getAttribute("intensity");u&&(a=!0,s.push(u.array));const h=c.getAttribute("classification");h&&(o=!0,i.push(h.array))}const c=new BufferGeometry;return c.setAttribute("position",new BufferAttribute(this.concatFloat32(e),3)),n&&c.setAttribute("color",new BufferAttribute(this.concatFloat32(r),3)),a&&c.setAttribute("intensity",new BufferAttribute(this.concatFloat32(s),1)),o&&c.setAttribute("classification",new BufferAttribute(this.concatFloat32(i),1)),c.computeBoundingBox(),c.computeBoundingSphere(),c}getValue(t,e,r,s,i=!0){switch(r.toLowerCase()){case"int8":return t.getInt8(e);case"uint8":return t.getUint8(e);case"int16":return t.getInt16(e,i);case"uint16":return t.getUint16(e,i);case"int32":return t.getInt32(e,i);case"uint32":return t.getUint32(e,i);case"float":case"float32":return t.getFloat32(e,i);case"int64":return Number(t.getBigInt64(e,i));case"uint64":return Number(t.getBigUint64(e,i));case"double":case"float64":return t.getFloat64(e,i);case"integer":case"scaledinteger":case"signed":case"unsigned":switch(s){case 1:return"unsigned"===r?t.getUint8(e):t.getInt8(e);case 2:return"unsigned"===r?t.getUint16(e,i):t.getInt16(e,i);case 4:return"unsigned"===r?t.getUint32(e,i):t.getInt32(e,i);case 8:return Number("unsigned"===r?t.getBigUint64(e,i):t.getBigInt64(e,i));default:return console.warn("Unsupported integer size:",a.size),0}default:return console.warn("Unknown attribute type:",r),0}}sizeOf(t){switch(t.type.toLowerCase()){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float":case"float32":return 4;case"int64":case"uint64":case"float64":case"double":return 8;case"signed":case"unsigned":case"integer":case"scaledinteger":return t.size;default:return console.warn("Unknown EPT attribute type:",t.type),0}}normalizeCI(t,e){let r;return r=1===e.size?t/255:2===e.size?t<=255?t/255:t/65535:t,Math.min(1,r)}async loadBinTile(t,e){try{const r=new DataView(t),s=e.attributes||e.schema,i=e.scale||[1,1,1],n=e.offset||[0,0,0];let a=0;const o=[];for(const t of s){const e=this.sizeOf(t),r=t.type.toLowerCase(),s=t.name.toLowerCase();o.push({name:s,type:r,size:e,byteOffset:a,raw:t}),a+=e}if(0===a)return null;const c=t.byteLength/a|0,l=this.skipPoints&&this.skipPoints>1?this.skipPoints:1,u=Math.ceil(c/l),h=new Float32Array(3*u),f=new Float32Array(3*u),p=new Float32Array(u);let d=0;for(let t=0;t<c;t+=l){const e=t*a;for(const t of o){const s=t.raw,a=this.getValue(r,e+t.byteOffset,t.type,t.size,!0);switch(t.name){case"x":h[3*d+0]=a*(i[0]||s.scale)+(n[0]||s.offset);break;case"y":h[3*d+1]=a*(i[1]||s.scale)+(n[1]||s.offset);break;case"z":h[3*d+2]=a*(i[2]||s.scale)+(n[2]||s.offset);break;case"intensity":p[d]=this.normalizeCI(a,s);break;case"red":f[3*d+0]=this.normalizeCI(a,s);break;case"green":f[3*d+1]=this.normalizeCI(a,s);break;case"blue":f[3*d+2]=this.normalizeCI(a,s)}}d++}for(let t=0;t<f.length;t++)f[t]=Math.pow(f[t],this.contrastFactor);const g=new BufferGeometry;return g.setAttribute("position",new BufferAttribute(h,3)),g.setAttribute("color",new BufferAttribute(f,3)),g.setAttribute("intensity",new BufferAttribute(p,1)),g}catch(t){return null}}isPDAL(t){return!!t.schema&&!t.attributes}getTileDepth(t,e){return this.isPDAL(e)?parseInt(t.split("-")[0],10):t.split("-").length-1}async _loadHierarchyForDepth(t){try{const e=await fetch(t);return e.ok?await e.json():null}catch{return null}}async discoverHierarchy(t,e,r,s){if(this.getTileDepth(t,e)>this.lodDepthLimit)return;const i=this.localBlobs?this.localBlobs[`${t}.json`]:`${r}ept-hierarchy/${t}.json`,n=await this._loadHierarchyForDepth(i);if(n){Object.assign(s,n);for(const t of Object.keys(n)){const i=this.getTileDepth(t,e);-1===n[t]&&i<=this.lodDepthLimit&&await this.discoverHierarchy(t,e,r,s)}}}mortonSort(t){return t.sort(((t,e)=>{const[r,s,i,n]=t.split("-").map(Number),[a,o,c,l]=e.split("-").map(Number);if(r!==a)return r-a;return(s<<40|i<<20|n)-(o<<40|c<<20|l)}))}async _mapWithConcurrency(t,e,r){console.log("Requesting tiles with concurrency limit of ",e);const s=new Array(t.length),i=t.indexOf("0-0-0-0");i>0&&([t[0],t[i]]=[t[i],t[0]]),s[0]=await r(t[0]);let n=1;const a=async()=>{for(;;){const e=n++;if(e>=t.length)break;const i=t[e];try{s[e]=await r(i)}catch(t){console.warn("Task failed for item:",i,t),s[e]=null}}},o=[],c=Math.min(e,t.length);for(let t=0;t<c;t++)o.push(a());return await Promise.all(o),s}load(t,e,r,s){this.parse(t).then((t=>e(t))).catch((t=>{s?s(t):console.error(t)}))}async parse(t){let e,r,s,i=!1;try{if(e=await fetch(t),!e.ok)return;r=await e.json(),s=t.replace("ept.json","")}catch(e){throw new Error("Failed to load url: "+t+" "+e)}if("zstandard"===r.dataType)throw new Error("Unsupported data type: zstandard");let n={};await this.discoverHierarchy("0-0-0-0",r,s,n);const a=Object.keys(n);console.log("Total Tiles:",a.length);let o=a.filter((t=>this.getTileDepth(t,r)<=this.lodDepthLimit));o=this.mortonSort(o),console.log("Selected Tiles:",o.length);const c=this.localBlobs?9:4,l=(await this._mapWithConcurrency(o,c,(async t=>{let n;console.log("Tile ",t);try{const a="binary"===r.dataType?".bin":".laz",o=`${s}ept-data/${t}${a}`,c=this.localBlobs?this.localBlobs[`${t}${a}`]:o;if(e=await fetch(c),!e.ok)return;if(n=await e.arrayBuffer(),n.byteLength<=150){if((new TextDecoder).decode(n).includes("git-lfs.github.com/spec"))return void(i=!0)}if(".bin"!==a)return await this.lasLoader.parse(n);{const t=await this.loadBinTile(n,r);if(t)return t}}catch(e){console.warn(`Tile ${t} failed to load:`,e)}return null}))).filter((t=>t));if(0===l.length)throw new Error("No EPT tiles could be loaded."+(i?" Files stored in Git LFS!":""));return this.mergeGeometries(l)}}export{EPTLoader};