import{BufferGeometry,FileLoader,Float32BufferAttribute,Loader}from 'three';import{LASLoader as LoadersGLLASLoader}from 'loaders-las';import{load as LASLoad}from 'loaders-core';class LASZLoader extends Loader{constructor(manager){super(manager);this.options={skipPoints:1,skipColor:!1,skipIntensity:!1,skipClassification:!1}}
setSkipPoints(sp){if(!Number.isInteger(sp)){sp=1}else{sp=Math.max(Math.min(sp,10),1)}
this.options.skipPoints=sp;return this}
setSkipColor(flag){this.options.skipColor=flag;return this}
setSkipIntensity(flag){this.options.skipIntensity=flag;return this}
setSkipClassification(flag){this.options.skipClassification=flag;return this}
load(url,onLoad,onProgress,onError){const scope=this;const loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.setResponseType('arraybuffer');loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,buffer=>{if(buffer.byteLength<=150){const text=new TextDecoder().decode(buffer);if(text.startsWith('version https://git-lfs.github.com/spec')){alert('The selected file is stored in Git LFS!');if(onError){onError('The selected file is stored in Git LFS!');return}else{console.error('The selected file is stored in Git LFS!');return}}}
scope.parse(buffer).then(geometry=>onLoad(geometry)).catch(err=>{if(onError)onError(err);else console.error(err)})},onProgress,onError)}
async parse(buffer){const options={worker:!0,CDN:'https://cdn.jsdelivr.net/npm/@loaders.gl',las:{skip:this.options.skipPoints,colorDepth:'auto'}};const data=await LASLoad(buffer,LoadersGLLASLoader,options);if(!data.attributes.POSITION?.value){throw new Error('LAS/LAZ file missing POSITION attribute!')}
const geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(data.attributes.POSITION.value,3));if(data.attributes.COLOR_0?.value&&!this.options.skipColor){const normalized=new Float32Array(data.attributes.COLOR_0.value.length);let max=0;for(let i=0;i<data.attributes.COLOR_0.value.length;i++){if(data.attributes.COLOR_0.value[i]>max){max=data.attributes.COLOR_0.value[i]}}
if(max===0)max=1.0;const invMax=1.0/max;for(let i=0;i<data.attributes.COLOR_0.value.length;i++){normalized[i]=data.attributes.COLOR_0.value[i]*invMax}
geometry.setAttribute('color',new Float32BufferAttribute(normalized,3))}
if(data.attributes.intensity?.value&&!this.options.skipIntensity){let maxI=0;for(let i=0;i<data.attributes.intensity.value.length;i++){if(data.attributes.intensity.value[i]>maxI){maxI=data.attributes.intensity.value[i]}}
if(maxI===0)maxI=1.0;const invMaxI=1.0/maxI;const normalizedI=new Float32Array(data.attributes.intensity.value.length);for(let i=0;i<data.attributes.intensity.value.length;i++){normalizedI[i]=data.attributes.intensity.value[i]*invMaxI}
geometry.setAttribute('intensity',new Float32BufferAttribute(normalizedI,1))}
if(data.attributes.classification?.value&&!this.options.skipClassification){geometry.setAttribute('classification',new Float32BufferAttribute(data.attributes.classification.value,1))}
geometry.computeBoundingBox();geometry.computeBoundingSphere();for(const key in data){delete data[key]}
return geometry}}
export{LASZLoader}