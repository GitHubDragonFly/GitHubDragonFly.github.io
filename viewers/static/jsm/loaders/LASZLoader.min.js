import{BufferAttribute,BufferGeometry,FileLoader,Loader}from"three";import{LASLoader as LoadersGLLASLoader}from"loaders-las";import{load as LASLoad}from"loaders-core";class LASZLoader extends Loader{constructor(t){super(t),this.options={skipPoints:1,skipColor:!1,skipIntensity:!1,skipClassification:!1,intensityGammaFactor:1,applyIntensityToColor:!0}}setSkipPoints(t){return t=Number.isInteger(t)?Math.max(Math.min(t,10),1):1,this.options.skipPoints=t,this}setSkipColor(t){return this.options.skipColor=t,this}setSkipIntensity(t){return this.options.skipIntensity=t,this}setSkipClassification(t){return this.options.skipClassification=t,this}setIntensityGammaFactor(t){return t=Number(t),(!isFinite(t)||t<=0)&&(t=1),t=Math.min(Math.max(t,.1),2),this.options.intensityGammaFactor=t,this}setApplyIntensityToColor(t){return this.options.applyIntensityToColor=t,this}load(t,e,i,s){const o=this,r=new FileLoader(o.manager);r.setPath(o.path),r.setResponseType("arraybuffer"),r.setRequestHeader(o.requestHeader),r.setWithCredentials(o.withCredentials),r.load(t,(t=>{if(t.byteLength<=150){if((new TextDecoder).decode(t).startsWith("version https://git-lfs.github.com/spec"))return alert("The selected file is stored in Git LFS!"),s?void s("The selected file is stored in Git LFS!"):void console.error("The selected file is stored in Git LFS!")}o.parse(t).then((t=>e(t))).catch((t=>{s?s(t):console.error(t)}))}),i,s)}async parse(t){const e={worker:!0,CDN:"https://cdn.jsdelivr.net/npm/@loaders.gl",las:{skip:this.options.skipPoints,colorDepth:"auto"}},i=await LASLoad(t,LoadersGLLASLoader,e);if(!i.attributes.POSITION?.value)throw new Error("LAS/LAZ file missing POSITION attribute!");const s=new BufferGeometry;if(s.setAttribute("position",new BufferAttribute(i.attributes.POSITION.value,3)),i.attributes.COLOR_0?.value&&!this.options.skipColor){const t=new Float32Array(i.attributes.COLOR_0.value.length);let e=0;for(let t=0;t<i.attributes.COLOR_0.value.length;t++)i.attributes.COLOR_0.value[t]>e&&(e=i.attributes.COLOR_0.value[t]);0===e&&(e=1);const o=1/e;for(let e=0;e<i.attributes.COLOR_0.value.length;e++)t[e]=i.attributes.COLOR_0.value[e]*o;if(i.attributes.intensity?.value&&!this.options.skipIntensity){let e=0;for(let t=0;t<i.attributes.intensity.value.length;t++)i.attributes.intensity.value[t]>e&&(e=i.attributes.intensity.value[t]);0===e&&(e=1);const o=1/e,r=new Float32Array(i.attributes.intensity.value.length);for(let t=0;t<i.attributes.intensity.value.length;t++)r[t]=i.attributes.intensity.value[t]*o;if(this.options.applyIntensityToColor){const e=this.options.intensityGammaFactor;for(let i=0;i<r.length;i++){const s=Math.pow(r[i],e);t[3*i+0]*=s,t[3*i+1]*=s,t[3*i+2]*=s}}s.userData.intensityMax=e,s.setAttribute("intensity",new BufferAttribute(r,1))}s.setAttribute("color",new BufferAttribute(t,3))}i.attributes.classification?.value&&!this.options.skipClassification&&s.setAttribute("classification",new BufferAttribute(i.attributes.classification.value,1)),s.computeBoundingBox(),s.computeBoundingSphere();for(const t in i)delete i[t];return s}}export{LASZLoader};