import{BufferAttribute,BufferGeometry,ClampToEdgeWrapping,FileLoader,Group,NoColorSpace,Loader,Mesh,MeshPhysicalMaterial,MirroredRepeatWrapping,RepeatWrapping,SRGBColorSpace,TextureLoader,Object3D,Vector2}from"three";import*as fflate from"https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/libs/fflate.module.min.js";class USDAParser{parse(e){const t={},o=e.split("\n");let r,n,a,s,i,c=null,l=t;const p=[t];return function(){for(const e of o)if(""!==e.trim())if(e.includes("="))if(i=e.split("="),a=i[0].trim(),s=i[1].trim(),s.endsWith("{"))r={},p.push(r),l[a]=r,l=r;else if(s.endsWith("(")){const e=s.slice(0,-1);l[a]=e;const t={};p.push(t),l=t}else l[a]=s;else if(e.endsWith("{"))r=l[c]||{},p.push(r),l[c]=r,l=r;else if(e.endsWith("}")){if(p.pop(),0===p.length)continue;l=p[p.length-1]}else if(e.endsWith("("))n={},p.push(n),c=e.split("(")[0].trim()||c,l[c]=n,l=n;else if(e.endsWith(")")){if(p.pop(),0===p.length)continue;l=p[p.length-1]}else c=e.trim()}(),t}}class USDZLoader extends Loader{constructor(e){super(e)}load(e,t,o,r){const n=this,a=new FileLoader(n.manager);a.setPath(n.path),a.setResponseType("arraybuffer"),a.setRequestHeader(n.requestHeader),a.setWithCredentials(n.withCredentials),a.load(e,(function(o){try{t(n.parse(o))}catch(t){r&&r(t),n.manager.itemError(e)}}),o,r)}parse(e){const t=new USDAParser;function o(e){const t=e.slice(0,7),o=new Uint8Array([80,88,82,45,85,83,68,67]);return t.every(((e,t)=>e===o[t]))}const r=fflate.unzipSync(new Uint8Array(e)),n=function(e){const r={};(new FileLoader).setResponseType("arraybuffer");for(const n in e){if(n.endsWith("png")){const t=new Blob([e[n]],{type:{type:"image/png"}});r[n]=URL.createObjectURL(t)}if(n.endsWith("usd")||n.endsWith("usda")){if(o(e[n]))continue;const a=fflate.strFromU8(e[n]);r[n]=t.parse(a)}}return r}(r),a=function(e){if(e.length<1)return;const t=Object.keys(e)[0];let r=!1;if(t.endsWith("usda"))return e[t];if(t.endsWith("usdc"))r=!0;else if(t.endsWith("usd")){if(!o(e[t]))return e[t];r=!0}}(r);if(void 0===a)throw new Error("THREE.USDZLoader: No usda file found.");const s=fflate.strFromU8(a),i=t.parse(s);function c(e,t){if(e){if(void 0!==t){const o=`def Mesh "${t}"`;if(o in e)return e[o]}for(const t in e){const o=e[t];if(t.startsWith("def Mesh"))return o;if("object"==typeof o){const e=c(o);if(e)return e}}}}function l(e){if(!e)return;let t=new BufferGeometry,o=null;if("point3f[] points"in e){const o=JSON.parse(e["point3f[] points"].replace(/[()]*/g,"")),r=new BufferAttribute(new Float32Array(o),3);t.setAttribute("position",r)}if("normal3f[] normals"in e){const o=JSON.parse(e["normal3f[] normals"].replace(/[()]*/g,"")),r=new BufferAttribute(new Float32Array(o),3);t.setAttribute("normal",r)}else t.computeVertexNormals(),t.normalizeNormals();if("color3f[] primvars:displayColor"in e){const o=JSON.parse(e["color3f[] primvars:displayColor"].replace(/[()]*/g,""));if(Array.isArray(o)&&o.some((e=>parseFloat(e)<1))){const e=new BufferAttribute(new Float32Array(o),3);t.setAttribute("color",e)}}if("float2[] primvars:st"in e&&(e["texCoord2f[] primvars:st"]=e["float2[] primvars:st"]),"texCoord2f[] primvars:st"in e){o=JSON.parse(e["texCoord2f[] primvars:st"].replace(/[()]*/g,""));const r=new BufferAttribute(new Float32Array(o),2);t.setAttribute("uv",r)}if("int[] faceVertexIndices"in e){const o=JSON.parse(e["int[] faceVertexIndices"]);t.setIndex(o)}if("int[] primvars:st:indices"in e&&null!==o){t=t.toNonIndexed();const r=new BufferAttribute(new Float32Array(o),2),n=JSON.parse(e["int[] primvars:st:indices"]);t.setAttribute("uv",function(e,t){const o=e.array,r=e.itemSize,n=new o.constructor(t.length*r);let a=0,s=0;for(let e=0,i=t.length;e<i;e++){a=t[e]*r;for(let e=0;e<r;e++)n[s++]=o[a++]}return new BufferAttribute(n,r)}(r,n))}return t}function p(e,t=""){for(const o in e){const r=e[o];if(o.startsWith("def Material"+t))return r;if("object"==typeof r){const e=p(r,t);if(e)return e}}}function f(e,t){t["float inputs:rotation"]&&(e.rotation=parseFloat(t["float inputs:rotation"])),t["float2 inputs:scale"]&&(e.repeat=(new Vector2).fromArray(JSON.parse("["+t["float2 inputs:scale"].replace(/[()]*/g,"")+"]"))),t["float2 inputs:translation"]&&(e.offset=(new Vector2).fromArray(JSON.parse("["+t["float2 inputs:translation"].replace(/[()]*/g,"")+"]")))}function u(e,t){for(const o in e){const r=e[o];if(o.startsWith(`def Shader "${t}"`))return r;if("object"==typeof r){const e=u(r,t);if(e)return e}}}function d(e){if("asset inputs:file"in e){const t=e["asset inputs:file"].replace(/@*/g,"").trim(),o=(new TextureLoader).load(n[t]),r={'"clamp"':ClampToEdgeWrapping,'"mirror"':MirroredRepeatWrapping,'"repeat"':RepeatWrapping};return"token inputs:wrapS"in e&&(o.wrapS=r[e["token inputs:wrapS"]]),"token inputs:wrapT"in e&&(o.wrapT=r[e["token inputs:wrapT"]]),o}return null}function m(e){const t=l(function(e){if(e){if("prepend references"in e){const t=e["prepend references"].split("@"),o=t[1].replace(/^.\//,""),r=t[2].replace(/^<\//,"").replace(/>$/,"");return c(n[o],r)}return c(e)}}(e)),o=function(e){const t=new MeshPhysicalMaterial;if(void 0!==e){if('def Shader "PreviewSurface"'in e){const o=e['def Shader "PreviewSurface"'];if("color3f inputs:diffuseColor.connect"in o){if("color3f inputs:diffuseColor"in o){const e=o["color3f inputs:diffuseColor"].replace(/[()]*/g,"");t.color.fromArray(JSON.parse("["+e+"]"))}else t.color.set(16777215);const r=o["color3f inputs:diffuseColor.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.map=d(n),t.map.colorSpace=SRGBColorSpace,'def Shader "Transform2d_diffuse"'in e&&f(t.map,e['def Shader "Transform2d_diffuse"'])}else if("color3f inputs:diffuseColor"in o){const e=o["color3f inputs:diffuseColor"].replace(/[()]*/g,"");t.color.fromArray(JSON.parse("["+e+"]"))}if("color3f inputs:emissiveColor.connect"in o){if("color3f inputs:emissiveColor"in o){const e=o["color3f inputs:emissiveColor"].replace(/[()]*/g,"");t.emissive.fromArray(JSON.parse("["+e+"]"))}else t.emissive.set(16777215);const r=o["color3f inputs:emissiveColor.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.emissiveMap=d(n),t.emissiveMap.colorSpace=SRGBColorSpace,'def Shader "Transform2d_emissive"'in e&&f(t.emissiveMap,e['def Shader "Transform2d_emissive"'])}else if("color3f inputs:emissiveColor"in o){const e=o["color3f inputs:emissiveColor"].replace(/[()]*/g,"");t.emissive.fromArray(JSON.parse("["+e+"]"))}if("normal3f inputs:normal.connect"in o){const r=o["normal3f inputs:normal.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.normalMap=d(n),t.normalMap.colorSpace=NoColorSpace,'def Shader "Transform2d_normal"'in e&&f(t.normalMap,e['def Shader "Transform2d_normal"'])}if("float inputs:roughness.connect"in o){t.roughness="float inputs:roughness"in o?parseFloat(o["float inputs:roughness"]):1;const r=o["float inputs:roughness.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.roughnessMap=d(n),t.roughnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_roughness"'in e&&f(t.roughnessMap,e['def Shader "Transform2d_roughness"'])}else"float inputs:roughness"in o&&(t.roughness=parseFloat(o["float inputs:roughness"]));if("float inputs:metallic.connect"in o){t.metalness="float inputs:metallic"in o?parseFloat(o["float inputs:metallic"]):1;const r=o["float inputs:metallic.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.metalnessMap=d(n),t.metalnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_metallic"'in e&&f(t.metalnessMap,e['def Shader "Transform2d_metallic"'])}else"float inputs:metallic"in o&&(t.metalness=parseFloat(o["float inputs:metallic"]));if("float inputs:clearcoat.connect"in o){t.clearcoat="float inputs:clearcoat"in o?parseFloat(o["float inputs:clearcoat"]):1;const r=o["float inputs:clearcoat.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.clearcoatMap=d(n),t.clearcoatMap.colorSpace=NoColorSpace,'def Shader "Transform2d_clearcoat"'in e&&f(t.clearcoatMap,e['def Shader "Transform2d_clearcoat"'])}else"float inputs:clearcoat"in o&&(t.clearcoat=parseFloat(o["float inputs:clearcoat"]));if("float inputs:clearcoatRoughness.connect"in o){t.clearcoatRoughness="float inputs:clearcoatRoughness"in o?parseFloat(o["float inputs:clearcoatRoughness"]):1;const r=o["float inputs:clearcoatRoughness.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.clearcoatRoughnessMap=d(n),t.clearcoatRoughnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_clearcoatRoughness"'in e&&f(t.clearcoatRoughnessMap,e['def Shader "Transform2d_clearcoatRoughness"'])}else"float inputs:clearcoatRoughness"in o&&(t.clearcoatRoughness=parseFloat(o["float inputs:clearcoatRoughness"]));if("float inputs:ior"in o&&(t.ior=parseFloat(o["float inputs:ior"])),"float inputs:occlusion.connect"in o){const r=o["float inputs:occlusion.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.aoMap=d(n),t.aoMap.colorSpace=NoColorSpace,'def Shader "Transform2d_occlusion"'in e&&f(t.aoMap,e['def Shader "Transform2d_occlusion"'])}if("float inputs:opacity"in o&&(t.opacity=parseFloat(o["float inputs:opacity"]),t.transparent=t.opacity<1,"float inputs:opacityThreshold"in o)){let r=parseFloat(o["float inputs:opacityThreshold"]);if(.0059===r||.0058===r){if(t.transparent=!1,t.transmission=1,t.opacity=1,.0059===r&&(t.thickness=.01),"float inputs:opacity.connect"in o){const r=o["float inputs:opacity.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.transmissionMap=d(n),t.transmissionMap.colorSpace=NoColorSpace,'def Shader "Transform2d_opacity"'in e&&f(t.transmissionMap,e['def Shader "Transform2d_opacity"'])}}else if(.0057===r){if(t.transparent=!0,t.depthWrite=!1,"float inputs:opacity.connect"in o){const r=o["float inputs:opacity.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.map=d(n),t.map.colorSpace=NoColorSpace,'def Shader "Transform2d_opacity"'in e&&f(t.map,e['def Shader "Transform2d_opacity"'])}}else if(.0056===r){if(t.transparent=!0,t.depthWrite=!1,"float inputs:opacity.connect"in o){const r=o["float inputs:opacity.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.alphaMap=d(n),t.alphaMap.colorSpace=NoColorSpace,'def Shader "Transform2d_opacity"'in e&&f(t.alphaMap,e['def Shader "Transform2d_opacity"'])}}else if(t.alphaTest=r,"float inputs:opacity.connect"in o){const r=o["float inputs:opacity.connect"],n=u(i,/(\w+).output/.exec(r)[1]);t.map=d(n),t.map.colorSpace=NoColorSpace,'def Shader "Transform2d_opacity"'in e&&f(t.map,e['def Shader "Transform2d_opacity"'])}}}if('def Shader "diffuseColor_texture"'in e){const o=e['def Shader "diffuseColor_texture"'];t.map=d(o),t.map.colorSpace=SRGBColorSpace}if('def Shader "normal_texture"'in e){const o=e['def Shader "normal_texture"'];t.normalMap=d(o),t.normalMap.colorSpace=NoColorSpace}}return t}(function(e){if(e){if("rel material:binding"in e){const t=e["rel material:binding"].replace(/^<\//,"").replace(/>$/,"").split("/");return p(i,` "${t[1]}"`)}return p(e)}}(e));t&&t.hasAttribute("color")&&(o.vertexColors=!0);const r=t?new Mesh(t,o):new Object3D;if("matrix4d xformOp:transform"in e){const t=JSON.parse("["+e["matrix4d xformOp:transform"].replace(/[()]*/g,"")+"]");r.matrix.fromArray(t),r.matrix.decompose(r.position,r.quaternion,r.scale)}return r}const h=new Group;return function e(t,o){for(const r in t)if(r.startsWith("def Scope"))e(t[r],o);else if(r.startsWith("def Xform")){const n=m(t[r]);/def Xform "(\w+)"/.test(r)&&(n.name=/def Xform "(\w+)"/.exec(r)[1]),o.add(n),e(t[r],n)}}(i,h),h}}export{USDZLoader};