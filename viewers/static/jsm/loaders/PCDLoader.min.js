import{BufferGeometry,Color,FileLoader,Float32BufferAttribute,Int32BufferAttribute,Loader,Matrix3,Matrix4,Points,PointsMaterial,Quaternion,SRGBColorSpace,Vector3}from"three";class PCDLoader extends Loader{constructor(e){super(e),this.littleEndian=!0}load(e,t,i,n){const s=this,r=new FileLoader(s.manager);r.setPath(s.path),r.setResponseType("arraybuffer"),r.setRequestHeader(s.requestHeader),r.setWithCredentials(s.withCredentials),r.load(e,(function(i){try{t(s.parse(i))}catch(t){n?n(t):console.error(t),s.manager.itemError(e)}}),i,n)}_unpackRGBA(e){return{r:e>>16&255,g:e>>8&255,b:e>>0&255,a:e>>24&255}}_getDataView(e,t,i,n){switch(i){case"F":return 8===n?e.getFloat64(t,this.littleEndian):e.getFloat32(t,this.littleEndian);case"I":return 1===n?e.getInt8(t):2===n?e.getInt16(t,this.littleEndian):e.getInt32(t,this.littleEndian);case"U":return 1===n?e.getUint8(t):2===n?e.getUint16(t,this.littleEndian):e.getUint32(t,this.littleEndian)}}parse(e){const t=function(e){const t={},i=new Uint8Array(e);let n="",s="",r=0,a=!1;const o=i.length;for(;r<o&&!1===a;){const e=String.fromCharCode(i[r++]);"\n"===e||"\r"===e?(s.trim().toLowerCase().startsWith("data")&&(a=!0),s=""):s+=e,n+=e}const l=n.search(/[\r\n]DATA\s(\S*)\s/i),f=/[\r\n]DATA\s(\S*)\s/i.exec(n.slice(l-1));if(t.data=f[1],t.headerLen=f[0].length+l,t.str=n.slice(0,t.headerLen),t.str=t.str.replace(/#.*/gi,""),t.version=/^VERSION (.*)/im.exec(t.str),t.fields=/^FIELDS (.*)/im.exec(t.str),t.size=/^SIZE (.*)/im.exec(t.str),t.type=/^TYPE (.*)/im.exec(t.str),t.count=/^COUNT (.*)/im.exec(t.str),t.width=/^WIDTH (.*)/im.exec(t.str),t.height=/^HEIGHT (.*)/im.exec(t.str),t.viewpoint=/^VIEWPOINT (.*)/im.exec(t.str),t.points=/^POINTS (.*)/im.exec(t.str),null!==t.version&&(t.version=parseFloat(t.version[1])),t.fields=null!==t.fields?t.fields[1].split(" "):[],null!==t.type&&(t.type=t.type[1].split(" ")),null!==t.width&&(t.width=parseInt(t.width[1])),null!==t.height&&(t.height=parseInt(t.height[1])),null!==t.viewpoint&&(t.viewpoint=t.viewpoint[1]),null!==t.points&&(t.points=parseInt(t.points[1],10)),null===t.points&&(t.points=t.width*t.height),null!==t.size&&(t.size=t.size[1].split(" ").map((function(e){return parseInt(e,10)}))),null!==t.count)t.count=t.count[1].split(" ").map((function(e){return parseInt(e,10)}));else{t.count=[];for(let e=0,i=t.fields.length;e<i;e++)t.count.push(1)}t.offset={};let d=0;for(let e=0,i=t.fields.length;e<i;e++)"ascii"===t.data?t.offset[t.fields[e]]=e:(t.offset[t.fields[e]]=d,d+=t.size[e]*t.count[e]);return t.rowSize=d,t}(e),i=[],n=[],s=[],r=[],a=[],o=[],l=[],f=new Color;if("ascii"===t.data){const d=t.offset,h=(new TextDecoder).decode(e).slice(t.headerLen).split("\n");for(let e=0,p=h.length;e<p;e++){if(""===h[e])continue;const p=h[e].split(" ");if(void 0!==d.x&&(i.push(parseFloat(p[d.x])),i.push(parseFloat(p[d.y])),i.push(parseFloat(p[d.z]))),void 0!==d.rgb){const e=t.fields.findIndex((e=>"rgb"===e)),i=t.type[e],n=parseFloat(p[d.rgb]);let r=n;if("F"===i){const e=new Float32Array(1);e[0]=n,r=new Int32Array(e.buffer)[0]}const a=(r>>16&255)/255,o=(r>>8&255)/255,l=(r>>0&255)/255;f.setRGB(a,o,l,SRGBColorSpace),s.push(f.r,f.g,f.b)}if(void 0!==d.rgba){const e=t.fields.indexOf("rgba"),i=t.type[e];let n=Number(p[d.rgba]);if("F"===i){const e=new Float32Array(1);e[0]=n,n=new Int32Array(e.buffer)[0]}const{r:a,g:o,b:l,a:h}=this._unpackRGBA(n);f.setRGB(a/255,o/255,l/255,SRGBColorSpace),s.push(f.r,f.g,f.b),r.push(h/255)}void 0!==d.normal_x&&(n.push(parseFloat(p[d.normal_x])),n.push(parseFloat(p[d.normal_y])),n.push(parseFloat(p[d.normal_z]))),void 0!==d.intensity&&a.push(parseFloat(p[d.intensity])),void 0!==d.classification&&o.push(parseInt(p[d.classification])),void 0!==d.label&&l.push(parseInt(p[d.label]))}}if("binary_compressed"===t.data){const d=new Uint32Array(e.slice(t.headerLen,t.headerLen+8)),h=d[0],p=d[1],u=function(e,t){const i=e.length,n=new Uint8Array(t);let s,r,a,o=0,l=0;do{if(s=e[o++],s<32){if(s++,l+s>t)throw new Error("Output buffer is not large enough");if(o+s>i)throw new Error("Invalid compressed data");do{n[l++]=e[o++]}while(--s)}else{if(r=s>>5,a=l-((31&s)<<8)-1,o>=i)throw new Error("Invalid compressed data");if(7===r&&(r+=e[o++],o>=i))throw new Error("Invalid compressed data");if(a-=e[o++],l+r+2>t)throw new Error("Output buffer is not large enough");if(a<0)throw new Error("Invalid compressed data");if(a>=l)throw new Error("Invalid compressed data");do{n[l++]=n[a++]}while(2+--r)}}while(o<i);return n}(new Uint8Array(e,t.headerLen+8,h),p),c=new DataView(u.buffer,u.byteOffset,u.byteLength),g={};let w=0;for(let e=0;e<t.fields.length;e++){const i=t.fields[e],n=t.size[e],s=t.count[e];g[i]=w,w+=n*s*t.points}for(let e=0;e<t.points;e++){if(void 0!==g.x){const n=t.fields.indexOf("x"),s=t.fields.indexOf("y"),r=t.fields.indexOf("z"),a=t.size[n],o=t.size[s],l=t.size[r],f=t.type[n],d=t.type[s],h=t.type[r],p=this._getDataView(c,g.x+a*e,f,a),u=this._getDataView(c,g.y+o*e,d,o),w=this._getDataView(c,g.z+l*e,h,l);if(!Number.isFinite(p)||!Number.isFinite(u)||!Number.isFinite(w))continue;i.push(p,u,w)}if(void 0!==g.rgb){const i=t.fields.indexOf("rgb"),n=t.size[i];let r;if("F"===t.type[i]){const t=this._getDataView(c,g.rgb+n*e,"F",n),i=new Float32Array(1);i[0]=t,r=new Int32Array(i.buffer)[0]}else r=c.getUint32(g.rgb+n*e,this.littleEndian);const a=r>>16&255,o=r>>8&255,l=r>>0&255;f.setRGB(a/255,o/255,l/255,SRGBColorSpace),s.push(f.r,f.g,f.b)}if(void 0!==g.rgba){const i=t.fields.indexOf("rgba"),n=t.size[i];let a;if("F"===t.type[i]){const t=this._getDataView(c,g.rgba+n*e,"F",n),i=new Float32Array(1);i[0]=t,a=new Int32Array(i.buffer)[0]}else a=c.getUint32(g.rgba+n*e,this.littleEndian);const{r:o,g:l,b:d,a:h}=this._unpackRGBA(a);f.setRGB(o/255,l/255,d/255,SRGBColorSpace),s.push(f.r,f.g,f.b),r.push(h/255)}if(void 0!==g.normal_x){const i=t.fields.indexOf("normal_x"),s=t.fields.indexOf("normal_y"),r=t.fields.indexOf("normal_z"),a=t.size[i],o=t.size[s],l=t.size[r],f=t.type[i],d=t.type[s],h=t.type[r];n.push(this._getDataView(c,g.normal_x+a*e,f,a)),n.push(this._getDataView(c,g.normal_y+o*e,d,o)),n.push(this._getDataView(c,g.normal_z+l*e,h,l))}if(void 0!==g.intensity){const i=t.fields.indexOf("intensity"),n=t.size[i],s=t.type[i];a.push(this._getDataView(c,g.intensity+n*e,s,n))}if(void 0!==g.classification){const i=t.fields.indexOf("classification"),n=t.size[i],s=t.type[i];o.push(this._getDataView(c,g.classification+n*e,s,n))}if(void 0!==g.label){const i=t.fields.indexOf("label"),n=t.size[i];l.push(c.getInt32(g.label+n*e,this.littleEndian))}}}if("binary"===t.data){const d=new DataView(e,t.headerLen),h=t.offset;for(let e=0,p=0;e<t.points;e++,p+=t.rowSize){if(void 0!==h.x){const e=t.fields.indexOf("x"),n=t.fields.indexOf("y"),s=t.fields.indexOf("z");i.push(this._getDataView(d,p+h.x,t.type[e],t.size[e])),i.push(this._getDataView(d,p+h.y,t.type[n],t.size[n])),i.push(this._getDataView(d,p+h.z,t.type[s],t.size[s]))}if(void 0!==h.rgb){const e=d.getUint8(p+h.rgb+2)/255,t=d.getUint8(p+h.rgb+1)/255,i=d.getUint8(p+h.rgb+0)/255;f.setRGB(e,t,i,SRGBColorSpace),s.push(f.r,f.g,f.b)}if(void 0!==h.rgba){const e=d.getUint32(p+h.rgba,this.littleEndian),{r:t,g:i,b:n,a:a}=this._unpackRGBA(e);f.setRGB(t/255,i/255,n/255,SRGBColorSpace),s.push(f.r,f.g,f.b),r.push(a/255)}if(void 0!==h.normal_x){const e=t.fields.indexOf("normal_x"),i=t.fields.indexOf("normal_y"),s=t.fields.indexOf("normal_z");n.push(this._getDataView(d,p+h.normal_x,t.type[e],t.size[e])),n.push(this._getDataView(d,p+h.normal_y,t.type[i],t.size[i])),n.push(this._getDataView(d,p+h.normal_z,t.type[s],t.size[s]))}if(void 0!==h.intensity){const e=t.fields.indexOf("intensity");a.push(this._getDataView(d,p+h.intensity,t.type[e],t.size[e]))}if(void 0!==h.classification){const e=t.fields.indexOf("classification");o.push(this._getDataView(d,p+h.classification,t.type[e],t.size[e]))}void 0!==h.label&&l.push(d.getInt32(p+h.label,this.littleEndian))}}const d=new BufferGeometry;if(i.length>0&&d.setAttribute("position",new Float32BufferAttribute(i,3)),n.length>0&&d.setAttribute("normal",new Float32BufferAttribute(n,3)),s.length>0&&d.setAttribute("color",new Float32BufferAttribute(s,3)),r.length>0&&d.setAttribute("alpha",new Float32BufferAttribute(r,1)),a.length>0&&d.setAttribute("intensity",new Float32BufferAttribute(a,1)),o.length>0&&d.setAttribute("classification",new Int32BufferAttribute(o,1)),l.length>0&&d.setAttribute("label",new Int32BufferAttribute(l,1)),d.computeBoundingSphere(),t.viewpoint){const e=t.viewpoint.trim().split(/\s+/).map(Number);if(e.length>=7){const[t,i,n,s,r,a,o]=e,l=new Vector3(t,i,n),f=new Quaternion(r,a,o,s),h=new Vector3(1,1,1),p=new Matrix4;if(Math.abs(f.x)<1e-6&&Math.abs(f.y)<1e-6&&Math.abs(f.z)<1e-6&&Math.abs(f.w-1)<1e-6&&d.rotateX(-Math.PI/2),p.compose(l,f,h),d.applyMatrix4(p),d.attributes.normal){const e=(new Matrix3).getNormalMatrix(p);d.attributes.normal.applyNormalMatrix(e)}}}const h=new PointsMaterial({size:.005});return s.length>0&&(h.vertexColors=!0),new Points(d,h)}}export{PCDLoader};