THREE.BufferGeometryUtils=class{static computeTangents(t){t.computeTangents()}static mergeBufferGeometries(t,e=!1){const r=null!==t[0].index,n=new Set(Object.keys(t[0].attributes)),o=new Set(Object.keys(t[0].morphAttributes)),s={},i={},u=t[0].morphTargetsRelative,a=new THREE.BufferGeometry;let l=0;for(let f=0;f<t.length;++f){const c=t[f];let m=0;if(r!==(null!==c.index))return null;for(const t in c.attributes){if(!n.has(t))return null;void 0===s[t]&&(s[t]=[]),s[t].push(c.attributes[t]),m++}if(m!==n.size)return null;if(u!==c.morphTargetsRelative)return null;for(const t in c.morphAttributes){if(!o.has(t))return null;void 0===i[t]&&(i[t]=[]),i[t].push(c.morphAttributes[t])}if(a.userData.mergedUserData=a.userData.mergedUserData||[],a.userData.mergedUserData.push(c.userData),e){let t;if(r)t=c.index.count;else{if(void 0===c.attributes.position)return null;t=c.attributes.position.count}a.addGroup(l,t,f),l+=t}}if(r){let e=0;const r=[];for(let n=0;n<t.length;++n){const o=t[n].index;for(let t=0;t<o.count;++t)r.push(o.getX(t)+e);e+=t[n].attributes.position.count}a.setIndex(r)}for(const t in s){const e=this.mergeBufferAttributes(s[t]);if(!e)return null;a.setAttribute(t,e)}for(const t in i){const e=i[t][0].length;if(0===e)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let n=0;n<i[t].length;++n)e.push(i[t][n][r]);const n=this.mergeBufferAttributes(e);if(!n)return null;a.morphAttributes[t].push(n)}}return a}static mergeBufferAttributes(t){let e,r,n,o=0;for(let s=0;s<t.length;++s){const i=t[s];if(i.isInterleavedBufferAttribute)return null;if(void 0===e&&(e=i.array.constructor),e!==i.array.constructor)return null;if(void 0===r&&(r=i.itemSize),r!==i.itemSize)return null;if(void 0===n&&(n=i.normalized),n!==i.normalized)return null;o+=i.array.length}const s=new e(o);let i=0;for(let e=0;e<t.length;++e)s.set(t[e].array,i),i+=t[e].array.length;return new THREE.BufferAttribute(s,r,n)}static interleaveAttributes(t){let e,r=0,n=0;for(let o=0,s=t.length;o<s;++o){const s=t[o];if(void 0===e&&(e=s.array.constructor),e!==s.array.constructor)return null;r+=s.array.length,n+=s.itemSize}const o=new THREE.InterleavedBuffer(new e(r),n);let s=0;const i=[],u=["getX","getY","getZ","getW"],a=["setX","setY","setZ","setW"];for(let e=0,r=t.length;e<r;e++){const r=t[e],n=r.itemSize,l=r.count,f=new THREE.InterleavedBufferAttribute(o,n,s,r.normalized);i.push(f),s+=n;for(let t=0;t<l;t++)for(let e=0;e<n;e++)f[a[e]](t,r[u[e]](t))}return i}static estimateBytesUsed(t){let e=0;for(const r in t.attributes){const n=t.attributes[r];e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}const r=t.index;return e+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,e}static mergeVertices(t,e=1e-4){e=Math.max(e,Number.EPSILON);const r={},n=t.index,o=t.attributes.position,s=n?n.count:o.count;let i=0;const u=Object.keys(t.attributes),a={},l={},f=[],c=["getX","getY","getZ","getW"];for(let e=0,r=u.length;e<r;e++){const r=u[e];a[r]=[];const n=t.morphAttributes[r];n&&(l[r]=new Array(n.length).fill().map((()=>[])))}const m=Math.log10(1/e),h=Math.pow(10,m);for(let e=0;e<s;e++){const o=n?n.getX(e):e;let s="";for(let e=0,r=u.length;e<r;e++){const r=u[e],n=t.attributes[r],i=n.itemSize;for(let t=0;t<i;t++)s+=~~(n[c[t]](o)*h)+","}if(s in r)f.push(r[s]);else{for(let e=0,r=u.length;e<r;e++){const r=u[e],n=t.attributes[r],s=t.morphAttributes[r],i=n.itemSize,f=a[r],m=l[r];for(let t=0;t<i;t++){const e=c[t];if(f.push(n[e](o)),s)for(let t=0,r=s.length;t<r;t++)m[t].push(s[t][e](o))}}r[s]=i,f.push(i),i++}}const d=t.clone();for(let e=0,r=u.length;e<r;e++){const r=u[e],n=t.attributes[r],o=new n.array.constructor(a[r]),s=new THREE.BufferAttribute(o,n.itemSize,n.normalized);if(d.setAttribute(r,s),r in l)for(let e=0;e<l[r].length;e++){const n=t.morphAttributes[r][e],o=new n.array.constructor(l[r][e]),s=new THREE.BufferAttribute(o,n.itemSize,n.normalized);d.morphAttributes[r][e]=s}}return d.setIndex(f),d}static toTrianglesDrawMode(t,e){if(e===THREE.TrianglesDrawMode)return t;if(e===THREE.TriangleFanDrawMode||e===THREE.TriangleStripDrawMode){let r=t.index;if(null===r){const e=[],n=t.attributes.position;if(void 0===n)return t;for(let t=0;t<n.count;t++)e.push(t);t.setIndex(e),r=t.index}const n=r.count-2,o=[];if(e===THREE.TriangleFanDrawMode)for(let t=1;t<=n;t++)o.push(r.getX(0)),o.push(r.getX(t)),o.push(r.getX(t+1));else for(let t=0;t<n;t++)t%2==0?(o.push(r.getX(t)),o.push(r.getX(t+1)),o.push(r.getX(t+2))):(o.push(r.getX(t+2)),o.push(r.getX(t+1)),o.push(r.getX(t)));o.length;const s=t.clone();return s.setIndex(o),s.clearGroups(),s}return t}static computeMorphedAttributes(t){if(!0!==t.geometry.isBufferGeometry)return null;const e=new THREE.Vector3,r=new THREE.Vector3,n=new THREE.Vector3,o=new THREE.Vector3,s=new THREE.Vector3,i=new THREE.Vector3,u=new THREE.Vector3,a=new THREE.Vector3,l=new THREE.Vector3;function f(t,f,c,m,h,d,g,b,p){e.fromBufferAttribute(c,d),r.fromBufferAttribute(c,g),n.fromBufferAttribute(c,b);const E=t.morphTargetInfluences;if(f.morphTargets&&m&&E){u.set(0,0,0),a.set(0,0,0),l.set(0,0,0);for(let t=0,f=m.length;t<f;t++){const f=E[t],c=m[t];0!==f&&(o.fromBufferAttribute(c,d),s.fromBufferAttribute(c,g),i.fromBufferAttribute(c,b),h?(u.addScaledVector(o,f),a.addScaledVector(s,f),l.addScaledVector(i,f)):(u.addScaledVector(o.sub(e),f),a.addScaledVector(s.sub(r),f),l.addScaledVector(i.sub(n),f)))}e.add(u),r.add(a),n.add(l)}t.isSkinnedMesh&&(t.boneTransform(d,e),t.boneTransform(g,r),t.boneTransform(b,n)),p[3*d+0]=e.x,p[3*d+1]=e.y,p[3*d+2]=e.z,p[3*g+0]=r.x,p[3*g+1]=r.y,p[3*g+2]=r.z,p[3*b+0]=n.x,p[3*b+1]=n.y,p[3*b+2]=n.z}const c=t.geometry,m=t.material;let h,d,g;const b=c.index,p=c.attributes.position,E=c.morphAttributes.position,A=c.morphTargetsRelative,T=c.attributes.normal,w=c.morphAttributes.position,y=c.groups,R=c.drawRange;let S,B,x,H,z,M,X,v;const V=new Float32Array(p.count*p.itemSize),D=new Float32Array(T.count*T.itemSize);if(null!==b)if(Array.isArray(m))for(S=0,x=y.length;S<x;S++)for(z=y[S],M=m[z.materialIndex],X=Math.max(z.start,R.start),v=Math.min(z.start+z.count,R.start+R.count),B=X,H=v;B<H;B+=3)h=b.getX(B),d=b.getX(B+1),g=b.getX(B+2),f(t,M,p,E,A,h,d,g,V),f(t,M,T,w,A,h,d,g,D);else for(X=Math.max(0,R.start),v=Math.min(b.count,R.start+R.count),S=X,x=v;S<x;S+=3)h=b.getX(S),d=b.getX(S+1),g=b.getX(S+2),f(t,m,p,E,A,h,d,g,V),f(t,m,T,w,A,h,d,g,D);else if(void 0!==p)if(Array.isArray(m))for(S=0,x=y.length;S<x;S++)for(z=y[S],M=m[z.materialIndex],X=Math.max(z.start,R.start),v=Math.min(z.start+z.count,R.start+R.count),B=X,H=v;B<H;B+=3)h=B,d=B+1,g=B+2,f(t,M,p,E,A,h,d,g,V),f(t,M,T,w,A,h,d,g,D);else for(X=Math.max(0,R.start),v=Math.min(p.count,R.start+R.count),S=X,x=v;S<x;S+=3)h=S,d=S+1,g=S+2,f(t,m,p,E,A,h,d,g,V),f(t,m,T,w,A,h,d,g,D);return{positionAttribute:p,normalAttribute:T,morphedPositionAttribute:new THREE.Float32BufferAttribute(V,3),morphedNormalAttribute:new THREE.Float32BufferAttribute(D,3)}}};