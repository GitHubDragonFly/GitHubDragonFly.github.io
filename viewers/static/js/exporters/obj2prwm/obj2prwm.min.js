!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.obj2prwm=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";var objParser=require("wavefront-obj-parser"),computeNormals=require("./utils/compute-normals"),prwm=require("prwm");function serializeIndexed(objData,usePositions,useNormals,useUvs){var nbPolygons=objData.vertexPositionIndices.length/4,indicesMapping={},indices=[],vertices=[],normals=[],uvs=[],i,k,vertexIndex,normalIndex,uvIndex,mapped,index,nextIndex=0;var mustGenerateNewNormals=useNormals&&(!objData.vertexNormals||objData.vertexNormals.length===0);for(i=0;i<nbPolygons;i++){for(k=0;k<3;k++){vertexIndex=objData.vertexPositionIndices[i*4+k];normalIndex=objData.vertexPositionIndices[i*4+k];uvIndex=objData.vertexUVIndices[i*4+k];mapped=(usePositions?vertexIndex+":":":")+(useNormals?normalIndex+":":":")+(useUvs?uvIndex+":":":");index=indicesMapping[mapped];if(typeof index==="undefined"){index=nextIndex;indicesMapping[mapped]=index;nextIndex++;if(usePositions){vertices.push(objData.vertexPositions[vertexIndex*3],objData.vertexPositions[vertexIndex*3+1],objData.vertexPositions[vertexIndex*3+2])}if(useNormals&&!mustGenerateNewNormals){normals.push(objData.vertexNormals[normalIndex*3],objData.vertexNormals[normalIndex*3+1],objData.vertexNormals[normalIndex*3+2])}if(useUvs){uvs.push(objData.vertexUVs[uvIndex*2],objData.vertexUVs[uvIndex*2+1])}}indices.push(index)}}if(mustGenerateNewNormals){computeNormals(indices,vertices,normals)}return{indices:indices,vertices:vertices,normals:normals,uvs:uvs}}function serializeNonIndexed(objData,usePositions,useNormals,useUvs){var nbPolygons=objData.vertexPositionIndices.length/4,vertices=[],normals=[],uvs=[],i,k,vertexIndex,normalIndex,uvIndex;var mustGenerateNewNormals=useNormals&&(!objData.vertexNormals||objData.vertexNormals.length===0);for(i=0;i<nbPolygons;i++){for(k=0;k<3;k++){if(usePositions){vertexIndex=objData.vertexPositionIndices[i*4+k];vertices.push(objData.vertexPositions[vertexIndex*3],objData.vertexPositions[vertexIndex*3+1],objData.vertexPositions[vertexIndex*3+2])}if(useNormals&&!mustGenerateNewNormals){normalIndex=objData.vertexNormalIndices[i*4+k];normals.push(objData.vertexNormals[normalIndex*3],objData.vertexNormals[normalIndex*3+1],objData.vertexNormals[normalIndex*3+2])}if(useUvs){uvIndex=objData.vertexUVIndices[i*4+k];uvs.push(objData.vertexUVs[uvIndex*2],objData.vertexUVs[uvIndex*2+1])}}}if(mustGenerateNewNormals){computeNormals(null,vertices,normals)}return{indices:null,vertices:vertices,normals:normals,uvs:uvs}}var nbVertices=null;module.exports={convert:function(objString,options){var log=options.quiet?function noop(){}:function log(s){console.log(s)};log(" * Parsing WaveFront OBJ data");var objData=objParser(objString);log(" * Formatting data");var serialized=options.indexed?serializeIndexed(objData,options.positions,options.normals,options.uvs):serializeNonIndexed(objData,options.positions,options.normals,options.uvs);var attributes={};nbVertices=0;if(options.positions){attributes["position"]={cardinality:3,normalized:false,values:new Float32Array(serialized.vertices)};nbVertices=serialized.vertices.length/3}if(options.normals){attributes["normal"]={cardinality:3,normalized:false,values:new Float32Array(serialized.normals)};nbVertices=serialized.normals.length/3}if(options.uvs){attributes["uv"]={cardinality:2,normalized:false,values:new Float32Array(serialized.uvs)};nbVertices=serialized.uvs.length/2}return prwm.encode(attributes,serialized.indices?nbVertices>65535?new Uint32Array(serialized.indices):new Uint16Array(serialized.indices):null,options.bigEndian)},getNumberOfVertices:function(){return nbVertices}}},{"./utils/compute-normals":8,prwm:2,"wavefront-obj-parser":7}],2:[function(require,module,exports){"use strict";var attributeTypes=require("./prwm/attribute-types");module.exports={version:1,Int:attributeTypes.Int,Float:attributeTypes.Float,isBigEndianPlatform:require("./utils/is-big-endian-platform"),encode:require("./prwm/encode"),decode:require("./prwm/decode")}},{"./prwm/attribute-types":3,"./prwm/decode":4,"./prwm/encode":5,"./utils/is-big-endian-platform":6}],3:[function(require,module,exports){"use strict";module.exports={Float:0,Int:1}},{}],4:[function(require,module,exports){"use strict";var isBigEndianPlatform=require("../utils/is-big-endian-platform");var InvertedEncodingTypes=[null,Float32Array,null,Int8Array,Int16Array,null,Int32Array,Uint8Array,Uint16Array,null,Uint32Array];var getMethods={Uint16Array:"getUint16",Uint32Array:"getUint32",Int16Array:"getInt16",Int32Array:"getInt32",Float32Array:"getFloat32"};function copyFromBuffer(sourceArrayBuffer,viewType,position,length,fromBigEndian){var bytesPerElement=viewType.BYTES_PER_ELEMENT,result;if(fromBigEndian===isBigEndianPlatform()||bytesPerElement===1){result=new viewType(sourceArrayBuffer,position,length)}else{var readView=new DataView(sourceArrayBuffer,position,length*bytesPerElement),getMethod=getMethods[viewType.name],littleEndian=!fromBigEndian;result=new viewType(length);for(var i=0;i<length;i++){result[i]=readView[getMethod](i*bytesPerElement,littleEndian)}}return result}function decode(buffer,offset){offset=offset||0;var array=new Uint8Array(buffer,offset),version=array[0],flags=array[1],indexedGeometry=!!(flags>>7),indicesType=flags>>6&1,bigEndian=(flags>>5&1)===1,attributesNumber=flags&31,valuesNumber=0,indicesNumber=0;if(bigEndian){valuesNumber=(array[2]<<16)+(array[3]<<8)+array[4];indicesNumber=(array[5]<<16)+(array[6]<<8)+array[7]}else{valuesNumber=array[2]+(array[3]<<8)+(array[4]<<16);indicesNumber=array[5]+(array[6]<<8)+(array[7]<<16)}if(offset/4%1!==0){throw new Error("PRWM decoder: Offset should be a multiple of 4, received "+offset)}if(version===0){throw new Error("PRWM decoder: Invalid format version: 0")}else if(version!==1){throw new Error("PRWM decoder: Unsupported format version: "+version)}if(!indexedGeometry){if(indicesType!==0){throw new Error("PRWM decoder: Indices type must be set to 0 for non-indexed geometries")}else if(indicesNumber!==0){throw new Error("PRWM decoder: Number of indices must be set to 0 for non-indexed geometries")}}var pos=8;var attributes={},attributeName,char,attributeNormalized,attributeType,cardinality,encodingType,arrayType,values,i;for(i=0;i<attributesNumber;i++){attributeName="";while(pos<array.length){char=array[pos];pos++;if(char===0){break}else{attributeName+=String.fromCharCode(char)}}flags=array[pos];attributeType=flags>>7&1;attributeNormalized=!!(flags>>6&1);cardinality=(flags>>4&3)+1;encodingType=flags&15;arrayType=InvertedEncodingTypes[encodingType];pos++;pos=Math.ceil(pos/4)*4;values=copyFromBuffer(buffer,arrayType,pos+offset,cardinality*valuesNumber,bigEndian);pos+=arrayType.BYTES_PER_ELEMENT*cardinality*valuesNumber;attributes[attributeName]={type:attributeType,normalized:attributeNormalized,cardinality:cardinality,values:values}}pos=Math.ceil(pos/4)*4;var indices=null;if(indexedGeometry){indices=copyFromBuffer(buffer,indicesType===1?Uint32Array:Uint16Array,pos+offset,indicesNumber,bigEndian)}return{version:version,bigEndian:bigEndian,attributes:attributes,indices:indices}}module.exports=decode},{"../utils/is-big-endian-platform":6}],5:[function(require,module,exports){"use strict";var isBigEndianPlatform=require("../utils/is-big-endian-platform"),attributeTypes=require("./attribute-types");var EncodingTypes={Float32Array:1,Int8Array:3,Int16Array:4,Int32Array:6,Uint8Array:7,Uint16Array:8,Uint32Array:10};var setMethods={Uint16Array:"setUint16",Uint32Array:"setUint32",Int16Array:"setInt16",Int32Array:"setInt32",Float32Array:"setFloat32"};function copyToBuffer(sourceTypedArray,destinationArrayBuffer,position,bigEndian){var length=sourceTypedArray.length,bytesPerElement=sourceTypedArray.BYTES_PER_ELEMENT;var writeArray=new sourceTypedArray.constructor(destinationArrayBuffer,position,length);if(bigEndian===isBigEndianPlatform()||bytesPerElement===1){writeArray.set(sourceTypedArray.subarray(0,length))}else{var writeView=new DataView(destinationArrayBuffer,position,length*bytesPerElement),setMethod=setMethods[sourceTypedArray.constructor.name],littleEndian=!bigEndian,i=0;for(i=0;i<length;i++){writeView[setMethod](i*bytesPerElement,sourceTypedArray[i],littleEndian)}}return writeArray}function encode(attributes,indices,bigEndian){var attributeKeys=attributes?Object.keys(attributes):[],indexedGeometry=!!indices,i,j;if(attributeKeys.length===0){throw new Error("PRWM encoder: The model must have at least one attribute")}if(attributeKeys.length>31){throw new Error("PRWM encoder: The model can have at most 31 attributes")}for(i=0;i<attributeKeys.length;i++){if(!EncodingTypes.hasOwnProperty(attributes[attributeKeys[i]].values.constructor.name)){throw new Error("PRWM encoder: Unsupported attribute values type: "+attributes[attributeKeys[i]].values.constructor.name)}}if(indexedGeometry&&indices.constructor.name!=="Uint16Array"&&indices.constructor.name!=="Uint32Array"){throw new Error("PRWM encoder: The indices must be represented as an Uint16Array or an Uint32Array")}var valuesNumber=attributes[attributeKeys[0]].values.length/attributes[attributeKeys[0]].cardinality|0,indicesNumber=indexedGeometry?indices.length:0,indicesType=indexedGeometry&&indices.constructor.name==="Uint32Array"?1:0;var totalLength=8,attributeKey,attribute,attributeType,attributeNormalized;for(i=0;i<attributeKeys.length;i++){attributeKey=attributeKeys[i];attribute=attributes[attributeKey];totalLength+=attributeKey.length+2;totalLength=Math.ceil(totalLength/4)*4;totalLength+=attribute.values.byteLength}if(indexedGeometry){totalLength=Math.ceil(totalLength/4)*4;totalLength+=indices.byteLength}var buffer=new ArrayBuffer(totalLength),array=new Uint8Array(buffer);array[0]=1;array[1]=indexedGeometry<<7|indicesType<<6|(bigEndian?1:0)<<5|attributeKeys.length&31;if(bigEndian){array[2]=valuesNumber>>16&255;array[3]=valuesNumber>>8&255;array[4]=valuesNumber&255;array[5]=indicesNumber>>16&255;array[6]=indicesNumber>>8&255;array[7]=indicesNumber&255}else{array[2]=valuesNumber&255;array[3]=valuesNumber>>8&255;array[4]=valuesNumber>>16&255;array[5]=indicesNumber&255;array[6]=indicesNumber>>8&255;array[7]=indicesNumber>>16&255}var pos=8;for(i=0;i<attributeKeys.length;i++){attributeKey=attributeKeys[i];attribute=attributes[attributeKey];attributeType=typeof attribute.type==="undefined"?attributeTypes.Float:attribute.type;attributeNormalized=!!attribute.normalized?1:0;for(j=0;j<attributeKey.length;j++,pos++){array[pos]=attributeKey.charCodeAt(j)&127||95}pos++;array[pos]=attributeType<<7|attributeNormalized<<6|(attribute.cardinality-1&3)<<4|EncodingTypes[attribute.values.constructor.name]&15;pos++;pos=Math.ceil(pos/4)*4;var attributesWriteArray=copyToBuffer(attribute.values,buffer,pos,bigEndian);pos+=attributesWriteArray.byteLength}if(indexedGeometry){pos=Math.ceil(pos/4)*4;copyToBuffer(indices,buffer,pos,bigEndian)}return buffer}module.exports=encode},{"../utils/is-big-endian-platform":6,"./attribute-types":3}],6:[function(require,module,exports){"use strict";var bigEndianPlatform=null;function isBigEndianPlatform(){if(bigEndianPlatform===null){var buffer=new ArrayBuffer(2),uint8Array=new Uint8Array(buffer),uint16Array=new Uint16Array(buffer);uint8Array[0]=170;uint8Array[1]=187;bigEndianPlatform=uint16Array[0]===43707}return bigEndianPlatform}module.exports=isBigEndianPlatform},{}],7:[function(require,module,exports){module.exports=ParseWavefrontObj;var vertexInfoNameMap={v:"vertexPositions",vt:"vertexUVs",vn:"vertexNormals"};function ParseWavefrontObj(wavefrontString){"use strict";var parsedJSON={vertexNormals:[],vertexUVs:[],vertexPositions:[],vertexNormalIndices:[],vertexUVIndices:[],vertexPositionIndices:[]};var linesInWavefrontObj=wavefrontString.split("\n");var currentLine,currentLineTokens,vertexInfoType,i,k;for(i=0;i<linesInWavefrontObj.length;i++){currentLine=linesInWavefrontObj[i];currentLineTokens=currentLine.trim().split(/\s+/);vertexInfoType=vertexInfoNameMap[currentLineTokens[0]];if(vertexInfoType){for(k=1;k<currentLineTokens.length;k++){parsedJSON[vertexInfoType].push(parseFloat(currentLineTokens[k]))}continue}if(currentLineTokens[0]==="f"){for(k=1;k<5;k++){if(k===4&&!currentLineTokens[4]){parsedJSON.vertexPositionIndices.push(-1);parsedJSON.vertexUVIndices.push(-1);parsedJSON.vertexNormalIndices.push(-1)}else{var indices=currentLineTokens[k].split("/");parsedJSON.vertexPositionIndices.push(parseInt(indices[0],10)-1);parsedJSON.vertexUVIndices.push(parseInt(indices[1],10)-1);parsedJSON.vertexNormalIndices.push(parseInt(indices[2],10)-1)}}}}return parsedJSON}},{}],8:[function(require,module,exports){"use strict";var normalizeNormals=function normalizeNormals(normals){var i,x,y,z,n;for(i=0;i<normals.length;i+=3){x=normals[i];y=normals[i+1];z=normals[i+2];n=1/Math.sqrt(x*x+y*y+z*z);normals[i]*=n;normals[i+1]*=n;normals[i+2]*=n}};var computeVertexNormals=function computeVertexNormals(indices,positions,normals){var pA=[0,0,0],pB=[0,0,0],pC=[0,0,0],cb=[0,0,0],ab=[0,0,0],vA,vB,vC,cbx,cby,cbz,i;normals.length=positions.length;for(i=0;i<normals.length;i++){normals[i]=0}if(indices){for(i=0;i<indices.length;i+=3){vA=indices[i]*3;vB=indices[i+1]*3;vC=indices[i+2]*3;pA[0]=positions[vA];pA[1]=positions[vA+1];pA[2]=positions[vA+2];pB[0]=positions[vB];pB[1]=positions[vB+1];pB[2]=positions[vB+2];pC[0]=positions[vC];pC[1]=positions[vC+1];pC[2]=positions[vC+2];cb[0]=pC[0]-pB[0];cb[1]=pC[1]-pB[1];cb[2]=pC[2]-pB[2];ab[0]=pA[0]-pB[0];ab[1]=pA[1]-pB[1];ab[2]=pA[2]-pB[2];cbx=cb[0];cby=cb[1];cbz=cb[2];cb[0]=cby*ab[2]-cbz*ab[1];cb[1]=cbz*ab[0]-cbx*ab[2];cb[2]=cbx*ab[1]-cby*ab[0];normals[vA]+=cb[0];normals[vA+1]+=cb[1];normals[vA+2]+=cb[2];normals[vB]+=cb[0];normals[vB+1]+=cb[1];normals[vB+2]+=cb[2];normals[vC]+=cb[0];normals[vC+1]+=cb[1];normals[vC+2]+=cb[2]}}else{for(i=0;i<positions.length;i+=9){pA[0]=positions[i];pA[1]=positions[i+1];pA[2]=positions[i+2];pB[0]=positions[i+3];pB[1]=positions[i+4];pB[2]=positions[i+5];pC[0]=positions[i+6];pC[1]=positions[i+7];pC[2]=positions[i+8];cb[0]=pC[0]-pB[0];cb[1]=pC[1]-pB[1];cb[2]=pC[2]-pB[2];ab[0]=pA[0]-pB[0];ab[1]=pA[1]-pB[1];ab[2]=pA[2]-pB[2];cbx=cb[0];cby=cb[1];cbz=cb[2];cb[0]=cby*ab[2]-cbz*ab[1];cb[1]=cbz*ab[0]-cbx*ab[2];cb[2]=cbx*ab[1]-cby*ab[0];normals[i]=cb[0];normals[i+1]=cb[1];normals[i+2]=cb[2];normals[i+3]=cb[0];normals[i+4]=cb[1];normals[i+5]=cb[2];normals[i+6]=cb[0];normals[i+7]=cb[1];normals[i+8]=cb[2]}}normalizeNormals(normals)};module.exports=computeVertexNormals},{}]},{},[1])(1)});