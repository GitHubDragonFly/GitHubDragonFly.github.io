var blobs=null,root,bones=[],bone_id,has_bones=!1,has_points_or_lines=!1,isPoints=!1,isLines=!1;THREE.AssimpJSONLoader=function(manager){this.manager=void 0!==manager?manager:THREE.DefaultLoadingManager},THREE.AssimpJSONLoader.prototype={constructor:THREE.AssimpJSONLoader,texturePath:"",load:function(url,onLoad,onProgress,onError,texturePath){scope=this,texturePath&&"string"==typeof texturePath?texturePath.includes(",")?blobs=texturePath.split(","):this.texturePath=texturePath:this.texturePath=this.extractUrlBase(url);var loader=new THREE.FileLoader(this.manager);loader.setCrossOrigin(this.crossOrigin),loader.load(url,(function(text){try{var json=JSON.parse(text),scene,metadata}catch(error){return void onError(error)}if(json&&void 0===json.meshes)onError("Unsupported file");else{if(void 0!==(metadata=json.__metadata__)){if("assimp2json"!==metadata.format)return void onError("Not an assimp2json scene");if(metadata.version<100&&metadata.version>=200)return void onError("Unsupported assimp2json file format version")}(scene=scope.parse(json)).has_bones=has_bones,json.animations&&!0===has_bones&&(scene.animations=json.animations),onLoad(scene)}}),onProgress,onError)},setCrossOrigin:function(value){this.crossOrigin=value},extractUrlBase:function(url){let parts=url.split("/");return parts.pop(),(parts.length<1?".":parts.join("/"))+"/"},parse:function(json){let meshes=this.parseMeshList(json,this.parseMesh),materials=this.parseMaterialList(json,this.parseMaterial);return this.parseObject(json,json.rootnode,meshes,materials)},parseMeshList:function(json,handler){let meshes=new Array(json.meshes.length);for(let i=0;i<json.meshes.length;i++)meshes[i]=handler.call(this,json.meshes[i],json);return meshes},parseMaterialList:function(json,handler){let materials=new Array(json.materials.length);for(let i=0;i<json.materials.length;i++)materials[i]=handler.call(this,json.materials[i],json.textures);return materials},parseMesh:function(mesh,json){var geometry,i,j,e,ee,face,src,a,b,c;for(geometry=new THREE.Geometry,1===mesh.primitivetypes?(isPoints=!0,has_points_or_lines=!0,geometry.isPoints=!0):2===mesh.primitivetypes&&(isLines=!0,has_points_or_lines=!0,geometry.isLines=!0),i=0,e=mesh.vertices.length;i<e;i+=3)geometry.vertices.push(new THREE.Vector3(mesh.vertices[i],mesh.vertices[i+1],mesh.vertices[i+2]));for(i=0,e=mesh.faces.length;i<e;i++)face=new THREE.Face3,src=mesh.faces[i],face.a=src[0],face.b=!0===isPoints?src[0]:src[1],face.c=!0===isPoints?src[0]:!0===isLines?src[1]:src[2],face.materialIndex=0,geometry.faces.push(face);for(mesh.texturecoords=mesh.texturecoords||[],void 0===geometry.faceVertexUvs&&(geometry.faceVertexUvs={}),i=0,e=mesh.texturecoords.length;i<e;i++){function convertTextureCoords(in_uv,out_faces,out_vertex_uvs){for(j=0,ee=out_faces.length;j<ee;j++)face=out_faces[j],a=2*face.a,b=2*face.b,c=2*face.c,out_vertex_uvs.push([new THREE.Vector2(in_uv[a],in_uv[a+1]),new THREE.Vector2(in_uv[b],in_uv[b+1]),new THREE.Vector2(in_uv[c],in_uv[c+1])])}void 0===geometry.faceVertexUvs[i]&&(geometry.faceVertexUvs[i]=[]),convertTextureCoords(mesh.texturecoords[i],geometry.faces,geometry.faceVertexUvs[i])}if(mesh.normals){function convertNormals(in_nor,out_faces){for(i=0,e=out_faces.length;i<e;i++)face=out_faces[i],a=3*face.a,b=3*face.b,c=3*face.c,face.vertexNormals=[new THREE.Vector3(in_nor[a],in_nor[a+1],in_nor[a+2]),new THREE.Vector3(in_nor[b],in_nor[b+1],in_nor[b+2]),new THREE.Vector3(in_nor[c],in_nor[c+1],in_nor[c+2])]}convertNormals(mesh.normals,geometry.faces)}if(mesh.colors&&mesh.colors[0]){function convertColors(in_color,out_faces){function makeColor(start){let col=new THREE.Color;return col.setRGB(in_color[start],in_color[start+1],in_color[start+2]),col}for(i=0,e=out_faces.length;i<e;i++)face=out_faces[i],a=4*face.a,b=4*face.b,c=4*face.c,face.vertexColors=[makeColor(a),makeColor(b),makeColor(c)]}convertColors(mesh.colors[0],geometry.faces)}return mesh.bones&&(this.parseBones(json.rootnode,mesh.bones),geometry.bones=bones,has_bones=!0),geometry.computeFaceNormals(),geometry.computeVertexNormals(),geometry.computeBoundingBox(),geometry.computeBoundingSphere(),isPoints=!1,isLines=!1,geometry},parseMaterial:function(material,textures){let mat=null,scope=this,i,prop,has_textures=[],init_props={color:16777215,flatShading:!1};function toColor(value_arr){let col=new THREE.Color;return col.setRGB(value_arr[0],value_arr[1],value_arr[2]),col}function defaultTexture(){const width=128,height=128,size=16384,data=new Uint8Array(65536),color=new THREE.Color(16777215),r=Math.floor(255*color.r),g=Math.floor(255*color.g),b=Math.floor(255*color.b);for(let i=0;i<size;i++){const stride=4*i;data[stride+0]=r,data[stride+1]=g,data[stride+2]=b,data[stride+3]=255}return new THREE.DataTexture(data,128,128)}for(i in material.properties){if(prop=material.properties[i],"$tex.file"===prop.key?1!==prop.semantic&&2!==prop.semantic&&4!==prop.semantic&&5!==prop.semantic&&6!==prop.semantic||function(semantic){var loader=new THREE.TextureLoader(scope.manager),keyname;let material_url;1===semantic?keyname="map":2===semantic?keyname="specularMap":4===semantic?keyname="emissiveMap":5===semantic?keyname="bumpMap":6===semantic&&(keyname="normalMap"),has_textures.push(keyname);let filename=prop.value;if(!0===prop.value.includes("/")?filename=filename.substring(filename.lastIndexOf("/")+1):!0===filename.includes("\\")&&(filename=filename.substring(filename.lastIndexOf("\\")+1)),!0===filename.includes("*"))try{let texture_index=parseInt(filename.substring(filename.lastIndexOf("*")+1));textures&&textures[texture_index]&&textures[texture_index].data&&(material_url="data:image/"+textures[texture_index].formathint+";base64,"+textures[texture_index].data)}catch(error){console.warn("THREE.AssimpJSONLoader: Texture pointer is not numeric "+filename)}else filename.toLowerCase().endsWith(".dds")?THREE.DDSLoader&&(loader=new THREE.DDSLoader(scope.manager)):filename.toLowerCase().endsWith(".tga")&&THREE.TGALoader&&(loader=new THREE.TGALoader(scope.manager));if(loader.setCrossOrigin(this.crossOrigin),null!==blobs)for(j=0,ee=blobs.length;j<ee;j+=2)blobs[j]===filename&&(material_url=blobs[j+1]);else void 0===material_url&&(material_url=scope.texturePath+"/"+filename);void 0===material_url?console.warn("THREE.AssimpJSONLoader: Cannot find or load texture "+filename):(material_url=material_url.replace(/\\/g,"/"),loader.load(material_url,(function(tex){tex&&(tex.wrapS=tex.wrapT=THREE.RepeatWrapping,mat[keyname]=tex,mat.needsUpdate=!0)})))}(prop.semantic):"?mat.name"===prop.key?init_props.name=prop.value:"$clr.diffuse"===prop.key?init_props.color=toColor(prop.value):"$clr.specular"===prop.key?init_props.specular=toColor(prop.value):"$clr.emissive"===prop.key?init_props.emissive=toColor(prop.value):"$mat.shadingm"===prop.key?prop.value>=1&&(init_props.flatShading=!0):"$mat.shininess"===prop.key&&(init_props.shininess=prop.value),has_textures.length)for(i=0,e=has_textures.length;i<e;i++)init_props[has_textures[i]]=defaultTexture();mat=new THREE.MeshPhongMaterial(init_props)}return mat},parseBones:function(rootnode,mesh_bones){if(mesh_bones)for(bones.length=0,i=0,il=rootnode.children.length;i<il;i++){root=new THREE.Object3D;let root_pos=new THREE.Vector3,root_rotq=new THREE.Quaternion,root_scl=new THREE.Vector3;(new THREE.Matrix4).fromArray(rootnode.children[i].transformation).transpose().decompose(root_pos,root_rotq,root_scl),root.position.x=root_pos.x,root.position.y=root_pos.y,root.position.z=root_pos.z,root.quaternion.x=root_rotq.x,root.quaternion.y=root_rotq.y,root.quaternion.z=root_rotq.z,root.quaternion.w=root_rotq.w,root.scale.x=root_scl.x,root.scale.y=root_scl.y,root.scale.z=root_scl.z,bone_id=0;let current_index=-1;this.traverse(rootnode.children[i].children,current_index,mesh_bones)}},traverse:function(children,current_index,mesh_bones){for(let i=0,il=children.length;i<il;i++){let pos=new THREE.Vector3,rotq=new THREE.Quaternion,scl=new THREE.Vector3,new_bone=new THREE.Bone;new_bone.name=children[i].name,new_bone.transformation=children[i].transformation;let new_bone_transformation=(new THREE.Matrix4).fromArray(children[i].transformation),new_bone_inverse_transformation=new_bone_transformation.getInverse(new_bone_transformation);mesh_bones.every(bone=>{if(bone.name===children[i].name){new_bone.offsetMatrix=bone.offsetmatrix,new_bone.weights=bone.weights;let new_bone_offsetmatrix=(new THREE.Matrix4).fromArray(bone.offsetmatrix),new_bone_inverse_offsetmatrix=new_bone_offsetmatrix.getInverse(new_bone_offsetmatrix);return new_bone_transformation.multiply(new_bone_offsetmatrix).transpose().decompose(pos,rotq,scl),new_bone.position.x=pos.x,new_bone.position.y=pos.y,new_bone.position.z=pos.z,new_bone.quaternion.x=rotq.x,new_bone.quaternion.y=rotq.y,new_bone.quaternion.z=rotq.z,new_bone.quaternion.w=rotq.w,new_bone.scale.x=scl.x,new_bone.scale.y=scl.y,new_bone.scale.z=scl.z,!1}return!0}),bones.push(new_bone),-1===current_index?root.add(new_bone):bones[bone_id-current_index-1].add(new_bone),bone_id+=1,current_index+=1,children[i].children&&children[i].children.length>0&&this.traverse(children[i].children,i,mesh_bones)}},parseObject:function(json,node,meshes,materials){let obj=new THREE.Object3D,i,idx;for(obj.name=node.name||"",obj.matrix=(new THREE.Matrix4).fromArray(node.transformation).transpose(),obj.matrix.decompose(obj.position,obj.quaternion,obj.scale),i=0;node.meshes&&i<node.meshes.length;i++){idx=node.meshes[i];let buffer_geometry="Geometry"===meshes[idx].type?(new THREE.BufferGeometry).fromGeometry(meshes[idx]):meshes[idx];bones.length>0&&(buffer_geometry.bones=bones),meshes[idx].isPoints&&!0===meshes[idx].isPoints?obj.add(new THREE.Points(buffer_geometry,new THREE.PointsMaterial({size:.02,color:materials[json.meshes[idx].materialindex].color}))):meshes[idx].isLines&&!0===meshes[idx].isLines?obj.add(new THREE.LineSegments(buffer_geometry,new THREE.LineBasicMaterial({color:materials[json.meshes[idx].materialindex].color,linewidth:.5}))):obj.add(new THREE.Mesh(buffer_geometry,materials[json.meshes[idx].materialindex]))}for(i=0;node.children&&i<node.children.length;i++)obj.add(this.parseObject(json,node.children[i],meshes,materials));return obj.has_points_or_lines=has_points_or_lines,obj}};